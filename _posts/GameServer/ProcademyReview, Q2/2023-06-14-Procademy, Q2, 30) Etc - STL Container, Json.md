---
title: Procademy, Q2, 30) Etc - STL Container, Json
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. STL**

네트워크 라이브러리에 필요한 RingBuffer, SerializedPacket 등은 적절한 stl이 없기 때문에 직접 구현해야 하지만, 그 외의 콘텐츠 영역에서는 stl을 사용한다. 2003년도가 아니라 2023년도에 취업할 거라면 직접 구현한 컨테이너를 사용하는 것은 되도록 피해야 한다. 과거에는 stl에 버그도 많았고 디버깅도 어려웠기 때문에 서버에서 금기시 됐으나 최근에는 버그도 드물고 조사식도 예쁘게 뽑아주기 때문에 대부분 stl을 사용한다. 단, inline 확장을 쓰지 않으면 사용할 수 없을 만큼 느려지기 때문에 반드시 설정해주어야 한다. 

vector는 클라에서는 많이 사용되지만 서버에서는 쓸 일이 많이 없다. 배열을 내부에서 동적으로 관리할 수 있다는 장점이 있는 반면, 크기를 키울 때 메모리 복사가 일어난다는 단점도 있다. reserve를 쓰면 이 복사를 줄일 수 있다. 서버에서 stl을 쓰는 건 보통 검색을 빠르게 하기 위함이므로 굳이 vector를 써야하는 경우는 잘 없으며, unordered map을 일반적으로 많이 사용한다. 

map은 key-value의 레드블랙트리, set은 key만 있는 레드블랙트리로 구현되어 있으며 set은 잘 쓰이지 않는다. 중복 로그인을 찾을 때 그나마 유용한데 그 경우도 unordered map이 더 일반적으로 쓰인다. multimap, multiset 역시 활용도가 많지 않다. multiset, multimap 검색 시 iterator 하나가 통 나오는 대신 begin과 end가 나온다. 따라서 begin iter, end iter 두개가 묶인 pair가 필요하다. 이 안에서 find_if로 더 상세하게 검색할 수 있다. 

unordered map은 key-value의 해시테이블로, 정렬이 안된다는 한계점이 있다. 그러나 실무에서 정렬은 대체로 보여주는 용도로 쓰이기 때문에 이는 클라 혹은 DB에서 처리하는 경우가 더 많다. 따라서 가장 탐색이 빠른 unordered map을 많이 사용한다. 또, stl sort는 quick_sort를 기본으로 사용하다가 몇회 이상 반복되면 merge_sort로 바꿔서 처음부터 다시 하는데, 구체적인 범위는 C 컴파일러 버전에 따라 달라진다. 

면접에서 stl의 특징에 대해 질문하는 경우는 잘 없지만 시간 복잡도나 내부 구현 방식은 필수적으로 알고 있어야 한다. 보통은 데이터 형태, 삽입과 검색의 비율, 데이터 양과 정렬 여부 등의 조건을 걸어두고 조건에 적합한 컨테이너를 선택해서 손코딩하는 형태의 질문이 나온다. 그럴 때 꼭 하나의 컨테이너만 사용하지 말고 index 저장을 위한 컨테이너들을 보조적으로 사용해도 된다. 

데이터 탐색 시 데이터가 같은지 아닌지는 (A, B) = false, (B, A) = false 방식으로 파악한다. 이때 노드마다 뒤집어서 확인하는 대신, false가 나오면 가장 최근에 false가 나온 노드를 멤버에 보관하며 nil까지 내려가되, true가 나오거나 nil에 도달하면 마지막에 저장되어 있던 false 노드와 교차로 비교해서 동일한 데이터임을 확인한다. 따라서 검색할 때마다 nil까지 탐색하게 된다. 이 경우 데이터가 위쪽에 있으면 낭비가 생기지만, 아래쪽에 있었을 경우 비교 횟수를 줄일 수 있게 되면서 균일한 성능을 보장한다. 

이때 디버그 빌드라면 (A, B)로 넣어도 (B, A)로 넣어도 true가 반환되는 경우에 예외를 던진다. 보통 좌표 기준으로 정렬을 해서 렌더링 순서를 맞추는데, 이 경우 이펙트 같은 특정 객체는 좌표와 상관 없이 맨 앞에 두게 된다. 이때 그러한 객체들끼리 비교를 하면 둘 다 true가 반환되면서 예외가 생긴다. 이때 내부적으로 비교자를 랩핑해서 사용하므로 커스텀 비교자를 만들어도 그 자체로 속도가 저하되진 않는다. 

<br/>

# **2. Json**

스크립트 언어 (인터프리터 언어)는 런타임에 텍스트를 읽어서 돌리다보니 컴파일 언어와 달리 변수 이름이 존재한다. 그래서 Key를 변수 이름으로 만들어서 각 객체 (ex 플레이어)에 대한 정보들을 Json으로 저장하고 불러올 수 있다. 바이너리 데이터에 비해 용량은 크지만, 편의성 호환성 안정성이 높기 때문에 표준적으로 많이 사용된다. 또, Key 기준으로 검색을 하기 때문에 데이터 하나가 없어지거나, 순서가 틀어지거나, 추가되어도 쉽게 대응할 수 있다. Json과 바이너리의 중간 격인 MessagePack도 있다. key는 text로 유지하되 value는 바이너리로 가서 Json의 장점을 가져오되 속도와 용량을 절약하는 것이다. 

스크립트 언어와 달리 c, c++ 같은 컴파일 언어는 일일이 파싱해주어야 하기 때문에 성능저하 및 트래픽 용량 증가 등이 문제가 되지만, 그럼에도 호환을 위해 Json을 많이 사용한다. c++에서 쓸 땐 보통 오픈 소스를 사용하며 Rapid Json이 많이 쓰인다. 최근까지 업데이트가 되고 있으며 header로만 이루어져 있어서 재빌드 할 때 편하다. utf-16은 윈도우에서만 많이 쓰는 거고 대부분의 영어권은 utf-8을 많이 사용하기 때문에 Rapid Json도 utf-8를 기본으로 사용하며 utf-16을 쓰려면 따로 설정해주어야 한다.

Rapid Json은 Value &value = Doc[“key”] 와 같이 적을 경우 key에 해당하는 value를 value에 저장해준다. 이때, 어떤 자료형인지 모르기 때문에 어떤 자료형이든 받을 수 있는 Value 자료형을 제공해준다. 이때 key가 없는 key라면 예외를 던진다. 안전하게 하려면 iterator를 반환해주는 find를 거치고 사용하는 것이 좋다. 컴파일 언어다보니 GetInt, GetString 등의 노가다가 필요하다. 이때, Json을 굳이 txt로 저장할 일은 없겠지만 그렇게 되어있다면 BOM 때문에 Parse에서 크래시가 난다. 


