---
title: Procademy, Q1, 26) Console Shooting Game - OOP
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. OOP**

절차지향적으로 처리할 때는 객체들을 처음에 다 만들어놓고 지속적으로 풀링하는 반면, 객체지향적으로 처리할 때는 객체를 사용 시점에서 생성하고 Update 하나로 지금 존재하는 객체들이 각자의 행동을 하도록 설계한다. 여기에서 다형성과 상속을 활용하면 코드를 간결하게 설계할 수 있다. 또, 동접자가 적을 때는 객체지향이, 동접자가 많을 때는 절차지향이 더 좋은 성능을 보일 수 있다. 객체지향에서는 데이터들이 중구난방으로 위치하는 반면 절차지향에서는 같은 타입의 데이터들이 연속적으로 위치하기 때문에 데이터 접근 관점에서 더 효율적으로 동작한다. 

Unity도 객체지향적으로 설계된 엔진이므로 참고하기 좋다. Unity는 main 함수를 사용자에게 보여주지 않고 MonoBehaviour이라는 Base Object와 그의 가상함수들을 제공하는데, 이를 상속받아 코드를 작성하면 각각 객체가 된다. 그리고 씬 안 모든 객체의 가상함수들을 한 프레임당 한번씩 돌리며 프로그램이 동작한다. 이때 객체지향적인 설계를 연습하고자 한다면 LoadScene을 제외하고는 서로를 알지 못하도록 해야 한다. 컨텐츠 코드와 프레임워크 코드를 완전히 분리시키는 것에 유의하자. 어떤 스테이지에 따라 무슨 코드를 돌릴지에 대한 건 프레임워크에서 알 수 없어야 하며 컨텐츠 코드만 바꾸면 재사용할 수 있게끔 해야 한다. 

<br/>

# **2. 충돌 처리**

충돌 처리를 총알/적군 내부에서 처리하는 것은 프레임워크와 컨텐츠를 분리해야 한다는 관점에서 봤을 때 적절하지 못하다. 충돌은 컨텐츠 관련 객체가 아니라 프레임워크 단에서 탐지를 하고, 충돌 결과만 관련 객체들에게 통보한 뒤, 객체 내에서 결과에 따른 로직을 처리하는 것이 객체지향적인 설계이다. 

충돌 처리는 어떤 객체든 탐지할 수 있도록 가상함수로 구현하며, 내가 호출한 게 아니라 이벤트 발생을 알리는 Callback이라는 의미에서 앞에 On을 붙이는 게 일반적이다. 충돌 결과 로직인 Destroy 등도 프레임워크에서 처리할 일이지 충돌 탐지에서 처리할 일이 아니다. 지연 삭제를 유도하는 것이 훨씬 안전하다. 

충돌 가능한 대상인지 아닌지도 중요한데 Unity에서는 이를 충돌 레이어로 처리한다. 인터페이스 클래스인 베이스 오브젝트에 이러한 레이어를 구현한 뒤 이를 기반으로 충돌처리가 되도록 하는 것이 좋다. 

<br/>

# **3. Scene 객체**

절차지향에서는 switch case로 씬을 제어하지만, 객체지향적 설계에서는 씬도 객체로 만들어서 관리한다. Scene에 필요한 세팅들을 멤버로 두고 Scene 객체로 만들어서 SceneManager를 통해 이들을 제어한다. 이 경우 세팅을 전역 대신 스택, 힙에 쌓을 수 있게 되므로 성능상 이점이 있다. 

Scene 전환은 컨텐츠의 영역이므로 LoadScene을 어디에서든 호출할 수 있어야 한다. 이때 LoadScene은 현재 Scene의 멤버로 들어있게 되므로 새 Scene을 new 하고 현재 Scene을 delete 하면 delete this하는 셈이 된다. 따라서 현재 프레임 말고 다음 프레임에서 delete를 하도록 시키는 것이 안전하다.

<br/>

# **4. Object Manager 객체**

Object Manager를 전역으로 만들 수도 있고 Scene의 멤버로 관리할 수도 있다. 그러나 Scene의 멤버로 관리하게 되면 Scene을 통해 ObjectManager에 접근해야 되기 때문에 번거로워진다. 또 네트워크, 회원 정보 등은 씬이 전환되어도 유지되어야 하므로 이에 대한 처리도 필요해지며, 검색과 특정 또한 어려워진다. 

Unity는 이를 보완하기 위해 tag로 특정 객체에 접근할 수 있도록 지원한다. 이런 기능은 객체지향적 설계라는 측면에서는 어긋나는 것이지만, 작업이 번거로워지는 것을 막기 위해 제공되고 있다. 물론 전역에 둘 경우 이런 방법 없이도 쉽게 구현할 수 있다. 다 각자의 장단점이 있기 때문에 적절하게 선택하면 된다.
