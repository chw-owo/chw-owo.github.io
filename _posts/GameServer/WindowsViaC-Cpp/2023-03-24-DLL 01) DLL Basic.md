---
title: DLL 01) DLL Basic
categories: WindowsViaC-Cpp
tags: 
toc: true
toc_sticky: true
---

이 포스트는 <제프리 리처의 Windows via C/C++ (한빛미디어)> 내용을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. DLL**

## **1) DLL이란?**

DLL, Dynamic Link Library는 윈도우의 핵심적인 기본 요소로, 윈도우 애플리케이션 프로그래밍을 위한 모든 함수는 DLL 내에 포함되어 있다. 이 중 가장 중요한 3개의 DLL은 메모리/프로세스/스레드 관리 함수를 표현하는 Kernel32.dll, 윈도우 생성/메시지 송신 등 UI 함수를 포함하는 User32.dll, 그래픽 이미지/텍스트 출력 함수를 포함하는 GDI32.dll이다. 

## **2) DLL 사용 이유**

첫째로 DLL을 사용하면 애플리케이션 기능 확장 측면에서 유용하다. DLL은 프로세스 주소 공간에 동적으로 로드될 수 있기 때문에 애플리케이션이 수행 중이더라도 수행 작업이 결정되면 해당 작업 수행 코드를 로드할 수 있다. 개발할 때 추후에 그 기능을 확장, 보강하고 싶은 경우 DLL을 유용하게 사용할 수 있다. 

둘째로 프로젝트 관리를 단순하게 할 수 있다. 개발 과정에서 여러 그룹이 서로 다른 작업을 수행하고 있다면 DLL로 프로젝트 관리를 더 쉽게 수행할 수 있다. 하지만 애플리케이션은 가능한 적은 개수의 파일로 유지하는 것이 좋은데 애플리케이션이 구동될 때 읽어야 하는 DLL 파일이 많아질 경우 프로세스 초기화가 심각하게 느려질 수 있다. 

셋째로 메모리 절약 측면에서 이점이 있다. 복수의 애플리케이션들이 동일한 DLL 파일을 사용하는 경우, DLL을 램에 한번만 로드한 후 그 내용을 공유할 수 있다. 정적으로 링크할 경우 _tcscpy, malloc 등의 함수가 메모리에 여러번 로드되는데, DLL을 사용할 경우 이러한 중복을 줄일 수 있다. 이 외에 DLL에 포함된 문자열, 아이콘, 비트맵 등의 리소스도 공유하게 된다. 

넷째로 지역화를 위해 DLL을 사용할 수도 있다. 예를 들어 코드로만 구성되어서 어떠한 UI 컴포넌트도 포함하지 않은 애플리케이션을 먼저 수행한 후, 지역화된 UI 컴포넌트를 포함하는 DLL 파일을 로드한다면 DLL을 이용해 지역화를 할 수 있다. 

다섯번째로, 플랫폼 차별성을 해소할 수 있다. 윈도우는 버전별로 다른 함수를 제공하기 때문에 최신의 함수를 사용하면 해당 함수를 제공하지 않는 윈도우의 로더는 프로세스를 수행할 수 없다. 이때 이런 기능을 DLL로 분리해두면 최신 함수를 성공적으로 호출할 수 없어도 이전 버전 윈도우에서 정상적으로 프로세스가 기동될 수 있을 것이다. 

마지막으로 윈도우는 DLL에서만 가능한 기능들을 제공한다. SetWindowHookEx, SetWinEventHook을 쓰는 작업이 그 예인데, 훅 통지 함수는 반드시 DLL 내에 존재해야 한다. 쉘은 DLL로 작성된 COM 오브젝트를 구성함으로써 그 기능을 확장할 수 있으며, 웹 브라우저는 ActiveX 컨트롤을 사용하여 다양한 기능을 제공하는 웹 페이지를 구성할 수 있다. 

## **3) DLL과 프로세스 주소 공간**

DLL은 다른 애플리케이션에서 사용할 수 있는 독립적인 함수들로 이루어져 있기 때문에 애플리케이션을 만드는 것보다 수월하게 작성할 수 있다. 메시지 루프 처리, 윈도우 생성 등은 일반적으로 DLL 파일로 수행되지 않으며, DLL은 단순히 함수들의 집합인 모듈을 구현하는 소스코드로 구성된다. 

DLL을 구성하는 소스 코드 파일들은 컴파일 이후 링커에 의해 링크 작업이 수행된다. 이때 링커에 /DLL 스위치를 지정해야 되는데, 그래야 링커가 DLL 파일 이미지에 특수한 정보들을 포함시키게 되며, 이를 통해 운영체제 로더가 이 파일 이미지가 애플리케이션이 아닌 DLL 파일임을 인지할 수 있게 되기 때문이다. 

DLL 파일 이미지는 함수 호출 전에 반드시 프로세스 주소 공간에 매핑되어야 하는데, 이를 위해 묵시적 로드타임 링킹 혹은 명시적 런타임 링킹 중 하나를 택한다. 파일 이미지가 매핑되고 나면 DLL의 함수들이 스레드에 의해 호출될 수 있다. DLL 함수에서 생성하는 모든 오브젝트는 함수를 호출한 스레드, 프로세스가 소유하며, DLL은 오브젝트를 소유하지 않는다.

실행 파일 내 전역으로 선언된 정적 변수는 동일 실행 파일이 여러번 실행되어도 공유되지 않는다. 이는 DLL 파일 내 전역으로 선언된 정적 변수에 카피 온 라이트 매커니즘이 적용되기 때문이다. 프로세스가 DLL 이미지 파일을 자신의 주소 공간 내 매핑하는 경우, 실행 파일 경우와 동일하게 전역으로 선언된 정적 변수의 새 인스턴스가 생성된다. 

이때 단일 주소 공간은 하나의 실행 모듈과 다수의 DLL 모듈로 구성됨을 알아야 한다. 이 중 일부는 crt 라이브러리를 정적으로 일부는 동적으로 링크하고 있을 수 있다. 아래 상황의 경우, 모든 crt 라이브러리가 동적으로 링크하고 있다면 문제가 없지만, 하나라도 정적으로 링크하고 있다면 free 호출에서 문제를 일으킨다. 

```c++
// EXE의 crt 힙 내에 있는 pv를 활용한다.
VOID EXEFunc()
{
    PVOID pv = DLLFunc();
    free(pv); 
}

// DLL의 crt 힙으로부터 메모리를 할당받는다.
PVOID DLLFunc()
{
    return(malloc(100));
}
```

이러한 상황을 막기 위해서는 메모리 할당 함수 모듈 안에서 메모리 삭제 함수까지 함께 제공하도록 해야한다. 이에 맞춰 다시 작성한 코드는 아래와 같다. 

```c++
VOID EXEFunc()
{
    PVOID pv = DLLFunc();
    DLLFreeFunc(pv); 
}

PVOID DLLFunc()
{
    PVOID pv = malloc(100);
    return(pv);
}

BOOL DLLFreeFunc(PVOID pv)
{
    return(free(pv));
}
```
모듈을 작성할 땐 다른 모듈의 함수들은 C/C++로 작성되지 않았을 수 있으며, 메모리 할당에 malloc, free를 사용하지 않을 수도 있다는 사실을 기억해야 한다. 더불어 C++의 new, delete 연산자는 내부적으로 malloc, free와 동일한 인자형을 취한다는 것도 알아두는 게 좋다. 

<br/>

# **2. DLL 수행 과정**

## **1) 전체 구조**

실행 파일과 DLL 모듈은 대체로 묵시적으로 링크된다. 몇몇 파일들과 컴포넌트들은 DLL내 함수와 변수를 사용할 때만 관여하는데, 간단하게 보기 위해 실행 모듈은 DLL로부터 함수와 변수를 import 하는 모듈로, DLL 모듈은 export하는 모듈로 제한하고자 한다. 물론 실제로는 DLL 모듈이 다른 DLL 모듈을 import 한다. 

![DLL](https://user-images.githubusercontent.com/96677719/226230643-d12b077d-c367-404b-9ee1-4a7040be13cc.png)

실행 모듈을 생성하려면 먼저 DLL 모듈을 생성해야 한다. 먼저 DLL이 export 하려는 함수 원형, 구조체 등을 포함하는 헤더를 작성한다. 소스 파일도 만드는데, 이 소스 코드 모듈은 실행 모듈 생성 시 사용되지 않는다. 이후 obj 모듈들을 결합하여 링커가 단일의 DLL 이미지 파일을 생성하게 된다. 하나 이상의 함수, 변수가 export 된 경우 lib 파일을 생성한다. 

실행 모듈의 경우 DLL 파일이 export 하는 함수, 변수 등을 참조한다면 헤더를 include 해야 한다. 이후 소스 코드를 작성, obj 모듈을 생성하면 링커는 단일 실행 파일 이미지를 생성한다. 이떄 실행 모듈은 DLL 모듈 이름을 포함하는 import section을 가지고 있으며, 여기에는 DLL 모듈별로 실행 파일이 사용하는 함수, 변수 정보가 포함되어 있다. 

실행 파일을 수행하면 우선 로더는 새로운 프로세스를 위한 가상 주소 공간을 생성한다. 우선 실행 모듈을 매핑하고, import section을 분석하고, section 내 모든 DLL을 시스템으로부터 찾아내 또 매핑한다. 다른 DLL 모듈을 import 하는 DLL 모듈들도 자신만의 import section을 갖는다. 이들을 모두 분석해 매핑하기 때문에 이 초기화 작업에 시간이 많이 걸린다. 

이렇게 필요한 모든 모듈이 매핑되면 프로세스의 주 스레드가 실행되면서 애플리케이션이 실행된다. 

## **2) DLL 모듈 생성**

DLL 작성 시 export 하려는 변수, 함수를 포함하는 헤더를 먼저 작성하는 게 좋다. 모든 DLL 소스 코드 모듈은 이를 include 하며, 이를 DLL과 같이 배포하여 사용할 수 있도록 만든다. 유지 보수 편의성을 위해 DLL 별로 헤더를 하나씩만 구성하는 것이 편리하다.

DLL 소스 코드를 컴파일 하면 헤더를 include 하기 전에 __declspec을 앞에 붙여야 한다. 이는 해당 파일을 dllexport로 정의하는 것으로, 컴파일러가 모든 변수, 함수, 클래스 앞에 DLL 모듈로부터 export 되는 것이라 판단하게 된다. 

DLL을 작성할 때 변수, 함수, 클래스 등을 export 할 수 있는데, 코드의 계층적 추상화를 유지하고 쉽게 관리하기 위해서는 변수를 export 하지 않는 것이 좋다. 또, C++ 클래스의 경우 export한 C++ 클래스를 사용하는 모듈은 동일 회사 컴파일러를 이용할 때만 사용할 수 있으므로 주의해야 한다. 

이때 DLL은 C++로, 실행 파일은 C로 작성하게 되면 DLL 파일이 생성될 때 함수 이름이 변경되면서 링크 과정에서 에러가 나기도 한다. 이때 extern C를 사용하면 컴파일러가 변수, 함수 이름을 변경하지 않으므로 C나 다른 프로그래밍 언어에서도 DLL을 사용할 수 있게 된다. 

링커는 export 심벌 목록을 갖고 있는 lib을 생성하고, 각 파일 안에 자신이 export하는 심벌 정보를 테이블 형태로 포함시키는데, 이를 export section이라 부른다. 또 각 심벌들이 어느 위치에 있는지 가리키는 상대 가상 주소, RVA도 DLL 파일 내에 포함시킨다.

DLL 함수 export 시 함수 별로 숫자 값을 할당하기도 하는데 이는 16bit 윈도우 환경에서만 적절하다. DLL을 직접 작성한다면 여전히 숫자값을 할당하는 게 지원되지만, MS에서는 이보다는 심벌의 이름을 사용하길 권장하고 있다.

## **3) 실행 모듈 생성**

실행 파일을 개발할 때는 DLL의 헤더를 include 해야한다. 이후 링커는 obj 모듈을 결합하여 실행 모듈을 생성하며, 이때 lib을 이용하여 심벌들이 어떤 DLL에서 export 되었는지 확인한다. lib은 export 심벌 목록만을 갖고 있으며, 이를 바탕으로 모든 심벌의 위치를 확인하면 실행 파일이 생성된다. 

링커는 import 된 심벌을 찾을 때 import section을 실행 파일 내에 추가하는데 여기엔 실행 파일이 필요로 하는 DLL 모듈과 참조되는 심벌 목록이 포함된다. Visual Studio DumpBin.exe 도구를 사용하면 모듈의 import section을 볼 수 있다. 

DumpBin.exe을 사용할 경우 심벌의 hint가 함께 출력되는데, 이는 프로세스 주소 공간 내에서 심벌이 위치하는 메모리 주소를 가리키는 값이다. 이는 실행 모듈이 바인딩 된 이후에만 나타나며 출력 결과 최하단에 바인딩에 대한 추가적인 정보도 함께 적혀있다. 

import 할 때도 __declspec(dllimport) 한정자를 사용하는데, 이 경우 참조하는 심벌이 lib으로부터 import 될 것임을 미리 알려주어 더 효율적인 코드를 만들 수 있다. 심볼만 import 하는 경우 굳이 사용하지 않아도 괜찮지만 되도록 사용하기를 권장한다. 


## **4) 실행 모듈 수행**

실행 파일이 수행되면 로더는 가상 주소 공간을 생성하고 실행 모듈을 매핑하며 import section을 확인해 필요한 DLL 파일도 함께 매핑한다. import section 내 DLL 이름은 전체 경로를 포함하지 않으므로 로더가 디스크 드라이브로부터 검색한다. 검색 순서는 아래와 같다.

**1.** 실행 파일 이미지가 있는 디렉토리

**2.** GetSystemDirectory 함수 반환 값인 윈도우 시스템 디렉토리

**3.** 16bit 시스템 디렉토리, 즉 윈도우 디렉토리 이하 System 하위 폴더

**4.** GetWindowsDirectory 함수 반환 값인 윈도우 디렉토리

**5.** 프로세스 현재 디렉토리

**6.** PATH 환경 변수에 포함된 디렉토리

윈도우 디렉토리 검색 이후에 프로세스 현재 디렉토리가 검색된다. 이는 현재 디렉토리로부터 시스템 DLL 파일인 것처럼 가장하는 파일이 로드되는 것을 막기 위해 윈도우 XP SP2에서부터 되었다. Session Manager의 값을 변경하면 검색 순서를 바꿀 수 있지만 권장되지 않는다. 

모든 모듈이 로드, 매핑되면 로더는 import 심벌의 모든 참조 정보를 수정하기 위해 각 모듈의 import section을 다시 살펴본다. 만일 심벌이 존재하지 않으면 로더는 RVA 정보를 가져와 DLL 모듈이 로드된 공간에 그 값을 더하고 import section에 계산된 가상 주소 값을 기록한다. 

모든 DLL 모듈은 여러번 참조되어도 한번씩만 로드, 매핑 된다. 프로세스 초기화 시 이러한 작업이 모두 수행되며 애플리케이션 수행 속도에는 영향을 미치지 않는다. 로딩 속도를 향상시키고 싶다면 시작 위치 변경과 바인딩 작업을 수행하는 것이 좋다. 