---
title: 메모리 관리와 IO 6) Dynamic Linking Library
categories: WindowsSystem
tags: 
toc: true
toc_sticky: true
---

이 포스트는 윤성우님의 <뇌를 자극하는 윈도우즈 시스템 프로그래밍 (한빛미디어)> 내용을 바탕으로 공부한 내용을 정리한 것입니다. 


# **1. 정적 라이브러리** 

![image](https://user-images.githubusercontent.com/96677719/215266478-4e40294d-914e-4286-af6c-a408bb9f3141.png)

obj 파일에서 swap.h를 포함하여 컴파일하면 SwapStaticLib.lib의 swap.cpp에 있던 코드 내용 사용할 수 있게 된다. 그리고 swap.cpp 내용을 포함한 SwapStaticLib.lib와 SwapLibTest.obj가 하나로 묶여서 SwapLibTest.exe라는 하나의 실행 파일을 만드는 것을 볼 수 있다. 이 과정을 주도하는 것을 링커라고 하고, 링커에 의해 진행되는 이 작업을 링크라고 한다. 

![image](https://user-images.githubusercontent.com/96677719/215266618-48686d3e-7dbb-440c-8445-15e0f881d244.png)

이렇게 만들어진 실행 파일들은 라이브러리 SwapStaticLib.lib의 바이너리 코드를 완전히 포함하고 있다. 링크 작업을 거치고 나면 라이브러리는 실행 파일 안에 포함되어서 분리할 수 없게 된다. 이러한 형태의 라이브러리를 가리켜 정적 라이브러리라 부른다. 이러한 정적 링크는 실행 파일만 있으면 언제든 실행할 수 있다는 장점을 갖고 있다. 그러나 라이브러리의 바이너리 코드를 모두 포함하기 때문에 많은 메모리 공간을 차지한다는 단점이 있다. 프로그램이 실행될 대도 그렇지만 하드디스크에 저장되어 있는 상태에서도 마찬가지이다. 

<br/>


# **2. DLL**

![image](https://user-images.githubusercontent.com/96677719/215266727-a979eda2-b6f4-4d52-813a-c59fccabd6d2.png)

정적 라이브러리와 달리 라이브러리를 별도로 저장한 다음 공유할 수 있는 구조로 만든 라이브러리를 동적 라이브러리, DLL (Dynamic Linking Library)라고 부른다. 위와 같이 DLL 방식으로 실행하게 되면 실행 파일의 메모리 공간 활용은 아래와 같이 이루어진다. 

![image](https://user-images.githubusercontent.com/96677719/215266802-3691ad9a-b539-4058-9529-fb0ac739844a.png)

정적 라이브러리를 사용할 때는 라이브러리를 포함하여 가상 메모리를 구성하였던 반면, DLL은 실행 파일의 일부로 포함되지 않기 때문에 사용할 때만 가상 메모리 주소에 DLL을 매핑시키게 된다. 즉, 두개의 파일이 하나의 가상 메모리를 구성하는 꼴이 된다. 하나의 프로세스를 실행할 때는 이 차이가 두드러지지 않지만 동일한 DLL을 참조하는 프로세스들을 여럿 실행한다면 아래와 같이 큰 차이를 보이게 된다.

![image](https://user-images.githubusercontent.com/96677719/215266882-398350ad-cd48-47fd-8931-fd7e89038c55.png)

위에서 AAA 프로세스를 실행하다가 BBB를 실행하게 된다면, 라이브러리에 포함되는 코드 역시 각각의 프로세스에 속하는 내용이기에 동일한 내용임에도 불구하고 메모리 전체가 스위칭 된다. 반면 DLL을 사용할 경우 라이브러리에 해당하는 영역은 그대로 두고 AAA, BBB의 영역만 스위칭이 일어난다. 이처럼 둘 이상의 프로세스가 동일한 DLL을 공유할 경우 메인 메모리에서 페이지 단위로 공유가 이루어지게 된다. 즉, DLL은 물리 메모리에 한번 올라가면 공유하는 프로세스가 모두 종료될 때가지 메모리에 존재한다. 이때 가상 메모리, 메인 메모리와 헷갈리면 안된다. 가상 메모리 주소에 매핑된 라이브러리는 프로세스가 소멸되면 함께 소멸되며, 메인 메모리 역시 페이지 교체 알고리즘에 의해 메인 메모리에 끝까지 남아있을 수 있는 페이지는 존재하지 않는다.  

이때, AAA와 BBB 모두 동일한 가상 메모리 주소에 dll을 할당한다. 정확히는 AAA가 dll을 가상 메모리 영역에 매핑하고 물리 메모리에 할당시키면, BBB는 이번에 물리 메모리에 올리지 않고 BBB 프로세스 가상 메모리 영역에 해당 dll을 매핑하는 것이다. 이때 두 프로세스가 동일한 dll을 동일한 가상 주소에 매핑했기 때문에 페이지 단위의 공유가 가능하게 된다. 만약 BBB를 실행하는 시점에서 AAA의 dll 가상 메모리 주소에 이미 다른 값이 들어있다면 해당 위치에 dll을 매핑시킬 수 없게 되면서 결국 BBB는 다른 영역의 메모리 주소에 해당 dll을 올리게 된다. 이러한 상황이 발생하면 동일한 dll을 사용하면서도 해당 dll을 두번 이상 물리메모리에 올리게 될 수도 있는 것이다. 

<br/>


# **3. 암묵적 연결, 명시적 연결**

**swap.h**
```c++
__declspec(dllimport)
void swap(int* v1, int* v2);
```

**swap.cpp**
```c++
__declspec(dllexport)
void swap(int* v1, int* v2)
{
    //
}
```

__declspec을 이용하여 외부에 제공할, 혹은 외부로부터 제공받을 함수 및 변수를 선언할 수 있다. 이는 C, C++ 문법이 아니라 마이크로소프트에서 제공하는 추가적인 선언문이다. 이를 빌드하게 되면 .lib, .dll 두가지 파일이 생성된다. 여기서 .lib 파일은 정적 라이브러리에서의 lib 파일과 다른 용도로 쓰이는데, .obj에서 호출하는 함수가 .dll 파일에 잘 정의되어 있다는 것을 링커에게 전달하는 용도로 사용된다. 즉, .lib 파일은 링크할 때 필요하고 .dll은 실행할 때 필요한 셈이다. 그 후, 프로젝트 파일이 있는 위치에 lib 파일을, 표준 검색 경로에 해당하는 위치에 .dll을 넣으면 실행할 수 있게 된다. 표준 검색 경로는 1) 실행 파일 디렉토리 2) 프로세스의 현 디렉토르 3) Windows 시스템 디렉토리 4) Windows 디렉토리 5) 환경 변수에 등록된 디렉토리 순서이다. 이 방법처럼 소스코드 내에 .dll 연결에 대한 명시적인 코드가 없는 경우, lib 파일과 연결되어 동작하며 이를 암묵적 연결이라고 부른다.

반면 명시적 연결의 경우 소스코드 내에 .dll 연결 코드를 명시적으로 넣어주는 것으로, 이 경우에는 .lib 파일이 필요 없게 된다. 대신 연결을 위해 LoadLibrary, FreeLibrary 함수를 사용하게 된다. 

![image](https://user-images.githubusercontent.com/96677719/215267343-13718004-1206-4cf6-b081-078f6698e9e9.png)

```c++
HMODULE LoadLibrary (
    LPCTSTR     lpFileName
);
```
LoadLibrary 함수는 필요한 dll을 프로세스 가상 메모리에 매핑하는 기능을 제공한다. lpFileName을 통해 프로세스 주소 공간으로 매핑시킬 dll 이름을 지정하면 dll 모듈의 핸들을 반환한다. 경로 정보를 포함하지 않고 파일 이름만 지정할 경우 표준 검색 경로를 기준으로 파일을 탐색한다. 

```c++
FARPROC GetProcAddress (
    HMODULE     hModule,
    LPCSTR      lpProcName
);
```
GetProcAddress 함수는 필요한 함수의 포인터를 반환하고, 이렇게 획득한 함수 포인터를 이용하면 dll이 제공하는 함수를 호출할 수 있다. hModule는 사용하고자 하는 함수나 변수가 속해있는 dll 모듈의 핸들, 즉 LoadLibrary의 반환값을 인자로 전달한다. 그 후 lpProcName로 찾고자 하는 함수의 이름을 지정하면 해당 함수의 포인터를 반환하다. 

```c++
HMODULE FreeLibrary (
    LPCTSTR     lpFileName
);
```
FreeLibrary 함수를 호출하면 .dll을 반환할 수 있다. LoadLibrary로 매핑된 dll 모듈은 반드시 이 함수로 해제되어야 한다. dll의 반환은 가상 메모리에서의 반환을 의미할 뿐 물리 메모리에서의 반환을 의미하진 않는다. LoadLibrary 호출 시 지정된 dll의 레퍼런스 카운트는 1씩 증가하고 FreeLibrary 함수 호출 시 1씩 감소한다. dll의 레퍼런스 카운트가 0이 되는 시점, 즉 dll을 참조하는 프로세스가 하나도 존재하지 않는 시점이 물리 메모리에서 dll이 반환되는 시점이다. 

명시적 연결을 선택하는 것은 크게 세가지 장점을 갖는다. 첫째로, dll이 필요한 시점에 로딩되고 불필요해지면 반환하기 때문에 메모리가 절약된다. 둘째로, 프로그램 실행 중 dll 교체 및 선택이 가능해진다. 마지막으로, 암묵적 연결 방식은 프로그램 실행 전에 필요한 모든 dll을 메모리에 로딩하기 때문에 실행까지 걸리는 시간이 길어질 수 있다. 반면 명시적 연결 방식은 필요한 순간에 로딩하기 때문에 실행까지 걸리는 시간이 짧고 dll 로딩에 걸리는 시간을 분산시킬 수 있다. 그러나 일반적으로 코드의 간결성과 사용의 용이성으로 암묵적 연결방법을 조금 더 선호한다. 

<br/>

# **4. DLL과 extern 선언**

Visual studio는 확장자가 c인지 c++인지에 따라 컴파일러를 결정한다. 만약 라이브러리를 만들 때 사용한 컴파일러와 해당 라이브러리를 사용하는 예제를 만들 때 사용한 컴파일러가 다르다면 링크 에러가 발생한다. c++ 컴파일러는 컴파일 과정에서 네임 맹글링, 즉 정의된 함수의 이름을 정해진 규칙에 따라 바꾸는 작업을 실행한다. 따라서 함수들의 바이너리 코드를 봤을 때 동일한 소스코드를 사용했어도 c로 컴파일 했을 때와는 다른 이름을 가지게 된다. 동일하게 c++로 컴파일 했더라도 만약 서로 다른 컴파일 규칙을 가진 컴파일러를 사용했다면 마찬가지로 호환이 되지 않는다. 따라서, C로 구현한 프로그램에서도 C++로 빌드된 라이브러리를 사용할 수 있게 하려면 C++ 컴파일러가 함수의 이름을 바꾸지 못하도록 작업해주어야 한다. 그 방법은 아래와 같다.  
```c++
extern "C" __declspec(dllimport)
void swap(int* v1, int* v2);
```

```c++
extern "C" __declspec(dllexport)
void swap(int* v1, int* v2)
{
    //
}
```
이때, 이 선언은 c++ 키워드이기 때문에 c 컴파일러에서 사용하게 되면 c 컴파일러가 이해하지 못한다. 따라서 C, C++ 모두에서 쓰이는 라이브러리를 만들 경우 아래와 같이 분기문으로 처리해주는 것이 좋다. 

```c++
#ifdef __cplusplus
    extern "C" 
    {
#endif

    // Library Code

#ifdef __cplusplus
    }
#endif
```

<br/>

# **출처**

뇌를 자극하는 윈도우즈 시스템 프로그래밍, 윤성우, 한빛미디어
