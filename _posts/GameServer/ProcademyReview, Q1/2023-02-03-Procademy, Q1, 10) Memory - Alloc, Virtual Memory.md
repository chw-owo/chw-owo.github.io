---
title: Procademy, Q1, 10) Memory - Alloc, Virtual Memory
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. Alloc**

```c++
char*p = (char*) malloc(100);
p[0] = 0;
free(p);
p[0] = 0;
```
위 함수에서 마지막 p[0] = 0; 를 실행할 경우 (대체로) 예외 없이 동작한다. 해제는 “이 메모리를 더 이상 사용하지 않겠다” 라는 의미이지 포인터가 가리키는 메모리를 없애버린다는 의미가 아니며, p에도 여전히 이전 값이 들어있기 때문이다.

```c++
char*p = (char*) malloc(100);
for( .. i < 102; …)
{
p[i] = 0;
}
free(p);
```
위 코드 역시 실제로는 잘못된 상황임에도 불구하고 p[i] = 0; 까지 (대체로) 예외 없이 동작하는 것을 볼 수 있다. 

잘못된 접근으로 예외가 나는 경우는 크게 두가지로 나뉘어진다. 첫째는, 메모리 창을 봤을 때 ??로 뜨는 영역은 건드렸을 때이다. 이는 우리에게 할당되지 않은 영역에 접근하기 때문에 예외가 나는 것이다. 둘째로, readonly-data, code 영역은 메모리 창에서 ??로 뜨지 않음에도 예외가 난다. 유저는 해당 영역에 대한 write 접근 권한이 없기 때문이다. 이처럼 확인 가능한 영역일 지라도 접근 권한이 없는 방식으로 접근하게 되면 예외가 난다. 위 상황들은 cpu 차원에서 page fault 예외를 던진다. 앞서 확인한 두 가지 예제는 둘 중 어디에도 해당하지 않기 때문에 예외가 나지 않는다. 위 코드를 실행할 경우 의도하지 않은 값 오염은 생기겠지만 값을 쓰는 순간에는 에러가 나지 않는다.

malloc으로 할당한 영역을 침범했음에도 왜 할당되지 않은 영역에 접근했다는 예외가 뜨지 않는지, 그 이유 대해 알기 위해서는 new, malloc이 내부적으로 어떻게 동작하는지 알아야 한다. 내부적으로 보면 new를 호출할 경우 new - malloc - HeapAlloc - VirtualAlloc 순으로 차례로 호출이 된다. C언어에는 메모리를 할당할 능력이 없으며, OS, Window에 있는 HeapAlloc을 C언어에서 매핑한 것이 malloc이다.즉, 힙이든 뭐든 메모리를 쓰기 위해서는 VirtaulAlloc을 써야한다. 그런데 컴퓨터는 1byte씩 가져오는 대신 지난번에 봤던 것처럼 페이지 단위, 즉 메모리 할당의 최소 단위인 64byte 단위로 끊어서 메모리 블록을 불러오게 된다. VirtualAlloc도 마찬가지고 이를 래핑한 new, malloc도 마찬가지이다. 하지만 매번 64byte를 가져오는 것은 낭비이기 때문에, 처음에 HeapAlloc을 new 혹은 malloc으로 호출하면 우선 64byte를 가져와서 확보한 다음 요청한 만큼 나누어 주게 된다. 즉, 시스템이 힙을 크기 단위로 관리하고 있는 것이다. 

다시 예제로 돌아와서, Debug 모드일 경우 free 하는 순간에 예외가 생기는데, 이는 Debug 모드 자체가 할당 받은 영역의 앞뒤 넘어가는 영역을 fdfdfd로 잡아놓고 건드리는지 체크해주기 때문이다. 참고로 fdfdfd 보다 더 앞뒤에 해당하는 영역은 cdcdcd, free를 마친 영역은 cccc로 밀어준다. 반면 release에서는 이러한 패딩 대신 앞뒤에 힙의 정보가 들어간다. Heap의 정보는 기본적으로 리스트로 관리 되는데 이걸 건드리게 되면 Heap이 깨져버린다. 한 마디로, 동적할당 중에 언제 에러가 터질지 모르는 상태가 되는 것이다. 이때 할당한 힙의 크기가 이전에 Heap을 깨뜨렸던 영역이 할당 받았던 크기와 같으면 예외가 날 가능성이 더 높아진다. 이는 같은 크기의 bucket끼리 묶어서 관리할 가능성이 높기 때문이다.

참고로, 일반적으로는 저단편화 힙이 기본 설정으로 되어있기 때문에 처음 만든 힙은 연속되게 잡힐 가능성이 높은데 이는 보장되는 것이 아니다. 힙이 많아지고 메모리 단편화가 심해지면 띄엄띄엄 들어가게 된다. 

<br/>

# **2. 가상 메모리의 영역**

프로세스마다 충분한 양의 독립적인 메모리를 할당해주기 위해 물리 메모리의 주소를 직접 사용하는 대신 가상 메모리를 사용하게 된다. 메모리가 0x 0000 0000 ~ 0x ffff ffff 을 차지한다면 이 중  0x 0000 0000 ~0x 7fff ffff를 유저 영역으로 지정하고 있다. 또 유저 영역 중에서도 최상단 64kb는 null pointer 영역으로 접근불가능한 영역이다. 꼭 0이 아니더라도 64kb 이하 영역에 접근하면 메모리 접근 불가 에러가 뜨는 게 이 때문이다. 프로세스 A의 1000번 메모리와 프로세스 B의 1000번 메모리는 전혀 관련 없는 물리 메모리이며, 컨텍스트 스위칭이 일어날 때마다 이 가상 메모리 테이블을 갈아끼우게 된다. 

이때 0x 7fff ffff ~ 0x ffff ffff 를 커널 영역으로 지정하고 있지만, 그렇다고 이 영역이 각 프로세스가 독립적으로 사용하는 커널 영역을 의미하는 것은 아니다. 커널 영역은 프로세스들이 공유해서 사용하며 그냥 유저가 접근할 수 없다는 의미로 이해하면 된다. 따라서 가상 메모리 테이블은 모든 물리 메모리에 대한 테이블이 아니라, 프로세스의 유저 영역에 대한 메모리 테이블을 의미한다. 

<br/>

# **3. Page Entry - Free, Reserve, Commit**

메모리는 4K마다 Free, Reserve, Commit의 상태를 가진다. 가상 메모리 테이블에서 페이지 엔트리, 각 페이지 단위로 위치가 어디고 어떤 상태인지에 대한 정보를 기록한다. 그리고 CPU의 CR3이라는 레지스터가 지금 현 프로세스의 가상 메모리 테이블을 가리키게 된다. 이건 Windows의 설정이 아니라 CPU 단위의 설계이다. 가상 주소를 물리 주소로 변환해야 될 때마다 CR3를 참조해서, 가상 메모리 테이블로 타고 가서, 주소를 변환한다. 그러나 메모리에 접근할 때마다 이 과정을 거치면 성능에 영향을 끼칠 것이다. 따라서 이 가상 메모리 테이블을 작성할 때도 Hash를 거치게 된다. 

L1 Cache 옆에는 TLB라는 Cache가 있는데, 이는 주소 변환을 빠르게 하기 위한 목적의 Cache이다. CPU에서는 TLB를 먼저 확인하고, 거기에 없을 경우 CR3 - 가상메모리테이블을 거쳐 값을 TLB로 가져온다. 그리고 그 값을 바탕으로 L1에서 Cache hit 여부를 확인, miss가 발생할 경우 해당 물리주소에서 데이터를 가져온다. 이 부분은 Cache와 동일하게 동작한다. 과거에는 MMU라는 장치 하나가 이러한 역할을 했지만 현재는 성능을 위해 여러 장치가 메모리 맵핑 기능을 분할하여 수행하고 있다.

4K 단위로 예약을 하게 되면 메모리 주소를 저장하는 데에 낭비가 심하게 발생하기에 예약의 경계는 4K가 아니라 64kb 단위로 이루어지게 된다. 메모리를 할당할 때는 유저가 예약할 메모리 위치를 주소로 지정하지 않는다. 우연히 다른 용도로 reserve 한 메모리 주소를 실수로 commit 요청했을 때 큰 문제가 생길 수 있기 때문이다. 따라서 메모리를 예약, 할당하는 과정은 OS가 알아서 처리하며 메모리의 상태(reserve, commit 등)를 저장, 관리하는 역할은 VAD가 수행하게 된다. 이때 VAD에서 실질적인 메모리 상황 관리를 빠르게 하기 위해 더 상세한 단위를 쓰는 대신 64kb 단위로 관리를 하는 것이다. (참고로 VAD는 이진트리로 구현된 일종의 자료구조로 비어있는 구간을 찾아서 메모리 할당을 보조하는 것을 목표로 한다. 구체적으로 어떻게 구성되어 있는지는 공식적으로 공개한 게 없다.)

<br/>

# **4. Page Entry - Guard**

페이지에 대한 속성 중 reserve, commit, free 말고도 guard라는 것이 있다. 접근하면 예외(에러)를 던지지만 대신 한번만 예외(에러)가 발생하며 이후에는 예외가 풀어지는, 즉 쓸 수 있는 commit 상태가 되는 상태이다. 이때 이 예외는 OS에서 커버하기 때문에 사용자에게는 예외가 뜨지 않는다. 이러한 상태는 stack에서 주로 사용되는데, esp 위에 있는 영역은 기본적으로 guard 상태이다. 이를 초과하게 되면 guard가 풀어지면서 사용할 수 있게 되고, 더 위쪽에 새로운 guard가 잡힌다. 그리고 guard 위는 reserve 상태인데 여기를 건드리면 바로 예외가 난다. 참고로 reserve, free 상태에서는 페이지 엔트리 자체가 안생기지만 guard 상태일 때는 페이지 엔트리가 생성되며 거기에 guard 상태로 상태가 올라간다. 
