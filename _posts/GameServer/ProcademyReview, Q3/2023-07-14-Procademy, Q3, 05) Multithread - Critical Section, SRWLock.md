---
title: Procademy, Q3, 05) Multithread - Critical Section, SRWLock
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. critical section (임계 영역)**

커널 객체인 세마포어, mutex와 달리 cs는 유저 객체이므로 타 프로세스의 스레드를 동기화하는데 사용할 순 없다. 이때 cs는 구조체이지 커널 객체가 아니므로 생성 요청은 필요하지 않으며 선언, 초기화만 하면 된다. EnterCriticalSection로 독점 진입, LeaveCriticalSection로 빠져나오면서 독점을 해제한다. TryEneter도 있는데 활용도가 떨어져 잘 쓰이진 않지만 간혹 false면 분기를 타서 데드락을 막기 위해 쓰일 수 있다. 

Interlock 함수로 진입 가능 여부를 판단하며, 불가능한 경우 커널 모드로 전환되어 block이 걸리고 가능한 경우 바로 return 된다. block 된 스레드를 깨울 때는 signal을 사용한다. 이때 구조체로 시작하지만 작동 하다보면 내부에서 커널 오브젝트를 만들어 사용하게 된다. 따라서 DeleteCriticalSection으로 이를 정리해주어야 한다. 

스레드 객체가 커널 객체이므로 유저 모드에서 동기화를 걸 순 없기에 유저 객체를 써도 커널 모드 전환은 생긴다. 커널 객체는 소유권 정보가 커널 메모리에 있기에 진입 가능 여부를 판단하는 것에도 커널 모드 전환이 필요하다. 반면 유저 객체는 진입 가능한 경우 모드 전환 없이 유저 모드에서 바로 할 수 있다. block을 걸어야 하는 상황이 되면 커널 객체와 마찬가지로 커널 모드로 진입하여 block을 걸린다.

윈도우 7까지는 진입 여부 판단만 Interlock으로 유저 모드에서 진행하고 block이 걸릴 땐 세마포어에 의존했다. 이땐 cs가 세마포어를 랩핑한 구조체였기 때문에 내부적으로는 세마포어를 쓰는 것과 동일했다. 현재는 block이 걸릴 때도 WaitOnAddress 라는 유저 객체를 사용하고 있다. 이때 cs처럼 동기화 기능만 가진 객체들은 대체로 시간 초과 매개 변수가 없으므로 주의해야 한다.

cs는 내부의 Recursion Count로 같은 스레드에 의한 재귀적 접근을 허용한다. 동일 스레드면 Enter을 여러번 할 수 있기에 자기가 가진 소유권을 획득하려다가 데드락이 걸리는 상황을 피할 수 있다. 또, 먼저 진입 대기한 스레드가 우선권을 갖는 것은 보장되지 않으며 우선순위가 높다고 먼저 진입하지도 않는다. 오히려 스레드가 block 될 때 이제 막 들어온 스레드가 진입할 가능성이 높으며 여러 스레드가 레디큐에 쌓여있다면 예측하기 어렵다. 

cs 내부를 보면 HANDLE OwningThread에 스레드 아이디를 저장하고 HANDLE LockSemaphore로 실질적인 동기화를 처리한다. 그러나 이 핸들을 직접 쓰지는 않고, 이는 주소 값을 저장해서 WaitOnAddress 방식으로 처리하기 위한 것이다. 예전에는 핸들이 아닌 진짜 세마포어가 그대로 있었고 필요할 때 세마포어를 생성한다. 그러나 커널 객체 생성은 실패 가능성이 있으므로 중간에 이러는 건 결함이 있다. 따라서 지금은 모든 유저 동기화 객체가 주소값을 활용하는 WaitOnAddress 방식을 사용한다. 

cs의 경우 spinCount가 180이며, 그 부분이 끝나면 WaitOnCriticalSection, 그 안에서 WaitOnAddress, 그 안에서 WaitForAlertByThreadId를 호출한다. 여기서 syscall, 즉 커널 모드로 전환 되고 커널 모드에서 실질적인 동기화 처리가 진행된다. 여기서 WaitOnAddress는 객체가 아닌 방법론으로, 주소를 키, 스레드 id를 value로 해시 테이블에 등록한 후 block이 되면 다른 주체가 스레드 id를 통해 깨우는 방법을 말한다. 

Enter하면 우선 gs reg에서 스레드 정보를 가져오고, 이후 lock btr(bit lock)으로 cs의 첫 멤버 lockCount를 1에서 0으로 수정하는데 이게 진입을 의미한다. 이후 스레드 id 저장, 재귀 카운트 세팅도 쭉 진행한다. 진입할 땐 lockCount가 1이면 1에서 0으로, 0이면 스레드 id를 확인한 뒤 같으면 재귀 카운트를 올린다. 다르면 커널 모드로 전환하여 대기를 건다. 


# **2. signal과 소유권**

동기화 객체의 signal은 현 스레드가 소유권을 놨다는 의미로, 이때 대기 중인 스레드 중 하나에게 소유권을 준다. 폴링 방식이 아니니 스레드들이 경쟁을 해서 차지하는 건 불가능하며, 현재 돌던 스레드가 누구에게 소유권을 줄지 결정하고 소유권을 놓는다. 따라서 논리적으로만 singla-nonsignal 전환되는 구조일 뿐 실제 내부 구현의 경우 상태는 유지되고 소유권만 넘어간다. 커널 동기화 객체의 경우 커널 객체 내부에서 대기 중인 스레드들을 큐 방식으로 관리하기 때문에 대부분 진입 순서가 보장되나, 이후 바뀔 여지가 있기 때문에 MS에서는 보장 되지 않는다고 명시하고 있으며 이에 의존해서는 안된다. 

반면 유저 동기화 객체는 새로 진입한 스레드와 기다리던 스레드가 경쟁을 한다. WaitOnAddress는 스레드를 큐가 아닌 해시테이블로 관리하며 깨워주기만 하고 획득하는 것은 알아서 하게 두는 구조이기 때문에 더 빨리 돌 수 있는 상태의 스레드가 채간다. 이전 스레드가 대기하던 스레드를 깨워주긴 하지만 이후에 바로 경쟁에 들어가는 것이다. 나오자마자 진입하는 일은 잘 없어서 이것이 실제 서버에서 문제가 되지는 않지만, 테스트 상황에는 멀티 스레드를 테스트를 해야 하는데 싱글 스레드처럼 동작하여 경합이 잘 안 일어나는 문제가 생길 수 있다.

<br/>

# **3. SRWLock**

SRWLock은 Reader/Writer(Shared/Exclusive)가 분리된 동기화를 제공하며 내부에서는 WaitOnAddress를 사용한다. Sh/Ex는 bit Interlock으로 판단한다. SRWLock 구조체는 내부에 Ptr 하나만 있고 여기에 bit 비교를 하는데, 이때 Shared 상태에서 새 Shared가 오면 이는 Exclusive 뒤에 줄을 서는 대신 바로 진입한다. 따라서 Shared가 계속 맞물리면 Exclusive는 쭉 block 상태가 유지되며 오랜 시간 진입하지 못할 수 있다. 

내부를 보면 ptr 하나만 있으며 recurs/spinCount, threadID를 다 보는 cs와 달리 bit 비교 한번만 진행하므로 cs보다 빠르다. 또, WaitOnAddress 객체를 가져다 쓰는 대신 WaitOnAddress가 내부에서 쓰는 함수를 바로 호출하기 때문에 함수 콜에 걸리는 시간도 단축된다.

