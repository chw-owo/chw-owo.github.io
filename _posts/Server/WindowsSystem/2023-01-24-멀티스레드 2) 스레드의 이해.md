---
title: 멀티스레드 2) 스레드의 이해
categories: WindowsSystem
tags: 
toc: true
toc_sticky: true
---

이 포스트는 윤성우님의 <뇌를 자극하는 윈도우즈 시스템 프로그래밍 (한빛미디어)> 내용을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 스레드란?**

## **1) 멀티 프로세스의 한계와 제안**

서버를 구현하다보면 하나의 프로그램으로 여러가지 일을 처리하기 위해서 둘 이상의 실행 흐름이 필요한 상황이 생긴다. 그러나 둘 이상의 일을 동시에 처리해야 할 때마다 추가적으로 프로세스를 생성한다면 빈번한 컨텍스트 스위칭으로 인해 성능에 안좋은 영향을 줄 것이다. 컨텍스트 스위칭은 프로세스 상태 정보를 저장 복원하는 일련의 과정으로, 저장 복원하는 정보 개수를 줄인다면 컨텍스트 스위칭으로 인한 부하를 줄일 수 있다. 기존의 프로세스 간 컨텍스트 스위칭에서는 프로세스들끼리 메모리를 공유하지 않기 때문에 메모리를 100%로 비우고 복원해야 했다. 반면 50%만 별개이고 50%는 공유하는 구조라면 굳이 비우고 복원하는 과정을 100%로 거치기 위해 성능을 저하시킬 필요가 없을 것이다. 이런 생각을 기반으로 스레드가 고안되었다. 스레드는 하나의 프로그램 내에서 둘 이상의 실행 흐름을 더 효율적으로 만들기 위해 설계되었다. 프로세스와 달리 스레드는 공유하는 상태 정보를 가지며, 이 덕분에 프로세스보다 빠르게 컨텍스트 스위칭을 할 수 있다. 

## **2) 메모리 구조 관점에서 스레드의 특징**

**특징 1.** 스레드마다 Stack을 독립적으로 할당한다. 

![image](https://user-images.githubusercontent.com/96677719/214252607-efaffbee-9704-4132-aad0-1ba0d6bf29d5.png)

프로세스와 마찬가지로 스레드도 독립적으로 스택을 할당한다. 독립된 스택 공간이 있어야 각각 별개의 함수를 호출할 수 있기 때문에, 실행 흐름 추가를 위한 최소 조건이 독립된 스택의 제공이라고 볼 수 있다. 

**특징 2.** Code 영역을 공유한다. 

![image](https://user-images.githubusercontent.com/96677719/214253330-e271d674-eaa2-49f7-8eb6-b4b7d254fe78.png)

스레드 간에는 Code 영역을 공유하기 때문에 각 스레드가 동일한 함수에 접근할 수 있다. 따라서 각 스레드의 main 함수는 코드 영역에 존재하는 모든 함수를 호출할 수 있다. 

**특징 3.** Data, Heap 영역을 공유한다. 

Data, Heap 영역을 공유하기 때문에 전역 변수, 정적 변수, malloc 함수를 통해 동적 할당된 메모리 공간을 공유할 수 있다. 따라서 IPC와 같은 별도의 통신 기법을 사용하지 않고도 데이터 공유가 가능하다. 이러한 특징 때문에 전역 변수, 정적 변수, 동적 할당된 공간을 사용할 때 더욱 주의해야 한다.

## **3) Windows에서의 프로세스/스레드** 

Windows에서는 스레드가 실제 프로그램의 흐름을 형성하고, 프로세스는 스레드를 담는 상자와 같은 역할을 한다. 앞서 프로세스 단원에서 언급했던 Running, Ready, Blocked 와 같은 상태 역시 프로세스가 아니라 스레드가 지니는 상태이며, 스케줄러가 실행의 단위로 선택하는 것도 프로세스가 아닌 스레드이다. 즉, Windows에서는 실행의 중심에 스레드가 있는 것이다. 이때, 프로그래머가 직접 생성하지 않아도 main 함수 호출을 위해 자동로 생성되는 기본 스레드를 main 스레드라고 부른다. 

**+)** 컨텍스트 스위칭의 경우, 서로 다른 프로세스에 있는 스레드끼리 스위칭이 일어날 경우에는 프로세스 단원에서 언급했던 것과 동일하게 이루어질 것이며 그 과정에서 Cache 메모리도 스위칭 될 것이다. 반면 동일 프로세스에 있는 스레드끼리 스위칭 할 경우 Cache 메모리를 비우고 다시 쌓을 필요가 없기 때문에 Cache 메모리 안에 있는 값이 유지되며 성능도 향상된다. 반면 pc, fp, sp 등의 레지스터는 어차피 스레드마다 다르게 동작하기 때문에 동일하게 스위칭이 일어난다.

<br/>

# **2. 스레드 구현 모델에 따른 구분**

## **1) Kernel Level Thread**  

스레드는 어떤 대상에 의해 만들어지냐에 따라 나눠질 수 있다. 첫번째로 커널이 스레드를 생성할 수 있다. 이 경우 운영체제가 제공하는 시스템 함수 호출을 통해 스레드 생성을 요구해야 한다. 그러면 운영체제는 해당 스레드를 생성, 관리하면서 새로운 흐름을 형성하도록 도와준다. 이렇게 프로그래머의 요청에 따라 스레드를 생성, 스케줄링 하는 주체가 커널인 경우 이를 두고 Kernel 레벨 스레드라고 부른다. 

![image](https://user-images.githubusercontent.com/96677719/214258579-11356c4f-67ef-4cef-9e3e-ddab577ed952.png)

위 그림은 Kernel 레벨 스레드 모델을 묘사한 것이다. User 영역은 사용자에 의해 할당되는 메모리 공간을 의미하는데 위에서 살펴보았던 Code, Data, Stack, Heap 영역 모두 User 영역에 해당한다. 그리고 프로세스에게 할당된 메모리 공간 중 User 영역을 제외한 나머지 영역을 두고 Kernel 영역이라 부른다. 운영체제가 실행되기 위해서는 운영체제도 메모리에 올라가게 되는데 이때 필요한 메모리 공간이 Kernel 영역에 해당한다. 일반 프로그램 실행을 위한 메모리 공간과 운영체제 실행을 위한 메모리 공간을 분리하지 않으면 관리 측면에서 곤란을 겪을 수 있기 때문에 이렇게 분리된다. 위의 스레드 예시에서는 스레드 A, B, C의 실행코드가 User 영역에, 스케줄러와 스케줄링에 필요한 스레드 정보가 Kernel 영역에 위치할 것이다. 오늘날 대부분의 운영체제는 Kernel Level Thread를 기반으로 스레드 모델을 지원한다. 

Kernel Level Thread의 장단점은 아래와 같다. 

**장점**:  커널에서 직접 제공하기 때문에 안정성과 다양한 기능성이 제공된다. 

**단점**:  커널에서 직접 제공하기 때문에 유저모드 - 커널모드의 전환이 빈번하게 일어난다. 이는 성능을 저하시킬 수 있다. 

## **2) User Level Thread**

오늘날 대부분의 멀티 프로세스 운영체제는 Kernel Level Thread를 지원하지만, 과거의 UNIX와 같은 일부 운영체제에서는 Kernel Level Thread를 지원하지 않는다. 이런 경우, 커널에 의존적이지 않은 형태로 스레드의 기능을 제공하는 라이브러리를 활용할 수 있는데 이렇게 만든 스레드를 유저 레벨 스레드라고 부른다. 커널에서 제공하는 기능이 아니므로 당연히 User 영역에서 실행된다. 위에서 스레드에 대한 정보가 Kernel 영역에 있었던 것과 달리 User Level Thread에서는 User 영역에 존재하며, 스케줄러는 스레드의 존재를 모른 채 프로세스만 스케줄링 하게 된다. 따라서 User Level Thread에서 스레드 간의 스케줄링은 User 영역에서 컨트롤해야 하는 대상이 된다. 

User Level Thread의 장단점은 아래와 같다. 

**장점**:  오로지 유저모드로 동작하기 때문에 성능 측면에서 유리하다.

**단점**:  만약 스레드 중 하나가 블로킹 될 경우, 운영체제는 프로세스의 존재만 알기 때문에 해당 프로세스의 스레드 전체가 블로킹 된다. 이러한 문제를 해결하려다 보면 프로그래밍이 복잡해지고 Kernel Level Thread에 비해 결과 예측이 어려워진다. 

## **3) Kernel Mode vs User Mode**

Windows는 동작할 때 Kernel Mode, User Mode 중 한가지 모드로 동작한다. 유저모드일 때는 커널 영역으로의 접근이 금지되는데, 이는 Kernel 영역의 주소에 프로그래머가 잘못 접근하는 것을 막기 위함이다. 반면 커널모드일 때는 모든 영역의 접근이 허용된다. 일반적인 프로그램을 실행할 때는 유저 모드로 동작하다가 Windows 커널이 실행되어야 하는 경우가 되면 커널 모드로 전환된다. 이때 스케줄러 역시 커널의 일부이기 때문에 스케줄러가 동작할 때 커널 모드로의 전환이 일어난다. 이 외에도 Windows 운영체제 차원에서 제공하는 시스템 함수들 중 상당수는 호출 시 커널모드로 동작하는데, 이러한 모드의 전환이 시스템에 부담을 주는 일이므로 이를 고려하여 상황에 따라 적절하게 사용해야 한다. 이러한 메모리 보호 기능은 CPU에 포함되어 있으며, 따라서 유저 모드/ 커널 모드를 제공하는 것은 Windows 운영체제가 아니라 프로세서이다. 

+) 과거의 32bit Windows 운영체제에서는 총 4GB 메모리 영역 중 2GB를 User 영역으로, 나머지 2GB를 Kernel 영역으로 사용했다. 오늘날 64bit 운영제체에서는 총 16TB 의 메모리를 각각 8TB씩 할당하고 있다. 

<br/>

# **출처**

뇌를 자극하는 윈도우즈 시스템 프로그래밍, 윤성우, 한빛미디어
