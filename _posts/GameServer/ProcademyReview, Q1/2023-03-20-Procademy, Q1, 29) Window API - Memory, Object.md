---
title: Procademy, Q1, 29) Window API - Memory, Object
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. Memory**

## **1) 윈도우 메모리 구조**

윈도우의 메모리는 주소 0부터 보호영역, 유저 영역, 또 다른 보호 영역 그리고 커널 영역으로 이루어져있다. 사용자가 메모리를 아무리 많이 써도 2^64 메모리 영역을 다 쓸 일은 없고, 만약 그걸 다 쓸 수 있다고 해도 그에 맞춰 페이징을 설계하면 낭비가 심해지기 때문에 윈도우에서는 일부 영역을 아예 접근 금지 영역으로 만들어둔 것이다. nullptr(0)이나 0x8123과 같은 값들이 접근 금지 영역에 포함되며 시스템적으로 크래쉬를 낼 때 사용하기도 한다. 

포인터 주소 체계에서 사용되지 않는 구간이 존재한다. 유저영역의 최대값이 43bit이므로 64bit 체제에서는 상위 13개 bit가 사용되지 않는 bit가 된다. 일반적인 사용은 아니지만 이를 주소로 마스킹하여 포인터에서 접근하지 못하는 bit 영역을 임의로 사용할 수도 있다. 포인터는 재사용이 되므로 이전에 할당-해제한 포인터를 다시 할당받게 되기도 하는데, 이 개념을 활용하면 이걸 막을 수 있다. 이런 사용의 경우 업데이트로 유저 영역이 늘어나면 당연히 문제가 생긴다. 

## **2) NonPaged Pool**

커널 메모리는 Paged pool, NonPaged pool로 나뉜다. Paged pool은 Page out 할 수 있는, 즉 물리 메모리에서 디스크로 뺄 수 있는 영역이고 NonPaged pool은 절대 Page out 할 수 없는, 무조건 물리 메모리에 상주해야 하는 메모리를 의미한다. NonPaged pool이 한계치를 초과하면 예상하지 못한 예외, 심한 경우 시스템 다운까지 발생할 수 있으므로 유의해야 한다. NonPaged pool 에러는 Interrupt 기반, 즉 하드웨어 신호를 기반으로 동작하는 코드에서 발생할 수 있다. 

NonPaged pool 에러가 생기는 상황은 다음과 같다. Page fault가 발생하면 CPU는 그 원인을 파악하여, Page out이 된 거라면 알아서 처리하고 아니라면 예외를 던진다. 그러나 소프트웨어 인터럽트는 하드웨어 인터럽트보다 우선순위가 낮아서, 인터럽트 처리를 위해 드라이브 코드가 작동 됐는데 그 안에서 Page fault가 발생한다면 예외를 던지고 메모리에 대해 Page In 하는 과정을 처리할 수 없게 된다. 

이와 같은 이유로 네트워크 관련 데이터는 NonPaged Pool을 사용해 처리한다. 메모리 버퍼가 대표적인 예시인데, 만약 수신 처리를 제대로 하지 못하면 메모리 버퍼를 위한 공간이 커지면서 NonPage Pool 사용량이 같이 늘어난다. Interrupt 기반 코드는 Interrupt가 발생한 즉시 처리되어야 하는데, 그게 처리되기 전에 Page out이 일어나면 NonPaged pool 관련 에러가 생긴다. 


## **3) 가상 메모리**

CR3에 현 프로세스의 가상 메모리 테이블과 매칭되는 물리 메모리 주소를 담고 이를 바탕으로 변환한다. TLB에서 miss가 나면 실제 테이블로 가고 hit가 되면 TLB에서 빠르게 가져오며 이런 역할을 하는 것들을 통틀어 MMU라고 부른다. 가상 메모리에선 선형적으로 존재하는 데이터도 물리메모리에서는 뒤죽박죽일 수 있지만, Page 단위로 묶여서 존재하기 때문에 Cache Hit에는 영향을 주지 않는다. 이를 통해 프로세스 간 메모리 단편화를 막을 수 있다. 커널 메모리도 가상 메모리 구조로 존재하는데 대신 이들은 프로세스끼리 공유할 수 있다. 

<br/>

# **2. Object**

## **1) Object Handle**

윈도우는 모든 리소스를 오브젝트라는 이름으로, 핸들을 통해 관리한다. 오브젝트는 유저 오브젝트와 커널 오브젝트로 나뉘며 핸들값은 32bit에서는 32bit, 64bit에서는 64bit의 크기를 갖는다 VOID 포인터이다. 유저 오브젝트는 유저가 사용하는 메모리에 있어서 유저 모드에서도 우리가 손쉽게 접근할 수 있는 오브젝트, 커널 오브젝트는 커널에 있어서 여러 프로세스끼리 공유가 가능하지만 커널 모드로 전환해야만 접근 가능한 오브젝트를 의미한다. 

커널 모드 전환은 인터럽트를 일으키고 가상 메모리 테이블을 전환하는 등 프로세스 간 컨텍스트 스위칭에 준하는 오버헤드가 생긴다. 또, 인터럽트를 하면 미리 해둔 분기 예측도 다 날라가게 된다. 물론 커널 모드 전환을 아예 안할 수는 없으며 커널 오브젝트를 안써도 전환이 일어날 수 지만, 그래도 커널 오브젝트 사용을 최소화하는 것이 성능에 좋다. 동기화에는 유저모드 객체를, 서버 간 통신에는 네트워크를, 분산에는 스레드를 사용하는 등의 방식으로 줄일 수 있다. 

SECURITY_ATTRIBUTES는 프로세스 간 접근 관련 보안 속성을 지정하는 것으로, 오브젝트를 만들 때 이를 인자로 받는다면 모두 커널 오브젝트이다. 물론 저게 없다고 모두 유저 오브젝트인 것은 아니다. 특히 Heap, IOCP, Socket 등은 전부 커널 오브젝트지만 다소 독특한 성격을 띄는데 Heap, IOCP는 프로세스 간 공유가 불가능하며, Heap은 호출할 때마다 커널 모드 전환이 일어나는 것도 아니다. 따라서 헷갈리는 오브젝트는 MS에서 공식 표를 참조하는 것이 좋다.

## **2) HeapCreate**

프로세스는 생성과 동시에 기본 Heap을 하나 세팅하고 그 핸들을 기억하기 때문에, 동적할당을 하면 자동으로 기본 Heap을 사용하게 된다. 이때 HeapCreate를 통해 동적 힙을 추가로 할당해서 사용할 수 있다. 이 경우 단편화 감소, 캐시 미스 감소 등의 효과를 얻을 순 있으나 이걸로 큰 성능 향상을 기대할 순 없다. 

그나마 현실적인 이점이라면, 멀티스레드에서 힙을 쓰면 매번 lock을 거는 동기화 작업이 들어가는데 스레드 별로 힙을 만들고 동기화를 끄면 성능상 이점을 얻을 수 있다. 하지만 이렇게 되면 해당 스레드에서 힙 삭제까지 해야되는데, 실제로 스레드 안에서 외부와의 상호작용 없이 할당하고 삭제까지 할 수 있는 상황은 흔하지 않다.

일반적인 사용은 아니지만 로그를 남길 때는 유용하게 쓸 수 있다. Release 빌드를 하면 디폴트 힙이 깨진 이후 Alloc을 하게 될 때 크래쉬가 난다. 그러면 CreateFile에서 크래쉬가 나면서 덤프도 남기지 못하게 되는데, 최악을 대비해 사용하는 힙은 디폴트 힙과 별도로 마련해두는 것이다.
