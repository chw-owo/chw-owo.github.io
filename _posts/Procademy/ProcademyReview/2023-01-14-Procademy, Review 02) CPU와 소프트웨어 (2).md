---
title: Procademy, Review 02) CPU와 소프트웨어 (2)
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

간단한 어셈블리어 예제를 통해 Stack이 동작하는 원리를 살펴보자.

## **1. 어셈블리어 예제**

**c++**
```c++
void Test()
{
    int a;
    int b;
    int c;

    a = 1;
    b = 2; 
    c = a + b;
    c = a * 3;
}
```

**어셈블리어(vs 2013, Debug Mode)**
```
push        ebp
mov         ebp, esp
sub         esp, 0E4h

push        ebx
push        esi
push        edi
lea         edi, [ebp-0E4h]

mov         ecx, 39h
mov         eax, 0CCCCCCCCh
rep stos    dword ptr es:[edi]

mov         dword ptr [a], 1
mov         dword ptr [b], 2
mov         eax, dword ptr [a]
add         eax, dword ptr [b]
mov         dword ptr [c], eax
imul        eax, dword ptr [a], 3
mov         dword ptr [c], eax

pop         edi
pop         esi
pop         ebx 
add         esp, 0E4h
cmp         ebp, esp
call        _RTC_CheckEsp_(00BC1285)
mov         esp, ebp
pop         ebp
ret
```

## **2. 어셈블리어 기초**

어셈블리어 분석을 들어가기 전에 기본적으로 알아야 할 것들이 있다. 

**h**

```
lea         edi, [ebp-0E4h]
```
여기서 h는 16진수를 의미한다. 0x로 시작하는 것과 동일한 의미로 해석하면 된다. 

<br/>

**변수가 동작하는 방식**

```
mov         dword ptr [a], 1
mov         dword ptr [b], 2
```
우리가 a, b, c라고 이름 붙였지만 이는 C++ 코드에서의 이름이지 기계어는 이러한 이름을 인식하지 못한다. \[a], \[b] 와 같은 표시 역시 사용자의 편의를 위해 visual studio가 표시해주고 있는 것뿐이다. 디스어셈블리 창에서 기호 이름 표시 기능을 끄면 아래와 같이 뜨는 것을 확인할 수 있다. 

```
mov         dword ptr [ebp-8],   1
mov         dword ptr [ebp-14h], 2
```

실제로는 위와 같이 ebp, esp에 대한 상대주소를 기반으로 돌아가게 된다. 즉, 변수 이름이 아니라 ebp 레지스터 기준으로 메모리 주소를 계산한 위치로 변수를 표현한다. 우리가 a라는 변수를 선언하면 일단은 그냥 메모리의 일정 부분을 비워두게 되고 컴파일러가 a라는 변수를 실제로 사용할 때, 베이스 포인터를 기준으로 어느 위치의 메모리를 사용하는지 실제 주소로 변환해주는 것이다. 절대 주소를 사용하는 전역 변수와는 다르게 동작한다. 

추가적으로, Release Mode 일 때는 변수 사이에 별도의 패딩을 두지 않고 붙여서 위치시키지만, Debug Mode일 때는 앞 뒤에 간격을 둔다. 현재 어셈블리 코드는 Debug 모드이기 때문에 변수 하나 당 12 byte (4byte 패딩 + 4byte 데이터 + 4byte 패딩)를 사용하고 있지만 Release 모드에서는 4byte를 사용하게 된다. 또, 기본적으로는 변수가 정의된 순서에 따라 위치가 정해지지만, 컴파일러 마음이라 배열과 같은 경우가 아니라면 보장받을 수 있는 것은 아니다. 

<br/>

**push/pop**

push, pop의 경우 32bit에서는 4byte, 64bit에서는 8byte 단위로 움직이게 된다. 예를 들어서 설명해보자.

```
push 10
```

10이라는 데이터를 stack에 넣고, esp를 한칸 늘린다. 만약 기존 esp가 500이었고 32bit 운영체제라면 esp는 496가 될 것이다. 

```
pop eax
```
stack의 top에 있는 데이터를 뽑아서 eax에 저장한 뒤, esp를 한칸 낮추게 된다. 만약 기존 esp가 500이었고 32bit 운영체제라면 esp는 504가 될 것이다.

<br/>

**lea와 대괄호 [ ]**

어셈블리어에서 대괄호 [ ]는 포인터 * 와 동일하게 쓰인다. 이 주소 안에 담긴 값을 가져오라는 의미로 해석하면 된다. 조금 특이한 경우는 lea에서 사용될 경우이다.

```
lea         edi, [ebp-0E4h]
```
```
lea         edi, ebp-0E4h
```
lea에 한해서는 위의 두가지 경우가 동일하게 동작한다. lea, load effective address는 주소 계산을 목적으로 하는 명령어로, 대괄호를 사용하든 사용하지 않든 해당 주소 값을 넣으라는 것을 의미한다. 사실 어셈블리어를 사용할 때는 대괄호 없이 lea edi, ebp-0E4h로 적는 것이 기본값이지만 visual studio가 친절하게 이렇게 보여주는 것이다. mov와 lea의 차이점은 null과 nullptr의 차이점 정도로 보면 된다. 주소 계산을 목적으로 하는 연산이라고 명확하게 하기 위해, 즉 가독성을 위해 별도의 명령어를 사용하는 것이지, 사실 mov edi, ebp-0E4h라고 사용해도 동일하게 동작한다. 

<br/>

그 외에 간단한 문법은 아래 포스트에서 참고할 수 있다. 

[어셈블리어 기초 1) 레지스터와 변수](https://chw-owo.github.io/os/%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC%EC%96%B4-%EA%B8%B0%EC%B4%88-1\)-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0%EC%99%80-%EB%B3%80%EC%88%98/)

[어셈블리어 기초 2) 기본 명령어](https://chw-owo.github.io/os/%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC%EC%96%B4-%EA%B8%B0%EC%B4%88-2\)-%EA%B8%B0%EB%B3%B8-%EB%AA%85%EB%A0%B9%EC%96%B4/)


## **3. 함수가 시작될 때 일어나는 일**

```
push        ebp
mov         ebp, esp
sub         esp, 0E4h

push        ebx
push        esi
push        edi

lea         edi, [ebp-0E4h]
mov         ecx, 39h
mov         eax, 0CCCCCCCCh
rep stos    dword ptr es:[edi]
```
새로 함수가 호출되었을 때, ebp, esp는 이전 함수 stack frame에 대한 정보를 갖고 있다. 따라서 ebp, esp 먼저 재설정하게 된다. 

```
push        ebp
mov         ebp, esp
```
일단 ebp를 스택에 저장하고, esp 값을 ebp로 옮긴다. 여기부터 새로운 처리가 시작되므로 기존의 ebp 값을 push를 통해 백업하고, 새롭게 베이스 포인터를 셋팅하는 것이다. 이 작업을 통해, 현재 함수가 끝났을 때 pop으로 이전 함수의 ebp를 확인하고 돌아갈 수 있다. 이때, 이전 함수로 돌아가는 주소를 잘못 찾으면 stack이 깨지면서 프로그램이 터지게 된다. 이럴 때 어셈블리 코드와 메모리를 열어보고 어디서 stack이 깨졌는지 역추적하면 보다 에러를 정확하게 찾을 수 있다. 

```
sub         esp, 0E4h
```
앞으로 처리할 부분에 대한 스택 사이즈를 0E24로 잡았다. 10진수로 변환하면 288 byte만큼의 공간이 현 함수의 스택프레임으로 잡힌 것이다. 이 수치는 내부 변수의 사이즈, 컴파일러 옵션 등에 따라 수시로 변할 수 있다. 실제로 visual studio 2017 버전의 경우 동일한 코드를 동작했을 때 스택 사이즈를 24h 만큼만 잡는다. 버전이 올라가면서 최적화가 더 잘되도록 발전한 것이다. 참고로 이 크기는 저장되는 값도, 해당 함수를 호출할 때마다 새롭게 계산되는 값도 아니다. 코드 영역에 고정되어있는 값이다. 이 과정에서 어떤 변수가 어떤 주소를 차지할 것인지도 정해진다. 

```
push        ebx
push        esi
push        edi
```

ebx, esi, edi도 백업한다. 이것도 기존 값을 되돌려놓기 위함이며 처리부가 끝나면 마지막에 되돌려주게 된다. 그러나 ebx, esi, edi는 임시적으로 사용하는 레지스터지, 저장하고 복원해야 하는 값은 아니다. 따라서 이 과정은 release mode에서는 빠지게 되며 아마 Debug를 돕기 위해 추가된 부분으로 추정된다.

```
lea         edi, [ebp-0E4h]
mov         ecx, 39h
mov         eax, 0CCCCCCCCh
rep stos    dword ptr es:[edi]
```

이 과정 역시 Debug 모드에서만 존재하는 부분이다. 39h는 288 / 4를 한 값으로, 여기서 rep는 스택 메모리 전체를 CCCCCCCC로 채우겠다는 반복문이다. 이러한 과정을 통해 메모리의 사용/해제 여부를 쉽게 확인할 수 있다. 그러나 이 반복 연산에서 시간이 소요되기 때문에, 디버그 모드에서는 지역 변수의 크기에 따라 성능이 달라지게 된다. 릴리즈 모드가 되면 이 부분이 사라지므로 지역 변수의 크기는 성능에 영향을 끼치지 않는다. 이것처럼 디버그 모드에서는 여러 안전장치를 기본으로 깔아주기 때문에, 디버그 모드에서는 동작하던 코드가 릴리즈 모드에서는 동작하지 않는 일이 생기기도 한다. 

여기까지가 함수가 호출될 때 기본적으로 일어나는 일이다. 그러나 스택프레임은 기본적으로 지역 변수를 저장하기 위해 존재한다. 따라서 오직 코드만 존재하고 지역변수를 하나도 쓰지 않는 함수의 경우 이러한 과정이 없을 수도 있다. 참고로 릴리즈 모드에서 최적화 컴파일러를 사용할 경우, 컴파일러가 성능을 위해 간단한 함수는 인라인처리 해버리기도 한다. 그러면 이렇게 함수 호출에 필요한 연산들을 생략할 수 있다. 

<br/>

## **4. 함수 내부에서 일어나는 일**

```
mov         dword ptr [a], 1
mov         dword ptr [b], 2
mov         eax, dword ptr [a]
add         eax, dword ptr [b]
mov         dword ptr [c], eax
imul        eax, dword ptr [a], 3
mov         dword ptr [c], eax
```
a, b에 1, 2를 불러온 뒤 eax에 넣어서 연산하고, 그 이후 다시 c에 넣는 것을 볼 수 있다. 메모리에 직접 접근하여 연산할 수 없기 때문에, 메모리에서 레지스터로 값을 복사해온 이후에 연산하게 되는 것을 확인할 수 있다.

<br/>

## **5. 함수가 종료된 뒤 일어나는 일**

```
pop         edi
pop         esi
pop         ebx 
add         esp, 0E4h
cmp         ebp, esp
call        _RTC_CheckEsp_(00BC1285)
mov         esp, ebp
pop         ebp
ret
```

함수 호출이 종료되고 나면 이전에 사용했던 값들을 되돌려야 한다. 

```
pop         edi
pop         esi
pop         ebx 
```
edi, esi, ebx를 복원하는 부분으로, 릴리즈 모드에서 push edi, esi, ebx가 사라지면 이 부분도 같이 사라진다. 

```
add         esp, 0E4h
cmp         ebp, esp
call        _RTC_CheckEsp_(00BC1285)
mov         esp, ebp
```
esp 를 복원하는 방법에는 두가지가 있다. 하나는 뺐던 값을 더하는 것, 하나는 mov esp, ebp 로 값을 맞춰주는 것이다. 이렇게 값을 복원하고 나면, 넣었던 값들은 존재는 하지만 아무 의미 없는 쓰레기 값이 된다. 

cmp ebp, esp는 이러한 과정을 거친 뒤 ebp와 esp가 동일한지 확인해주는 일종의 안전장치이다. ebp, esp 비교한 값을 저장해두고 있다가 _RTC_CheckEsp_ 에서 확인한다. 만약 일치하지 않는다면 stack이 깨졌다는 에러를 보내게 된다. 비교 확인한 이후에 한번 더 mov esp, ebp로 안전장치를 걸어둔다. 릴리즈 모드에서는 이러한 과정이 사라지게 된다. 

```
pop         ebp
```
맨 처음 push 했던 직전 함수의 ebp 값을 pop하여 다시 ebp에 넣어준다. 이 과정을 통해 해당 함수가 호출되기 이전의 상태로 완전히 돌아오게 된다. 

그런데 프로그래머가 stack memory를 잘못 조작해서 만약 기존의 ebp 값이 오염되었다면, 이 ebp에 오염된 값이 들어오게 된다. 위의 안전장치로도 이 단계에서 일어난 실수는 체크하지 못한다. 대신 그 다음 함수에서 감지할 수 있게 된다. 만약 Func0(){ Func1(); } 와 같은 구조가 있을 때, Func0()에서 Func1()단계에 일어난 실수를 감지하는 것이다. 

ebp에 오염된 값이 들어가도 코드는 실행할 수 있다. 다음에 실행할 코드를 가리키는 건 ebp, esp가 아니라 ip이다. 코드 실행은 코드 영역에서 일어나는 일이기 때문에, stack memory와는 관련이 없다. 하지만 stack memory를 통해 잘못된 값이 들어가면서 나중에 예상하지 못한 지점에서 오작동이 날 수 있기 때문에 더 유의해야 한다. 지역변수에서 제대로 값을 못불러오는데 원인을 알 수 없다면 메모리, 레지스터를 열어서 esp, ebp를 확인해보는 것이 좋다. 그렇게 추적하여 stack memory가 깨졌는지 확인할 수 있다. 

<br/>

## **6. 그 외의 상황**

**1) 지역 변수 참조**

```c++
int* Test(int a)
{
    int x = a + 10;
    return &x;
}

void Test2()
{
    int* p = Test(10);
    printf("%d", *p);
}

int main()
{
    Test2();
}
```

지역 변수는 함수가 끝나면 사라지는 값이기 때문에, 논리적으로는 위 함수가 실행되지 않아야 한다. 그러나 메모리를 보면 ebp, esp의 값이 변했을 뿐, stack에는 데이터가 여전히 남아있기 때문에 결과가 제대로 출력되는 것을 확인할 수 있다. 이런 경우 당장은 실행이 제대로 되겠지만 이후 해당 stack memory에 다른 값이 들어오게 됐을 때 엉뚱한 값을 출력하는 방식으로 문제가 생길 수 있다. 지역변수에 참조나 포인터를 사용할 때는 해당 변수의 유효범위를 반드시 확인해야 하며, 애초에 사용하지 않는 것이 좋다. 

<br/>

**2) 선언과 초기화**

```c++
void Test2()
{
    // 1
    int a;
    a = 0;

    // 2
    int b = 0;
}
```
1, 2 둘 다 성능에 있어서는 차이가 없다. 왜냐면 지역변수에 있어서는 선언이라는 개념이 없고 정해진 공간에 값을 대입하는 개념만 있기 때문이다. 고로 읽기가 아니라 쓰기만 목적으로 하는 변수라면 성능을 위해 굳이 불필요한 초기화를 하지 않는 것을 권장한다. 


## **7. 기계어 변환**

어셈블리어는 한줄씩 기계어와 맵핑할 수 있다. 컴파일러를 거쳐 최종적으로 기계어 코드가 만들어지고, CPU는 기계어 코드를 바탕으로 프로그램을 처리하게 된다. 디스어셈블리 창에서 코드 바이트 표시하면 기계어로 어떻게 변환 되는지도 볼 수 있다. 우리가 쓰는 체제는 명령어의 크기가 가변적인 것도 확인할 수 있다. 

기계어 코드는 옵코드라고 하는데 실제로는 bit 단위로 들어가게 된다. 프로그램이 동작하게 되면 우선 함수들을 명령어의 나열로 만들고, 메모리 상에 최종 기계어 코드를 올리게 된다. 그리고 ip 레지스터(=pc)가 이리저리 옮겨다니며 가리키는 명령어를 차례로 호출한다. 내부적으로 보았을 때, 함수 호출, call은 이 eip 위치를 변화시키는 것을 의미한다. x86, x86-64, arm등은 우리가 흔히 접하는 대표적인 CPU 아키텍쳐인데, 동일한 아키텍쳐를 쓴다는 것은 이러한 명령어 Set, 레지스터 이름, 레지스터 역할 등이 동일하다는 것을 의미한다. 

명령어 Set은 크게 RISC와 CISC로 나뉘는데 현재 우리는 일반적으로 CISC 명령어 Set을 따른다. RISC는 명령어 용량이 일정하여 cpu가 해석하는 게 빠른 반면 복잡한 명령어 사용이 어렵다. CISC는 명령어 용량이 가변적이어서 해석은 다소 느리지만 imul과 같은 복잡한 명령어 사용이 가능하다. 예를 들어 CISC에서는 mov로 퉁칠 수 있는 명령어를 RISC에서는 load, store로 나누어 명확하게 분담하게 된다. 

<br/>

## **8. 릴리즈 모드에서의 디버깅**

흔히 릴리즈 모드에서는 디버깅을 할 수 없다고 알려져있으나, 사실 돌고 있는 프로세스라면 모두 디버깅이 가능하다. 다만, 릴리즈 모드에서 디버깅이 안된다는 것은 소스코드와 맵핑이 안된다는 것을 의미한다. 릴리즈 모드에서 빌드를 하게 되면 최적화 컴파일러가 자동으로 켜져서, 컴파일러가 소스코드를 효율적이라 생각하는 방향으로 변경하게 된다. 그 결과 내가 짠 코드와 어셈블리가 맵핑이 안돼서 breakpoint가 안잡히는 것이다. 따라서 최적화 컴파일러를 끄면 릴리즈 모드에서도 breakpoint를 잡고 디버깅을 할 수 있다. 물론 최적화 컴파일러를 킨 것에 비해 성능과 속도는 약간 안 좋아지게 된다. 

선생님께서는 온라인 게임의 경우 최적화 컴파일을 제거하고 릴리즈 빌드 하는 것을 권장한다고 하셨다. (프로젝트 속성에서 설정 가능하다) 그렇게 설정할 경우 디버깅용 안전장치는 제거하는 동시에 소스코드 맵핑은 여전히 할 수 있어서, 상대적으로 정확한 버그 해결이 가능하다고 한다. 게임 서버는 서비스 이후 5년 뒤, 7년 뒤에도 버그가 날 수 있는 분야이기 때문에, 성능 향상과 빠른 버그 해결 중에서 후자를 어느정도는 고려하는 것이 좋다고 하셨다.

추가적으로, 디버깅 시에 브레이크 포인트를 잡고 가다보면 in al, dx 와 같은 의미 없는 코드가 나올 때도 있다. 이는 visual studio가 잘못 번역한 거니까 그냥 위치를 조금 더 위로 잡으면 해결된다. 

## **Question**

**Q. return 전에 xor은 왜 나오나요?**

return 값을 전달할 때 eax 를 사용하기 때문에 eax를 0으로 돌려주어야 한다. 따라서 return 전에 xor eax eax가 들어가게 된다.

<br/>

**Q. ebp, esp가 다르다는 얘기는 ebp 값이 오염이 돼서 Stack이 깨진다는 이야기인가요?**

대부분의 경우 그렇다. esp는 상대적으로 움직이기 때문에 오염될 가능성이 많지 않고 ebp가 문제일 가능성이 높다. 함수 안에서 또 다른 함수를 호출할 때 이런 일이 생기기 쉽다.

<br/>

**Q. 동일한 코드가 다른 어셈블리어로 변환될 수도 있나요?**

컴파일러 종류, 설정, 버전에 따라 달라질 수 있다. 

<br/>

**Q. ebp 위에 바로 값이 올라가지 않고 패딩이 생겼어요 왜인가요?**

포인터 변수를 지역에 선언하는 경우에는 안전 장치를 컴파일러가 알아서 추가하기도 한다. 

<br/>
