---
title: Procademy, Q3, 03) Multithread - 정리
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 프로세스와 스레드**

프로세스는 실행 중인 프로그램을 의미한다. 명령어(Code)와 프로그램 수행에 필요한 데이터(Heap, Stack, Data, etc…)들의 집합을 프로세스라고 볼 수 있으며, 이러한 메모리 구조는 프로세스 개수만큼 생성된다. 이때, 윈도우 OS에서 작업의 실제 수행 주체는 프로세스가 아닌 스레드이다. 프로세스는 메모리 구조와 한개 혹은 여러개의 스레드로 구성되며, 한 프로세스 내의 스레드들은 모두 같은 메모리를 바라본다.  

스레드는 커널 영역에 생성되는 실제 작업 수행 단위로, 스레드가 쓰는 메모리는 프로세스 주소 공간 내에 생성된다. 스레드가 사용하는 공간은 사적 공간과 공유 공간으로 나뉘는데, 사적 공간에는 스레드 로컬 스토리지(=TLS), 1MB의 유저 스택, 커널 스택이 있다. TLS에는 데이터 영역에 해당하는 전역 변수와 정적 변수 등이 저장된다. 유저 스택에는 함수 호출에 필요한 데이터들이, 커널 스택에는 인터럽트 발생 시 저장되어야 하는 데이터들이 저장된다. 

스레드가 실행하는 코드는 프로세스의 코드 영역에 있으며, 코드 영역은 동일 프로세스 내 스레드끼리의 공유 공간이므로 스레드는 처음 요청 받은 함수 외에도 프로세스 내 다른 함수들을 호출할 수 있다. 또, 프로세스의 힙 영역, 데이터 영역, 그 외 스택을 제외한 메모리 영역들 역시 공유되는 영역으로, 따로 지정하지 않는 이상 모든 스레드는 프로세스의 기본 힙을 공유하여 사용하며 정적, 전역 변수도 공유된다. 

스레드가 실행되면 코어의 레지스터들은 해당 스레드 실행을 위한 레지스터 값으로 채워진다. 이러한 정보를 스레드 컨텍스트라고 하며, 여기엔 가상 메모리 테이블을 가리키는 cr3, 수행할 명령어를 가리키는 ip, 스택 위치를 가리키는 sp 등이 포함된다. 이런 정보를 저장한 구조체를 TCB(Thread Context Block)라고 하며, 스레드가 정지되면 이를 커널 영역에 보관하다가 해당 스레드가 스케줄링 되면 코어로 불러와서 실행한다.  

정리하자면 스레드는 프로세스 내에서 둘 이상의 실행 흐름을 두기 위해 실행 단위를 분리한 것으로 실제적인 실행 단위이다. 스레드는 프로세스처럼 완전히 독립된 구조를 사용하지는 않으며, 공유하는 요소가 있기 때문에 동일 프로세스 내 스레드들끼리 스위칭 할 경우 오버헤드가 줄어든다. 구체적으로는 상대적으로 Cache Miss가 줄어들고, 일부 스레드 컨텍스트 정보를 (레지스터 값) 변경하지 않아도 되기 때문이다. 

이때 OS가 TCB로 관리하는 실행 주체로서의 실제 스레드, 커널 영역에 존재하는 스레드 객체, 유저가 반환 받는 스레드 핸들은 모두 다른 것이다. 실제 스레드와 스레드 핸들이 스레드 객체를 참조하고 있으며, 유저는 스레드 핸들을 통해 스레드의 정보를 얻을 수 있다. 이런 이유로 스레드 객체는 처음 생성 시 usage count가 2로 설정되고, 스레드 핸들로 CloseHandle을 호출하면 1이, 스레드가 종료되면 또 1이 줄어든다.

<br/>

# **2. 커널 영역과 유저 영역**

메모리는 활용 대상에 따라 유저 영역과 커널 영역으로 나뉜다. 유저 영역은 유저 프로그램 동작 시 사용하는 메모리 영역, 커널 영역은 OS 동작 시 사용하는 메모리 영역을 의미한다. 유저 영역의 메모리 오염은 현 프로세스에만 영향을 주지만, 커널 영역의 메모리 오염은 시스템 전체에 문제를 일으킬 수 있다. C처럼 메모리에 직접 접근하는 경우 유저가 실수로 커널 영역을 오염시킬 수 있기 때문에 유저 모드와 커널 모드를 분리하여 이를 방지한다. 

유저 모드는 커널 영역에 접근할 경우 예외가 발생하는 모드, 커널 모드는 모든 영역에 접근할 수 있는 모드이다. 프로세스는 기본적으로 유저 모드에서 동작하다가, OS 커널을 실행해야 하는 경우 커널 모드로 전환된다. 유저는 커널 영역에 직접 접근할 수 없으며, 요청을 하면 커널 모드 전환 후 커널이 요청 받은 작업을 수행한다. 이때 커널 모드, 유저 모드를 제공하는 주체는 OS가 아닌 프로세서, 즉 CPU의 자체적인 메모리 보호 기능이다. 

스레드도 커널 레벨 스레드와 유저 레벨 스레드로 나뉜다. 커널 스레드는 커널이 생성, 관리 하고 언제 실행할 지 결정한다. 다른 커널 객체처럼 usage count가 0이 되면 커널이 소멸 시킨다. 반면 유저 스레드는 유저가 스레드를 생성, 관리, 삭제하고 언제 실행할 지 결정 한다. 코어는 유저 스레드의 존재를 모르기에 정말 병렬로 처리할 순 없지만, 언어나 OS가 멀티 스레드를 지원하지 않는 경우 프로그램의 실행 흐름을 제어하기 위해 이를 사용한다. 

<br/>

# **3. OS의 종류**

OS는 응답성을 기준으로 RTOS와 일반 OS로 나뉜다. RTOS (Real-Time OS)는 다시 Soft RTOS와 Hard RTOS로 나뉘는데, Soft RTOS는 제한적인 목적으로 사용하는 OS로, 일반 OS보다 훨씬 가볍고 좋은 응답성을 가진다는 점에서 차이가 있지 구조적으로 큰 차이가 있진 않다. 반면 Hard RTOS는 데드라인을 반드시 지키는 OS로, 일반 OS와 전혀 다른 알고리즘으로 스케줄러가 디자인 된다.

스케줄링 방식을 기준으로는 선점형 OS와 비선점형 OS로 나뉜다. 이때 ‘선점’은 OS 입장에서의 선점으로, OS가 유저와 상관 없이 임의로 스케줄링을 조정하겠다는 것을 의미한다. 비선점형 OS는 현재 실행 중인 스레드보다 높은 우선 순위의 스레드가 들어와도 실행 대상을 변경하지 않으며, 명시적으로 CPU를 내놓거나 퀀텀을 다 사용할 때까지 기다린다. 따라서 프로그래머가 한 프로세스가 CPU를 독차지 하지 않도록 신경써서 구현해야 한다. 과거 Window 3.x 시리즈가 이 방식을 따랐다. 

선점형 OS는 스케줄링에 OS가 관여한다는 의미로, 현재 실행 중인 스레드보다 높은 우선 순위의 스레드가 등장하면 높은 우선 순위의 스레드가 즉각 실행된다. 따라서 비선점형 OS에 비해 스케줄러(타이머 인터럽트 핸들러)가 설정된 시간 단위마다 더 많은 것을 체크하게 된다. 대신 프로그래머가 신경쓸 영역이 줄어든다. 윈도우 OS는 현재 우선 순위 기반의 라운드 로빈 방식 선점형 스케줄링 알고리즘을 채택하고 있다. 여기서 라운드 로빈은 퀀텀을 할당 받아서 순서가 자동으로 돌아가는 구조를 의미한다. 

<br/>


# **4. 선점형 OS의 스케줄링 절차**

코어는 커널 영역에 인터럽트와 인터럽트에 해당하는 핸들러 코드 테이블을 갖고 있으며, 이를 인터럽트 서비스 루틴이라 부른다. 0번 타이머 인터럽트 핸들러는 현 스레드의 퀀텀이 끝났는지, 더 우선순위가 높은 스레드는 없는지 체크하는 코드이며 이 기능을 스케줄러라 부른다. 즉 별도의 스케줄러라는 하드웨어가 있는 게 아니라, 코어들이 모두 커널 영역 ISR 내부에 스케줄링 기능의 코드를 갖고 있는 것이다. 

스케줄러가 봤을 때 스레드 스위칭이 필요한 상황이라면 디스패쳐 인터럽트를 발생시킨다. 이때 디스패쳐 인터럽트의 우선순위는 겨우 스레드 인터럽트 한 단계 위이기 때문에 타이머 인터럽트 핸들러가 종료된 뒤 실행된다. 디스패쳐 핸들러는 TCB를 어떤 코어의 레디큐에 넣을지 탐색하고 적절한 큐에 직접 넣는다. 그 후 다시 자기 코어로 돌아와 가장 우선순위가 높은 스레드로 스위칭을 실행한다. 이 모든 과정이 디스패쳐 핸들러의 내부에서 진행된다. 

이때 윈도우는 실행 단위로 스레드를 사용하기에 프로세스가 아닌 스레드만이 Running, Ready, Blocked의 상태를 지니며, 스케줄링 시 어떤 프로세스 소속인지는 전혀 고려하지 않는다. 또, 코어들끼리는 서로 동기화되지 않으며, 각자의 0번 타이머 인터럽트에 맞춰 각자의 레디큐에서 TCB를 꺼내올뿐이다. 타이머 인터럽트를 생략하는 명령어도 존재하고, 초 당 clock 수까지만 통일할 뿐 인터럽트 타이밍까지 정확히 동기화하는 것은 아니다. 
