---
title: Memory 04) Thread Stack
categories: WindowsViaC-Cpp
tags: 
toc: true
toc_sticky: true
---

이 포스트는 <제프리 리처의 Windows via C/C++ (한빛미디어)> 내용을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 스레드 스택**

스레드가 생성되면 기본적으로 시스템은 프로세스 주소 공간으로부터 스레드 스택으로 사용할 영역을 1MB 예약하고, 이 중 물리적 저장소로 두 개의 페이지를 커밋한다. 이 기본 설정은 컴파일러 옵션, 링커 옵션에서 변경할 수 있으며, CreateThread, _beginthreadex를 호출할 때 따로 설정할 수도 있다. 

스택 영역과 커밋된 저장소는 모두 PAGE_READWRITE 특성을 지닌다. 예약을 완료하고 나면 시스템은 예약된 영역의 최상위 두 페이지에 커밋하고 스택 포인터 레지스터는 최상위 페이지의 끝을 가리키게 된다. 이때 두번째 페이지는 가드 페이지라고 불린다. 스레드가 함수를 반복 호출하면 call tree 깊이가 증가하며 더 많은 스택 공간이 필요해진다. 

스레드가 가드 페이지 내 저장소에 접근을 시도하면 시스템은 가드 페이지 이하 공간을 추가적으로 커밋하고 보호 특성을 해제하며 새롭게 커밋된 페이지에 가드 보호 특성을 지정한다. 이러한 기법을 통해 스레드가 필요로 하는 크기에 맞춰 물리적 저장소를 증가 시킬 수 있다. 

<br/>

# **2. 스택 오버플로우**

만약 이미 한번 가드 페이지에 접근했는데, 또 새로 커밋된 페이지의 최하단에 닿게 되면 이번에도 다시 저장소가 커밋된다. 대신 이때는 새로 커밋한 저장소에 대해 가드 보호 특성을 지정하지 않고  EXCEPTION_STACK_OVERFLOW를 발생시킨다. 이는 스택으로 예약된 주소공간이 모두 커밋되었다는 것을 의미하며 이후 코드를 계속 진행시킬 수 있다.

이때 최하위 영역은 항상 예약 상태로만 유지하고 커밋하지 않는데, EXCEPTION_STACK_OVERFLOW 이후에도 계속 스택을 사용해서 이 영역에 닿게 되면 접근 위반 예외를 발생시키고 프로세스를 종료한다. 만약 가드페이지를 재설정 하고 싶다면 _resetstkoflw를 호출해야 한다. 

C/C++ 런타임 라이브러리는 이러한 상황을 대비해 스택을 확인하는 함수를 가지고 있다. 이는 컴파일 시점에서 컴파일러가 스택 확인이 필요한 곳에서 자동으로 호출하도록 코드를 포함시키며 디스어셈블리로 확인할 수 있다. /GS 컴파일러 스위치를 이용하면 페이지 크기 임계값을 사용자가 제어할 수 있다. 