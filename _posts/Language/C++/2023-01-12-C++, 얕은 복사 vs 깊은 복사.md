---
title: C++, 얕은 복사 vs 깊은 복사
categories: C++
tags: 
toc: true
toc_sticky: true
---

## **1. 얕은 복사**

```c++
class Knight
{
public:
public:
    int _hp = 100;
};

int main()
{
    // 기본 생성자
    Knight k1;
    k1._hp = 200;

    // 복사 생성자
    Knight k2 = k1;

    // 기본 생성자 + 복사 대입 연산자
    Knight k3;
    k3 = k1;

    return 0;
}
```
k2를 생성하는 것과 k3를 생성하는 것은 동일해보이지만 복사 생성자를 쓰는지, 복사 대입 연산자를 쓰는지에 있어서 차이를 가진다. 위 코드를 그대로 실행해보면, 분명 복사 생성자나 복사 대입 연산자를 따로 구현하지 않았음에도 잘 실행되는 것을 확인할 수 있다. 즉, 복사 생성자와 복사 대입 연산자는 직접 만들지 않아도 컴파일러가 암시적으로 만들어준다는 결론을 낼 수 있다. 컴파일러가 암시적으로 만들어준 복사 생성자, 복사 대입 연산자의 경우 메모리에서 k1이 가지고 있던 값을 그대로 복사해서 넣는다는 특징을 가지는데, 지금 같은 예시에서는 상관 없지만 멤버 변수에 참조나 포인터가 있다면 문제가 생긴다. 아래에 예시를 들어보자.

```c++
class Pet
{
    ...
};

class Knight
{
public:
public:
    int _hp = 100;
    Pet _pet;
};
```

위와 같이 Knight 객체가 Pet를 갖도록 하고 싶다고 해보자. 이 코드에서는 Knight가 소멸되면 Pet도 같이 소멸되게 된다. 또, 만약 Pet을 상속 받은 Rabbit Pet, Puppy Pet 등이 있다면 이들은 Knight의 Pet에 들어가지 못하게 된. 그런 문제가 아니더라도 만약 Pet의 데이터 영역이 매우 크다면 Knight 역시 같이 매우 커지게 되는 문제도 있다. 따라서 멤버 변수로 클래스를 갖게 된다면 아래와 같이 참조값 혹은 포인터로 갖고 있는 편이 깔끔하다.

```c++
class Pet
{
    ...
};

class Knight
{
public:
public:
    int _hp = 100;
    Pet* _pet;
};

int main()
{

    Pet* pet = new Pet();

    Knight k1;
    k1._hp = 200;
    k1._pet = pet

    Knight k2 = k1;
    ...

    delete pet;
    return 0;
}
```

문제는 이를 컴파일러가 만들어준 복사 생성자 / 복사 대입 연산자로 복사하게 되면 k1과 k2가 동일한 Pet의 주소값을 가리키게 된다. 

이처럼 멤버 데이터를 비트열 단위로 똑같이 복사하는 것을 두고 얕은 복사라고 부른다. 이런 경우에 Knight 객체들이 각자 다른 Pet을 갖도록 하고 싶다면 복사 생성자, 복사 대입 연산자를 따로 만들어주어야 한다. 

<br/>

## **2. 깊은 복사**

깊은 복사는 멤버 데이터가 참조(주소) 값이라면 데이터를 새로 만들어주는 복사를 말한다. 즉, 원본 객체가 참조하는 대상까지 새로 만들어서 복사함으로서 각 객체들이 멤버 변수를 통해 상이한 객체를 가리키는 상태로 만드는 것이다. 예시는 아래와 같다.  

```c++
class Pet
{
public:
    Pet()
    {

    }

    Pet(const Pet& pet)
    {

    }
};

class Knight
{
public:
    Knight()
    { 
        _pet = new Pet();
    }

    Knight(const Knight& knight)
    {
        _hp = knight._hp;
        _pet = new Pet(*(knight._pet));
    }

    Knight& operator=(const Knight& knight)
    {
        _hp = knight._hp;
        _pet = new Pet(*(knight._pet));
        return *this;
    }

    ~Knight()
    {
        delete _pet;
    }

public:
    int _hp = 100;
    Pet* _pet;
};
```

이처럼 각 Knight가 새로운 pet을 가리키도록 할당해준 것이 깊은 복사의 한 예시라고 볼 수 있다. 

<br/>

## **3. 암시적 복사(얕은 복사) vs 명시적 복사 (깊은 복사)**

**1) 암시적 복사 생성자의 실행 단계**

I.      부모 클래스의 복사 생성자 호출
II.     멤버 클래스의 복사 생성자 호출
III.    멤버가 기본 타입일 경우 메모리 복사 (얕은 복사)

<br/>

**2) 명시적 복사 생성자의 실행 단계**

I.      부모 클래스의 기본 생성자 호출
II.     멤버 클래스의 기본 생성자 호출

<br/>

**3) 암시적 복사 대입 연산자의 실행 단계**

<br/>

**4) 암시적 복사 대입 연산자의 실행 단계**

<br/>

## **출처**

[C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈] Part1: C++ 프로그래밍 입문, Rookiss
