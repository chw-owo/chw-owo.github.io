---
title: Web Browser 04) 프로토콜 스택에 송신 의뢰하기
categories: 1%Network
tags: 
toc: true
toc_sticky: true
---

이 포스트는 Tsutomu tone의 <성공과 실패를 결정하는 1%의 네트워크 원리(성안당)> 내용을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 데이터 송수신 개요**

애플리케이션이 IP 주소를 반환받고 나면, 직접 데이터를 송신하는 게 아니라 해당 주소로 송신하도록 OS 내부 프로토콜 스택에 의뢰한다. 이때도 Socket 라이브러리를 사용하게 되며, 소켓을 통해 데이터를 주고 받는 과정을 도식화하면 송수신 컴퓨터 사이의 데이터가 오가는 통로가 있고 그 통로로 데이터를 전달하는 것처럼 표현할 수 있다. 

송수신을 위해서는 통로를 연결, 해제하는 추가적인 동작이 필요하다. 통로 양 끝의 데이터 출입구를 소켓이라 부르는데, 우선 서버 측에서 소켓을 만든 뒤 그 소켓에 클라이언트가 자신의 소켓을 연결하기를 기다린다. 소켓이 연결되면 데이터를 전송하고, 데이터를 전송한 뒤엔 연결했던 통로를 분리한다. 연결은 어느쪽에서 끊든지 무관하며, 분리 이후 소켓을 말소하면 통신 동작이 종료된다. 

이때 앞서 말했다시피 위와 같은 일련의 동작들을 직접 실행하는 것은 OS 내부 프로토콜 스택이며, 애플리케이션은 단계별로 적절한 Socket 라이브러리 내 함수를 호출하여 이를 실행하도록 의뢰한다. 즉, 데이터를 실제로 송수신 하는 것은 애플리케이션이 아니라 프로토콜 스택, LAN 드라이버, LAN 어댑터인 것이다. 호출하는 방식은 아래와 같다. 

```c++
// IP 얻어오기
<메모리 영역> = gethostbyname("<URL 주소>");

// 소켓 준비
<디스크립터> = socket(<IPv4 사용>, <스트림형>, ...);

// 소켓 연결, 접속
connect(<디스크립터>, <서버의 IP 주소와 포트 번호>, ...);

// 데이터 송신
write(<디스크립터>, <송신 데이터>, <송신 데이터 길이>);

// 데이터 수신
<수신 데이터 길이> = read(<디스크립터>, <수신 버퍼>, ...);

// 연결 해제
close(<디스크립터>);
```

<br/>

# **2. 소켓의 작성**

```c++
<디스크립터> = socket(<IPv4 사용>, <스트림형>, ...);
```

우선 socket을 호출하면 socket 내부로 제어가 넘어가면서 소켓을 만드는 동작을 실행하고, 다시 애플리케이션으로 제어가 돌아온다. 소켓이 만들어지고 나면 디스크립터를 반환하는데, 이는 복수의 소켓을 사용할 경우를 대비해 소켓을 식별하기 위한 것으로 메모리에 기록해두었다가 사용하게 된다. 

<br/>

# **3. 소켓의 연결, 접속**

```c++
connect(<디스크립터>, <서버의 IP 주소와 포트 번호>, ...);
```
소켓을 연결할 때는 디스크립터, 서버의 IP 주소, 포트 번호를 전달하여 connect를 호출하는데, 프로토콜 스택은 디스크립터를 보고 어느 소켓을 접속시킬지 판단한다. connect가 이루어지면 각각의 프로토콜 스택들이 연결된 상대의 IP 주소, 포트 번호 등의 정보를 소켓에 기록함으로써 데이터 송수신 가능한 상태가 된다.

IP 주소는 DNS에 조회했던 액세스 대상의 주소를 의미하며 포트 번호는 그 서버의 어떤 소켓에 접속할 지를 지정하는 값이다. 포트 번호는 웹서버면 80, 메일이면 25를 사용하는 식으로 종류에 따라 미리 결정된 값을 사용하며, 클라 측 포트 번호는 프로토콜 스택이 적당한 값을 할당한 뒤 서버 측에 통지한다. 

<br/>

# **4. 데이터 송수신**

```c++
write(<디스크립터>, <송신 데이터>, <송신 데이터 길이>);
<수신 데이터 길이> = read(<디스크립터>, <수신 버퍼>, ...);
```

연결 이후에는 write를 호출하여 데이터를 전달한다. HTTP 리퀘스트 메시지를 송신하고자 한다면, 디스크립터와 이 데이터, 그리고 길이를 전달하여 write를 호출하면 된다. 그러면 소켓에 기록되어 있던 연결 상대 정보를 바탕으로 이를 송신해준다. 

수신할 때는 read를 호출하는데, 이때 수신한 응답 메시지를 전달한 수신 버퍼에 저장하게 된다. 수신 버퍼는 애플리케이션 내부에 마련된 메모리 영역이므로 이후 애플리케이션에서 이에 접근해 메시지를 확인할 수 있다. 

<br/>

# **5. 접속 해제**

```c++
close(<디스크립터>);
```
송수신을 완료하면 close를 호출하여 연결을 끊고 소켓을 말소시킨다. 이 과정을 웹에서 살펴보자면, 일반적으로는 응답 메시지 송신 후 서버측에서 close를 먼저 호출한다. 그러면 이것이 클라에 전달되어 클라이언트의 소켓도 연결 끊기 단계로 진입된다. 그리고 브라우저가 read로 수신을 의뢰했을 때 read는 연결이 끊겼다는 사실을 브라우저에 통지하게 되며, 브라우저에서도 close를 호출해 연결 끊기 단계에 들어간다. 

이처럼 HTTP는 HTML 문서, 영상 데이터 등을 하나하나 별도의 데이터로 취급하여 1개의 데이터를 읽을 때마다 접속 - 송신 - 수신 - 연결 끊기의 과정을 반복한다. 그러나 복수의 데이터를 읽을 때 접속 - 연결 해제를 반복하는 것은 비효율적이기 때문에 연결을 끊지 않는 방법도 마련되어 있다. 이 방법은 이후에 다룰 것이며, 이 경우 리퀘스트 데이터가 없어진 상태일 때 브라우저가 연결 끊기 동작에 들어가게 된다. 