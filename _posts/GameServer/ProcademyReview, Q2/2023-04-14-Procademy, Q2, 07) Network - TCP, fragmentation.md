---
title: Procademy, Q2, 07) Network - TCP, fragmentation
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. socket TCP 함수**

## **1) accept**

socket은 기본 설정이 block socket이며, accept 역시 block 함수이다. 즉, accept할 게 생길 때까지 block이 걸리며 그동안은 cpu를 차지하지 않고 멈춰있는다. 또, client에서는 connect 순간에 바인딩을 하는데 이것 역시 block 함수이다. non-block socket의 경우 connect에서 성공이든 실패든 바로 결과가 return되는 반면 block socket은 잠시 기다렸다가 반환한다. 상대가 listen이 아니거나, 내 메시지가 전송이 안되거나, fin을 보냈는데 rst가 오는 경우 등에 실패를 반환한다. 

## **2)  send**

```c++
send(socket, buffer, buffer length, option flag);
```
send를 호출하면 송신 버퍼에 메시지를 넣으며, 이를 전송하는 것은 TCP가 진행한다. option flag는 TCP 헤더 옵션을 지정하는 것으로, 만약 MSG_OOB를 지정하면 수신 버퍼 대신 별도의 저장 공간에 메시지를 보낸다. 이때 약 1byte의 간단한 플래그만 보낼 수 있으며 잘 쓰이지 않는다. block 소켓은 버퍼가 부족할 경우 block이 걸리고, 비워졌을 때 send 된다. 반면 non-block은 넣을 수 있는 만큼만 넣고, 넣은 크기를 반환한다. 송신 버퍼는 매우 크고 가변적이기 때문에 버퍼가 부족할 일은 많지 않다.

## **3)  receive**

```c++
recv(socket, buffer, buffer length, option flag);
```

recv를 호출하면 수신 버퍼에 데이터가 있을 때 가져오게 되며, 실제로 수신하는 것은 TCP가 진행한다. 일단 1byte라도 있으면 받으며 한번에 최대 buffer length만큼 받을 수 있다. 평상시엔 받은 byte 수를, 소켓이 종료 절차를 밟은 경우 0을, 에러 시 에러 코드를 반환한다. 수신 버퍼에 데이터가 없으면 return 하지 않고 block 걸린다. 이때, TCP는 메시지가 뭉쳐지거나 조각나서 오기 때문에 이를 위한 커스텀 헤더를 만들거나 규격화를 해야 된다.

<br/>

# **2. Packet fragmentation**

## **1) MSS**

TCP는 패킷이 L4의 MSS, Maximum Segment Size 보다 클 경우 조각을 낸다. MSS는 페이로드 기준 1460로, L3 MTU(1500)에서 TCP 헤더를 뺀 크기이다. 이는 규격이 되는 단위로 현재 사용되는 모든 라우터에 통용되며, L2도 마찬가지로 점보 프레임이라는 규격을 갖는다. 이는 IP 계층에서 조각을 내지 않도록 하기 위함이며, TCP는 절대 MTU가 넘는 크기로 L3에 패킷을 전달하지 않는다. 즉, 조각을 내는 이유는 L3 때문이지만 조각을 내는 주체는 L4이다.

만약 TCP에서 조각을 내지 않으면 IP에서 MTU에 맞춰 조각을 내는데, 이 경우 맨 앞 패킷에만 TCP 헤더가 붙기 때문에 하나가 유실되면 모든 패킷을 폐기해야 한다. 반면 조각 내기를 TCP가 수행하여 TCP 헤더를 모든 조각에 붙인다면 하나가 유실되어도 이를 L4에서 처리할 수 있게 된다. 물론 TCP의 순서 보장 때문에 유실된 패킷만 재전송할 순 없지만, 전체를 폐기하는 대신 유실된 패킷 이후부터 재전송할 것이며 이것이 훨씬 효율적인 방법이다.

참고로 netsh interface ipv4 show subinterfaces 이걸로 MTU 크기를 조회할 수 있다. 2023년 기준 현재는 모두 1500으로 통일되어 있으나, loopback은 약 42억이다. 내가 나와 통신할 때는 L2까지 가지 않고 메모리를 통하기 때문으로, 이때는 패킷도 조각나지 않는다. 이런 이유로 TCP에서는 큰 데이터를 보내도 유실률이 높아지지 않는다. 반면 UDP에서는 L3에서 조각을 내므로 하나라도 없으면 다 폐기된다. 따라서 유실률을 낮추기 위해 L7에서 조각낸 뒤에 보내는 것이 좋다. 

## **2) 윈도우 사이즈**

송수신 버퍼를 윈도우, 버퍼의 남은 공간 즉 현재 송신할 수 있는 데이터 크기를 윈도우 사이즈라고 한다. 수신측은 TCP 헤더 윈도우 사이즈로 송신측에 이를 통지한다. recv로 데이터를 가져오면 그 만큼 공간이 확보 되며, 메시지 전송 시 이 정보를 갱신한다. 또, 윈도우 사이즈가 0일 때 주기적으로 0임을 상대에게 통지하다가 여유가 생길 경우 그 크기를 통지한다. 이 경우들을 제외하면 윈도우 사이즈가 변해도 매번 알리지는 않으며 대신 송신 측에서 데이터를 보낼 때마다 차감 계산을 한다. 

이러한 윈도우 사이즈 역시 TCP 계층에서 데이터가 조각 나는 사유 중 하나이다. 송신 측에서 1000byte 보내고 싶으나 수신 측이 500만 받을 수 있는 경우 500byte만 전송해야 하므로 데이터가 조각난다. 물론 정상적인 상황이라면 윈도우 사이즈 때문에 잘리는 일은 잘 생기지 않는다. 또 하나의 원인은 수신측 버퍼이다. 수신할 때도 버퍼를 두는데 받아오는 버퍼 크기가 3000이고 TCP 버퍼에 5000이 있다면 2000은 남기고 가져오게 된다. 

이 방식대로면 내 윈도우 사이즈가 64KB임을 통지했을 때 상대가 나에게 64KB를 보냈으면 내가 ack를 보내주어야만 다음 단계로 넘어갈 수 있을 것이다. 따라서 만약 핑이 200ms라면 1초에 5번씩 64KB밖에 보낼 수 없는 셈이 된다. 1초에 얼마나 보낼 수 있느냐가 네트워크 속도가 되는데, 이는 지금의 인터넷 속도를 따를 수 없는 설계이다. 따라서 버퍼 크기의 경우 아주 옛날에는 8KB, 비교적 최근에는 64KB였으며 현재는 n00KB~1GB까지 확장되었다. 

문제는 윈도우 사이즈가 16인 기존 헤더를 바꿀 수가 없다. 따라서 맨 처음 3-Way Handshake 단계에서 TCP 헤더 window scale에 몇 승을 할지에 대한 값을 함께 보낸다. 예를 들어 이 값이 8이라면 이는 윈도우 사이즈 값에 8bit를 shift 하겠다는 것을 의미한다. 윈도우 사이즈와 Window Scale 값을 받으면 송신 측에서 이를 계산하여 사용한다. 실제로는 OS 차원에서 전송되는 크기보다 더 여유분을 두고 있다.

과거에는 64KB였기에 NonPaged pool을 사용해도 문제가 되지 않았지만 현재 저 크기를 다 사용한다면 문제가 될 것이다. 따라서 내부 버퍼는 필요할 때마다 늘리는 구조로 사용되지, 처음부터 윈도우 사이즈만큼 확보하지는 않는다. 실제로 receive를 하지 않고 버퍼에 쌓이도록 테스트 해보면 Nonpaged pool이 버퍼가 늘어나는 것에 비례하여 늘어나는 것을 볼 수 있다. 이것을 제대로 처리하지 않으면 Nonpaged pool 예외가 발생하므로 주의해야 한다. 