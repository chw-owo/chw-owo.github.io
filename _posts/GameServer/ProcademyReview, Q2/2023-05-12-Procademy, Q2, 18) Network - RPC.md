---
title: Procademy, Q2, 18) Network - RPC (1)
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. RPC 개요**

![RPC](https://github.com/chw-owo/chw-owo.github.io/assets/96677719/8de752d6-49ff-478f-a581-624e2857707a)

Remote Procedure Call. 원격지에 있는 함수를 호출시키는 것을 의미한다. 

위 그림에서 선 아래의 과정을 함수로 랩핑하여 보이지 않도록 한 것이다. 내부적으로는 동일한 네트워크 함수 호출 과정을 거치지만, 이를 엔진 차원에서 랩핑하여 네트워크 프로그래밍을 잘 몰라도 간편하게 사용할 수 있도록 만든 것이다. RPC에서는 서버에서 함수를 호출 하면 클라에서도 해당 함수를 호출해주며, 저 함수들을 만드는 과정 역시 자동화한다. 편의성을 위해 랩핑을 많이 하므로 호출하는 입장에서는 편리하지만 성능에는 좋지 않다. 게임 서버 개발자로 회사에 들어갈 경우 클라쪽 네트워크 코드도 담당하게 되는데 이때 RPC 형태로 만들어서 전달하는 게 일반적이다. 

구글의 프로토콜 버퍼가 대표적인 오픈 소스 RPC로, 정해진 규격대로 스크립트를 짜서 컴파일하면 언어에 상관 없이 프론트(클라)와 백(서버)가 서로를 호출할 수 있도록 만들어준다. 그러나 이는 Stateless 서버를 대상으로 만들어진 것이므로 Stateful 서버에는 적합하지 않다. 따라서 실제로는 직렬화 버퍼까지만 제공하는 아파치의 플랫 버퍼를 사용하거나 혹은 프로토콜 버퍼에서 직렬화 버퍼만 사용하고 네트워크 단은 직접 제작한다. 혹은 Stateful 서버를 위한 RPC인 프라우드넷을 사용하기도 한다. 


# **2. RPC의 구조**

프라우드넷의 경우 스크립트를 정의한 txt 파일을 IDLCompiler.exe에 넣으면 이에 대한 소스코드(cpp)를 만들어준다. 즉, 함수 이름과 인자를 적으면 파싱을 통해 소스코드를 뱉어내는 일종의 컴파일러인 셈이다. 이후 그 소스 코드를 솔루션에 포함시켜서 컴파일하면, 컨텐츠 단에서 함수 이름을 호출하는 것만으로도 네트워크 작업을 처리할 수 있게 된다. 이때 비주얼 스튜디오 - 프로젝트 속성 - 빌드 이벤트 - 명령줄 에 어떤 경로의 어떤 실행 파일을 실행할지 파라미터와 함께 입력하면 빌드 전후 혹은 링크 전에 실행해준다. 이를 통해 위 작업을 자동화할 수 있으며, 빌드 후 복사본을 자동으로 백업할 때도 사용된다. 

기존에는 메시지 단위로 구조체를 만들고, 구조체를 통해 메시지를 세팅해서 사용했다면 RPC에서는 대신 직렬화 버퍼를 사용한다. 구조체를 이용해 데이터를 순서대로 배치하는 대신 런타임에서 직접 Serializing 하여 버퍼에 넣는 것이다. 이러한 직렬화 버퍼는 RPC가 아니어도 가변 길이 메시지를 사용하는 상황에서 유리하다. 이때 모든 게 개수가 정해진 고정 파라미터 형태로 나와야 한다. 만약 플레이어 목록을 던지고 싶다면 List< Player >를 인자로 넣고 직렬화 버퍼에 List< Player >를 넣는 코드를 전역으로 오버로딩 해주어야 한다. 

송신부를 프록시(Proxy), 수신부를 스텁(Stub)이라고 부른다. 송신측(Proxy)에서는 만들어진 함수를 그대로 호출하면 송신이 된다. 반면 수신측(Stub)의 경우 함수에서 콘텐츠 처리가 이루어져야 하는 동시에, 이미 완성된 네트워크 코드에서 stub에서 만든 코드를 직접 호출해주어야 한다. 또, stub.cpp는 RPC 구조 안에서는 자동 생성된 중간 과정 파일에 해당하므로 사용자가 직접 수정할 수 없다. 따라서 수신측의 함수는 추상 함수로 만들어진다. 이 추상 함수들을 가상함수로 받아서 콘텐츠 코드를 채우고 해당 클래스를 Setter를 통해 네트워크 코드로 전달해주면, RPC가 switch-case를 통해 해당 함수들을 호출해주는 것이다. 
