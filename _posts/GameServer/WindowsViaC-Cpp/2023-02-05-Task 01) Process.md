---
title: Task 01) Process
categories: WindowsViaC-Cpp
tags: 
toc: true
toc_sticky: true
---

이 포스트는 <제프리 리처의 Windows via C/C++ (한빛미디어)> 내용을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 프로세스**

## **01) 프로세스란?**

프로세스는 일반적으로 수행 중인 프로그램의 인스턴스라고 정의하며 두개의 컴포넌트로 구성된다. 하나는 프로세스를 관리하는 목적으로 운영체제가 사용하는 커널 오브젝트이다. 시스템은 프로세스에 대한 각종 통계 정보를 프로세스 커널 오브젝트에 저장하기도 한다. 또 하나는 실행 모듈, DDL의 코드, 데이터 등을 수용하는 주소 공간이다. 이러한 주소 공간은 스레드 스택, 힙 할당과 같은 동적 메모리 할당에 사용되는 공간도 포함한다. 
                                                              
## **02) 프로세스와 스레드**

프로세스는 자력으로 수행될 수 없으며, 프로세스가 무언가를 수행하기 위해서는 반드시 프로세스 컨텍스트 내에서 수행되는 스레드가 있어야 한다. 따라서 프로세스는 최소 한 개의 스레드를 가져야 하며, 프로세스가 생성되면 시스템이 자동으로 주 스레드라 부르는 첫번째 스레드를 생성해준다. 만약 모든 스레드가 종료된다면 시스템은 자동으로 프로세스와 프로세스의 주소 공간을 파괴한다. 

하나의 프로세스는 다수의 스레드를 가질 수 있으며, 스레드는 동시에 코드를 수행한다. 이를 위해 각 스레드는 자신만의 CPU 레지스터 집합과 스택을 가져야 한다. 또, 동시 수행을 위해 운영체제는 CPU 시간을 각 스레드에 조금씩 나누어주어야 한다. 각 스레드는 라운드 로빈 방식으로 주어지는 단위 시간 만큼 수행되며, 다수의 CPU를 가진 머신에서 스레드에 CPU 시간을 나눠주는 알고리즘은 상당히 복잡하다. 이에 대해 이해하고 어플리케이션의 알고리즘을 적절히 변경하는 것은 이러한 머신의 장점을 최대한 살리기 위해 유효한 방법이다. 

<br/>

# **2.윈도우 어플리케이션 작성**

## **01) GUI vs CUI**

윈도우는 두가지 형태의 어플리케이션을 지원하는데 하나는 그래픽 유저 인터페이스(GUI) 기반의 어플리케이션이며 하나는 콘솔 유저 인터페이스(CUI) 기반의 어플리케이션이다. 윈도우와 함께 배포되는 메모장, 계산기, 워드 패드 등의 보조 프로그램은 대부분 GUI 어플에 해당한다. CUI 어플은 텍스트를 기반으로 하며 명령프롬프트가 전형적인 CUI 어플에 해당한다. 

Visual Studio를 사용하면 프로젝트 속성 - 링크에서 링커 스위치를 설정할 수 있는데 "/SUBSYSTEM:CONSOLE"을 설정하면 CUI 기반으로 "/SUBSYSTEM:WINDOWS"를 설정하면 GUI 기반으로 서브시스템 값을 가져온다. 

## **02) 진입점 함수**

윈도우 어플리케이션은 수행을 시작할 진입점 함수를 반드시 가져야 한다. C/C++ 환경에서는 두가지 형태의 진입점 함수를 사용할 수 있으며, 어떤 함수를 사용할지는 유니코드 문자열의 사용 여부에 달려있다. 

```c++
int WINAPI _tWinMain(
    HINSTANCE hInstanceExe,
    HINSTANCE, 
    PTSTR pszCmdLine,
    int nCmdShow
);
```
```c++
int _tmain(
    int argc,
    TCHAR *argv[],
    TCHAR *envp[]
);
```
운영체제는 우리가 만든 진입점 함수를 직접 호출하는 대신 C/C++ 런타임에 의해 구현된 C/C++ 런타임 시작 함수를 호출한다. 이는 링크 시 -entry: command-line option을 통해 설정된다. 런타임 시작 함수는 런타임 라이브러리에 대한 초기화 및 전역, 정적 오브젝트를 생성하는 역할을 수행한 후 진입점 함수를 호출한다. 

각 진입점 함수 별 런타임 시작 함수는 아래와 같다. 

|어플리케이션|진입점 함수|런타임 시작 함수|
|-----------|----------|---------------|
|ANSI, GUI| _tWinMain(WinMain)|WinMainCRTStartup|
|UNICODE, GUI| _tWinMain(wWinMain)|wWinMainCRTStartup|
|ANSI, CUI| _tmain(main)|mainCRTStartup|
|UNICODE, CUI|  _tmain(wmain)|wmainCRTStartup|

"/SUBSYSTEM:WINDOWS"가 설정되어 있다면 Winmain, wWinMain을 찾게 되고 이 진입점 함수가 존재하지 않을 경우 unresolvec external symbol 에러를 반환한다. 반대의 경우도 동일하게 동작한다. 만약 "/SUBSYSTEM" 링커 스위치를 제거한 경우 진입점 함수를 바탕으로 어플리케이션에 적합한 설정 값을 찾아내 실행한다. 

## **03) Process Instance Handle**

모든 실행 파일과 DLL 파일은 프로세스의 메모리 공간 상에 로드될 때 고유의 인스턴스 핸들을 할당 받는다. 이러한 인스턴스 핸들은 WinMain의 첫번째 매개변수 hInstanceExe를 통해 전달되어 리소스를 로드할 때 주로 사용된다. 예를 들어 LoadIcon 함수를 보면 첫번째 인자로 hInstance를 받는데 여기서 이 인스턴스 핸들이 사용된다. 

플랫폼 SDK 문서를 살펴보면 간혹 HMODULE 형 인자를 요구하는 함수들이 있다. 16bit 윈도우에서는 HMODULE, HINSTANCE가 구분되는 자료형이었으나 현재는 혼용해서 사용되는 완전히 동일한 자료형이므로 hInstance와 동일하게 사용하면 된다. 예를 들어 GetModuleFileName 함수를 보면 첫번째 인자로 hInstModule을 받는데 여기에서도 이 인스턴스 핸들을 사용한다.

## **04) GetModuleHandle**

hInstanceExe은 시스템이 프로세스의 메모리 주소 공간 상에 실행 파일을 로드할 시작 메모리 주소룰 가리킨다. 이 시작 주소는 링커에 의해 결정되며, 서로 다른 링커는 서로 다른 기본 시작 주소를 가질 수 있다. GetModuleHandle 함수를 사용하면 실행 파일이나 DLL 파일이 프로세스의 메모리 공간 상 어디에 로드되어 있는지 가리키는 핸들/시작 주소를 반환한다. 

```c++
HMODULE GetModuleHandle(PCTSTR pszModule);
```

인자로 프로세스에 로드되어 있는 실행 파일 혹은 DLL 파일의 이름을 '\0'으로 끝나는 문자열로 전달하면, 해당 파일이 로드된 시작 주소를 반환한다. 만약 시스템이 해당 파일을 찾을 수 없다면 NULL을 반환한다. 이때 매개변수로 NULL을 전달할 경우 현재 수행 중인 실행 파일의 시작 주소를 반환한다. 

이 함수가 DLL 내에서 호출되면 어떤 모듈에 포함되어 수행 중인지 알아내기 위해 두가지 방법을 사용할 수 있다. 첫째는 링커에 의해 정의되는 가상변수 __ImageBase가 현재 수행 중인 모듈의 시작 주소를 가리키고 있다는 사실을 활용하는 것이다. 두번째는 GetModuleHandleEx 함수를 호출하는 것이다. 첫번째 매개변수로 GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS를, 두번째 매개변수로 현재 수행 중인 함수의 주소를, 마지막 매개변수로 반환 받을 변수를 지정하면 된다. 

GetModuleHandle에는 중요한 두 가지 특성이 있다. 첫째로, 이 함수는 자신을 호출한 프로세스의 주소 공간만을 확인하며 다른 프로세스의 주소 공간에 로드된 것은 확인하지 못한다. 둘째로, NULL 값을 전달하게 되면 프로세스 주소 공간에 로드 된 실행 파일 시작 주소를 반환한다. 이는 GetModuleHandle를 DLL내에서 호출한 경우에도 마찬가지이다. 

## **05) Prev Instance Handle**

C/C++ 런타임 시작 코드는 항상 hPrevInstance 매개변수로 NULL을 전달한다. 이 매개변수는 16bit 윈도우에서 사용되었으며 포팅 편의를 위해 wWinMain에 남아있을 뿐 참조할 필요가 없기 때문이다. 

## **06) Process Command line**

새로운 프로세스가 생성되면 프로세스에 command line, 명령행이 전달된다. 명령행은 비어있는 경우가 거의 없는데, 새 프로세스를 생성하기 위해서는 최소한 명령행의 첫번째 토큰으로 실행파일의 이름을 전달하기 때문이다. 하지만 '\0'으로만 이루어지니 빈 문자열을 명령행으로 전달 받는 경우도 간옥 있다. 

C 런타임 시작 코드가 GUI 어플을 수행하는 경우 먼저 GetCommandLine 윈도우 함수를 이용하여 프로세스의 명령행 전체를 가져오며, 이 중 실행 파일명을 제외한 나머지 부분을 WinMain 함수의 pszCmdLine 매개변수로 전달한다. 이 매개변수가 가리키는 메모리 버퍼에 값을 쓸 수도 있지만 오버플로우의 위험이 있으므로 되도록 이 영역은 읽기 전용으로 냅두고, 값을 수정할 때는 해당 버퍼를 새 버퍼에 복사한 후 복사된 버퍼를 변경하는 것이 권장된다. 

GetCommandLine 함수를 호출하면 프로세스 명령행 전체를 가리키는 포인터를 획득할 수 있따. 이 함수는 실행파일의 전체 경로명을 포함하는 전체 명령행의 내용을 담고 있는 버퍼의 포인터를 반환하며, 여러번 호출하여도 항상 동일한 버퍼의 주소를 반환한다. 만일 이 내용을 변경하면 최초 전달되었던 명령행 정보를 알 수 없게 되므로 읽기 전용으로 다루어야 한다. 

## **07) Process Environment Variable**

모든 프로세스는 자신과 연관된 환경 블록을 갖는다. 환경 블록은 프로세스의 주소 공간에 할당된 메모리 블록을 의미하며 이 공간은 다음과 같은 형태의 일련의 문자열을 포함한다. 

```
=::=:\ ...
VarName1 = VarValue1\0
VarName2 = VarValue2\0
VarName3 = VarValue3\0 
...
VarNameX = VarValueX\0
\0
```

환경 블록에 접근하는 방법은 두가지가 있다. 첫번째는, 전체 환경 블록을 얻기 위해 GetEnvironmentStrings 함수를 호출한 뒤 "="를 기준으로 파싱하는 것이다. 반환된 메모리 블록을 더 이상 사용하지 않을 것이라면 FreeEnvironmentStrings를 호출해주어야 한다. 

두번째 방법은 CUI 어플리케이션에서만 활용 가능한 방법으로 _tmain 진입점 함수의 매개변수로 전달되는 TCHAR *env[]를 사용하는 것이다. env는 문자열을 가리키는 포인터의 배열로 구성되어 있으며, 각각의 포인터가 "이름=값" 형태의 문자열을 가리킨다. 그리고 마지막 문자열 다음에는 NULL 포인터가 나타난다. env를 통해 환경 변수들이 전달되기 이전에 =로 시작하는 문자열들이 제거되기 때문에 따로 처리해줄 필요가 없다. 

일반적으로 자식 프로세스는 부모 프로세스의 환경 변수 집합을 상속한다. 또, 부모 프로세스에서 어떤 환경 변수를 자식에게 상속할지 제어할 수도 있다. 상속으로 환경 변수가 전달될 경우, 이는 환경 블록을 공유하는 방식이 아니라 새롭게 값을 복사, 전달하는 방식으로 이루어진다. 따라서 이후 자식 프로세스가 환경 블록을 수정하여도 부모 프로세스의 환경 블록에는 영향이 가지 않는다. 

사용자는 제어판의 시스템을 통해 환경 변수를 추가, 삭제, 변경할 수 있다. 환경변수를 설정할 때는 "="가 이름과 값의 구분자 역할을 하므로 환경변수의 이름 혹은 값에 "="가 포함되면 안된다. 또, "=" 전후의 공백 문자열도 유의미한 값으로 비교의 대상이 되기 때문에 주의해야 한다. 

환경변수를 이용하는 어플리케이션에서 사용할 수 있는 유용한 함수들이 몇가지 있다. 첫번째는 GetEnvironmentVariable 함수이다. 인자로 알고 싶은 환경 변수의 이름과, 값을 저장할 버퍼 포인터를 전달하면 해당 환경변수의 값을 알 수 있다. 두번째는 ExpandEnvironmentStrings 함수이다. GetEnvironmentVariable에서와 동일하게 값을 전달하면 대체 가능 문자열을 변경하여 반환해준다. 마지막으로 SetEnvironmentVariable 함수를 이용해 환경 변수를 추가, 삭제, 변경할 수 있다. 

## **08) Process Error Mode**

각 프로세스는 심각한 에러가 발생했을 때, SetErrorMode 함수를 호출하여 시스템이 이러한 에러들을 어떻게 처리하면 좋을지 알려줄 수 있다. 해당 함수의 플래그는 아래와 같다. 

|플래그|설명|
|------|---|
|SEM_FAILCRITICALERRORS| 시스템이 크리티컬 에러 처리기 메시지 박스를 출력하지 않도록 하고, 발생한 에러를 호출한 프로세스에 전달한다.|
|SEM_NOGPFAULTERRORBOX| 시스템이 일반 보호 실패 메시지 박스를 출력하지 않도록 한다. 이 플래그는 디버깅 어플리케이션이 일반 보호 실패 자체에 대한 예외 처리기를 가지고 있는 경우에 한해 사용하는 것이 권장된다. |
|SEM_NOOPENFILEERRORBOX| 시스템이 파일 관련 실패 메시지 박스를 출력하지 않도록 한다.|
|SEM_NOALIGNMENTFAULTEXCEPT|시스템이 자동으로 메모리 정렬 실패를 수정하고, 어플리케이션에게는 실패 사실을 알리지 않는다. x86, x64 프로세서에서는 영향을 주지 않는 플래그이다. |

기본적으로 자식 프로세스는 부모 프로세스의 에러 모드 플래그를 상속한다. 그러나 자식 프로세스는 이와 같이 설정되었다는 것을 전달받지 못하기 때문에 의도하지 않게 메시지를 전달받지 못하고 종료될 수도 있다. 이를 막기 위해 CreateProcess 호출 시 CREATE_DEFAULT_ERROR_MODE 플래그를 지정하여 자식 프로세스의 에러 모드를 기본값으로 설정할 수 있다. 

## **09) Current Drive & Directory**

파일의 전체 경로가 제공되지 않을 경우 많은 윈도우 함수들은 파일과 디렉토리를 현재 드라이브의 현재 디렉토리에서 찾는다. 시스템은 내부적으로 프로세스의 현재 드라이브와 디렉터리를 저장해두며, 이러한 정보가 프로세스 단위로 유지되기 때문이다. 이 특성 때문에 특정 스레드가 현재 드라이브, 디렉토리를 바꾸게 되면 동일 프로세스 내 모든 스레드에게 영향을 끼치게 된다. 

시스템은 프로세스의 현재 드라이브와 디렉토리는 저장해두지만, 모든 드라이브의 현재 디렉토리를 저장하지는 않는다. 그러나 운영체제는 다수의 드라이브에 대해 현재 디렉토리를 처리할 수 있는 기능을 제공하며, 이를 위해 프로세스의 환경 변수가 사용된다. 예를 들어 프로세스는 아래와 같은 두개의 환경 변수 값을 가질 수 있다. 

```
=C:=C:\Utility\Bin
=D:=D:\Program Files
```

프로세스의 현재 드라이브와 디렉토리를 얻을때는 GetCurrentDirectory 함수를 호출하며, 설정할 때는 SetCurrentDirectory 함수를 호출한다. 

함수 호출 시 현재 드라이브가 아닌 드라이브 문자를 전달하게 되면, 시스템은 프로세스의 환경 변수 블록에서 지정된 문자를 찾는다. 만약 이러한 변수가 존재하면 시스템은 이 값을 지정된 드라이브의 현재 디렉토리로 간주하며, 없을 경우 지정된 드라이브의 루트 디렉토리를 현재 디렉토리로 선택한다. 

부모 프로세스가 현재 디렉토리 정보를 자식 프로세스에게 전달하기 위해 환경 블록을 생성하여도, 자식 프로세스의 환경 블록에 디렉토리 정보가 자동으로 상속되지는 않는다. 자식 프로세스는 모든 드라이브의 루트 디렉토리를 현재 디렉토리로 간주한다. 만약 자식에게 현재 디렉토리 정보를 전달하고 싶다면, 드라이브 문자를 이름으로 하는 환경 변수를 생성하여 환경 블록에 추가해야 한다. 이때, 현재 디렉토리 정보를 얻기 위해 GetFullPathName 함수를 호출할 수 있다. 

## **10) System version**

Window API의 GetVersion 함수를 이용하면 사용하는 윈도우 버전을 확인할 수 있다. 그러나 이 함수의 경우, 버전 정보가 뒤집혀서 반환이 되는 특징이 있어 권장되지 않는다. 

GetVersionEx 를 사용하면 OSVERSIONONFOEX 구조체를 통해 보다 읽기 쉽게 버전 정보를 가져올 수 있다. MSDN의 시스템 버전 획득 문서에서 해당 구조체의 각 멤버를 어떻게 사용해야 하는지에 대해 예제 코드를 제공하고 있다. 

윈도우 비스타부터는 VerifyVersionInfo 함수를 이용할 수 있다. 이를 이용하면 현재 수행 중인 시스템 버전과 어플리케이션이 요구하는 버전을 손쉽게 비교할 수 있다. 여기서도 OSVERSIONONFOEX 구조체가 사용되며 OSVERSIONONFOEX 구조체를 세팅한 뒤 해당 함수의 인자로 전달하면 일치할 경우 TRUE를, 일치하지 않을 경우 FALSE를 반환한다.

<br/>

# **3. CreateProcess 함수**

## **01) 개요**

```c++
BOOL CreateProcess (
    PCTSTR               pszApplicationName,
    PTSTR                pszCommandLine,
    PSECURITY_ATTRIBUTES psaProcess,
    PSECURITY_ATTRIBUTES psaThread,
    BOOL                 bInheritHandles,
    DWORD                fdwCreate,
    PVOID                pvEnvironment,
    PCTSTR               pszCurDir,
    PSTARTUPINFO         psiStartInfo,
    PPROCESS_INFORMATION ppiProcInfo
);
```

스레드가 CreateProcess를 호출하면 시스템은 Usage Count가 1인 프로세스 커널 오브젝트를 생성한다. 프로세스 커널 오브젝트가 프로세스 자체를 의미하는 것은 아니며, 운영체제가 프로세스를 관리하기 위한 데이터 구조체를 의미한다. 

프로세스 커널 오브젝트가 생성되고 나면, 시스템은 새로운 프로세스를 위한 가상 주소 공간을 생성하고 실행 파일의 코드, 데이터, DLL 파일들을 해당 주소 공간에 로드한다. 그 후 새로 생성된 프로세스의 주 스레드를 위한 스레드 커널 오브젝트 (Usage Count 1)를 생성한다. 그러면 주 스레드는 링커에 의해 진입점으로 지정된 C/C++ 런타임 시작 코드를 실행하고, 이 시작 코드는 main 함수를 호출하게 된다. 

이때, CreateProcess가 TRUE를 반환하는 시점은 시스템이 성공적으로 프로세스와 주 스레들르 생성한 직후이다. 따라서 새로 생성된 프로세스가 초기화에 성공했는지, 필요한 DLL을 제대로 로드 했는지 등에 대해 부모 프로세스는 알 수 없다. 

## **02) **pszApplicationName**

pszApplicationName는 대체로 NULL로 지정하나 간혹 pszApplicationName로 실행 파일명을 전달할 수 있다. pszApplicationName로 파일명을 지정하는 경우 파일명의 확장자를 .exe로 가정하지 않기 때문에 반드시 확장자를 포함해야 한다. 또, 이 경우에 파일이 현재 디렉토리에 존재하지 않으면 별도의 검색을 거치지 않고 실패를 반환한다. 이는 윈도우의 POSIX 서브 시스템을 지원하도록 하기 위해 포함된 매개변수로, 대부분의 경우 pszCommandLine의 첫번째 인자로 실행파일 명을 전달한다. 

## **03) pszCommandLine**

pszCommandLine를 이용하면 CreateProcess가 새로운 프로세스를 생성하기 위해 필요한 추가 정보를 제공할 수 있다. 이때 전달되는 문자열의 첫 토큰은 실행하려는 프로그램의 파일명으로 간주되며 확장자가 없을 경우 .exe라 가정한다. 이때 pszCommandLine는 PTSTR, 즉 CreateProcess 함수 내에서 변경될 수 있는 형태로 전달되어야 한다. CreateProcess는 내부적으로 해당 명령행 문자열에 변경 작업을 수행한 뒤, 반환 직전에 원래 값으로 돌려놓는다. 

+) 재밌는 것은, 비스타에서 ANSI 버전의 CreateProcess를 호출할 경우 예외가 발생하지 않는데 이는 유니코드로의 변경을 위해 문자열 복사가 내부적으로 이루어지기 때문이다. 

생성할 프로세스의 파일명이 전체 경로를 포함하는 경우 전체경로를 이용하나, 그게 아닐 경우 실행 파일을 찾기 위해 다음과 같이 순차적으로 검색한다. 

**1.** 생성할 프로세스의 실행 파일명에 포함된 디렉토리

**2.** 생성할 프로세스의 현재 디렉토리

**3.** 윈도우 시스템 디렉토리. 즉 GetSystemDirectory가 반환하는 System32 서브폴더

**4.** 윈도우 디렉토리

**5.** PATH 환경 변수에 포함된 디렉토리들

간혹 pszApplicationName로 파일명을 지정하고 또 pszCommandLine를 통해 새로운 프로세스를 위한 명령행 문자열을 전달할 수도 있다. 

## **04) psaProcess, psaThread, bInheritHandle**

새로운 프로세스를 생성하기 위해서 시스템은 프로세스 커널 오브젝트와 스레드 커널 오브젝트를 생성한다. 이들은 모두 커널 오브젝트이므로 부모 프로세스에서 각각에 대해 보안 특성을 지정해주어야 한다. 만약 기본 Security descriptor를 사용하고 싶다면 각 매개변수를 NULL로 지정하면 된다. 그렇지 않다면 SECURITY_ATTRIBUTES 구조체를 통해 보안 권한을 설정할 수 있다. 

bInheritHandle에 TRUE를 전달하면 부모 프로세스가 접근 가능한 커널 오브젝트를 자식 프로세스에서도 사용가능하도록 설정할 수 있다. SECURITY_ATTRIBUTES로 상속 가능하게 설정해도 이 매개변수기 FALSE라면 상속이 불가능하다.  

## **05) fdwCreate**

fdwCreate 매개변수는 새로운 프로세스를 어떻게 생성할지를 결정하게 된다. 여러개의 플래그 값을 비트 OR 연산으로 결합해서 전달할 수 있으며, 사용 가능한 플래그는 다음과 같다. 

**DEBUG_PROCESS**: 현 프로세스가 자식 프로세스와 자식의 자식 프로세스를 디버깅 할 수 있게 된다. 

**DEBUG_ONLY_THIS_PROCESS**: 현 프로세스가 자식 프로세스를 디버깅 할 수 있게 된다. 

**CREATE_SUSPENDED**: 프로세스 생성 후 주 스레드를 정지 상태로 만든다. 이를 통해 자식 프로세스 주소 공간 내 메모리 및 주 스레드의 우선 순위 등을 변경할 수 있게 된다. ResumeThread 함수를 통해 정지 상태를 해제할 수 있다. 

**DETACHED_PROCESS**: CUI 기반 자식 프로세스가 부모 프로세스의 콘솔 윈도우에 접근하지 못하도록 한다. 자식 프로세스가 콘솔 윈도우에 텍스트를 출력하기 위해서는 AllocConsole을 호출해야만 한다. 

**CREATE_NEW_CONSOLE**: 프로세스 생성 시 새 콘솔 윈도우를 생성한다. 

**CREATE_NO_WINDOW**: 콘솔 윈도우를 생성하지 않는다. 사용자 인터페이스가 필요 없는 CUI 어플을 수행할 때 사용한다. 

**CREATE_NEW_PROCESS_GROUP**: Ctrl + C, Ctrl + Break를 누르면 통보할 프로세스들의 목록을 수정한다. 

**CREATE_DEFAULT_ERROR_MODE**: 현 프로세스가 자식 프로세스에게 에러 모드를 상속하지 않는다. 

**CREATE_SEPERATE_WOW_VDM**: 16bit 윈도우 어플을 수행할 때 사용되며, 가상 도스 머신을 생성하고 그 안에서 16bit 윈도우 어플을 수행하도록 한다. 이를 사용하지 않을 경우 기본적으로 모든 16bit 어플은 하나의 VDM을 공유하게 되며, 윈도우 98에서는 이 플래그를 사용하여 동작 방식을 변경할 수 없다. 

**CREATE_SHARED_WOW_VDM**: 16bit 윈도우 어플을 수행할 때 사용되며, 16bit 윈도우 어플을 시스템이 공유하는 VDM 내에서 수행할 수 있게 한다. 

**CREAT_UNICODE_ENVIRONMENT**: 자식 프로세스 환경 블록 내에 유니코드 문자가 사용되도록 한다. 이를 사용하지 않을 경우 프로세스의 환경 블록은 기본적으로 ANSI 문자열을 사용한다. 

**CREATE_FORCEDOS**: MS-DOS 어플이 16bit OS/2 어플 내에서 수행되도록 한다. 

**CREATE_BREAKAWAY_FROM_JOB**: 잡 내의 프로세스가 해당 잡과 연결되지 않는 프로세스를 생성할 때 사용한다. 

**EXTENDED_STARTUPINFO_PRESENT**: psiStartInfo 매개변수를 통해 STARTUP_INFOEX를 전달할 것임을 운영체제에게 알려준다.

또, 아래와 같은 방식으로 우선순위 클래스를 지정할 수도 있으나 이는 권장되지 않으며 실제로 많이 사용되지도 않는다고 한다. 

**IDLE_PRIORITY_CLASS**: 유휴 상태

**BELOW_NORMAL_PRIORITY_CLASS**: 보통 이하

**NORMAL_PRIORITY_CLASS**: 보통

**ABOVE_NORMAL_PRIORITY_CLASS**: 보통 이상

**HIGH_PRIORITY_CLASS**: 높음

**REALTIME_PRIORITY_CLASS**: 실시간

이러한 우선순위 클래스를 지정하게 되면 새로 생성되는 프로세스 내의 스레드들이 다른 프로세스의 스레드들과 차별적으로 스케줄링 된다. 

## **06) pvEnvironment**

새 프로세스가 사용할 환경 변수 문자열을 포함하고 있는 메모리 블록의 포인터를 지정한다. 부모 프로세스의 환경 블록을 상속 받을 경우 이를 NULL로 지정하거나 GetEnvironmentStrings 함수의 반환값을 사용하면 된다. 이 함수는 현재 프로세스의 환경 블록 주소를 반환하며, 이로 인해 반환된 메모리 블록이 더 이상 필요하지 않을 경우 FreeEnvironmentStrings으로 메모리 블록을 삭제해주어야 한다. 

## **07) pszCurDir**

부모 프로세스가 자식 프로세스의 현재 드라이브와 디렉토리를 설정할 수 있도록 한다. NULL을 전달할 경우 자식을 생성한 어플의 현재 디렉토리로 설정되며, 이외의 값을 전달할 경우 '\0'으로 끝나는 문자열을 가리키는 포인터를 전달하면 된다. 

## **08) psiStartInfo**

STARTUPINFO나 STARTUPINFOEX 구조체를 가리키는 포인터를 지정한다. 이때 반드시 0으로 초기화 해주어야 쓰레기값으로 인한 오작동을 예방할 수 있다. 

STARTUPINFO 구조체 멤버 중 dwFlags를 통해 어떤 멤버가 유효한 정보이고 어떤 정보가 무시되어도 괜찮은지 전달할 수 있다. 지정할 수 있는 플래그는 아래와 같다. 

**STARTF_USESIZE**: dwXSize, dwYSize 멤버를 사용한다. 어플 윈도우의 넓이와 높이를 x, y 픽셀 단위로 지정한다. 

**STARTF_USESHOWWINDOW**: wShowWindow 멤버를 사용한다. 어플의 메인 윈도우가 어떻게 나타날지 지정한다. 

**STARTF_USEPOSITION**: dwX, dwY 멤버를 사용한다. 어플 윈도우의 좌상단 위치를 x, y 픽셀 단위로 지정할 수 있다. 

**STARTF_USECOUNTCHARS**: dwXCountChars, dwYCountChars 멤버를 사용한다. 자식 콘솔 윈도우의 넓이와 높이를 문자 단위로 지정한다. 

**STARTF_USEFILEATTRIBUTE**: dwFillAttribute 멤버를 사용한다. 자식 콘솔 윈도우의 글자색과 배경색을 지정한다.

**STARTF_USEFILLATTRIBUTE**: hStdInput, hStdOutput,  hStdError 멤버를 사용한다. 콘솔 입출력 버퍼를 가리키는 핸들을 지정한다. 

**STARTF_RUNFULLSCREEN**: x86 컴퓨터에서 콘솔 어플이 전체화면으로 시작되게 한다. 

**STARTF_FORCEONFEEDBACK**: 새 프로세스 초기화 과정을 관찰하여 적합한 커서 모양으로 변경한다. 

**STARTF_FORCEOFFFEEDBACK**: 커서를 어플 시작 커서로 변경하지 않는다. 

여기서 언급되지 않은 STARTUPINFO 구조체의 멤버는 아래와 같다. 

**cb**: STARTUPINFO 구조체의 바이트 크기를 담는다. STARTUPINFOEX와 같이 구조체를 확장하는 경우 버전 제어를 수행한다. 

**lpReserved, lpReserved2, cbReserved2**: 예약된 멤버로 NULL 혹은 0으로 초기화 해야 한다. 

**lpDesktop**: 어플이 수행될 데스크톱의 이름을 지정한다. NULL을 입력하면 현재 데스크톱과 연결된다. 

**lpTitle**: 콘솔 윈도우의 타이틀을 지정하며 NULL이면 실행 파일명으로 지정된다. 

## **09) ppiProcInfo**

PROCESS_INFORMATION 구조체를 가리키는 포인터로 지정되며 함수 호출에 앞서 반드시 메모리를 할당해야 한다. CreateProcess 함수는 반환 직전에 해당 구조체의 멤버를 초기화해준다. 구조체 구조는 아래와 같다. 

```c++
typedef struct _PROCESS_INFORMATION {

    HANDLE hProcess;
    HANDLE hThread;
    DWORD dwProcessId;
    DWORD dwThreadId;

} PROCESS_INFORMATION;
```

hProcess, hThread 멤버에 커널 오브젝트 핸들 값을 할당하게 된다. 프로세스 커널 오브젝트가 파괴되려면 프로세스가 종료되고, 부모 프로세스가 CloseHandle 을 호출하여 이 오브젝트 핸들을 삭제하여 사용 카운트를 0으로 만들어주어야 한다. 

<br/>

# **4. 프로세스의 종료 원인**

**1) 주 스레드의 진입점 함수 반환**

이 방법만이 유일하게 리소스의 적절한 해제를 보장하기 때문에, 프로세스가 종료되어야 할 때는 항상 이 방법을 통하도록 설계하는 것이 좋다. 주 스레드 진입점 함수가 반환될 경우 모든 자원을 적절히 해제한 후, 진입점 함수의 반환값을 인자로 ExitProcess를 호출하게 된다. 주 스레드 진입점 함수가 반환되면 아래와 같은 작업을 수행한다. 

**-** C++ 오브젝트들이 파괴자를 이용해 적절하게 파괴된다.

**-** 운영체제가 스레드 스택 용도로 할당한 메모리 공간을 적절하게 해제한다. 

**-** 시스템이 진입점 함수의 반환 값으로 프로세스 종료 코드를 설정한다. 

**-** 시스템이 프로세스 커널 오브젝트 Usage Count를 감소시킨다. 

<br/>

**2) 현 프로세스 내 스레드의 ExitProcess 함수 호출**

ExitProcess는 매개변수로 unsigned int 형식의 프로세스 종료 코드를 받고, 어떠한 값도 반환하지 않는다. ExitProcess, ExitThread를 호출하면 운영체제가 이에 대해 적절한 처리를 하기 때문에 해당 프로세스, 스레드와 관련된 모든 운영체제 리소스는 완벽하게 제거된다. 그러나 C/C++ 런타임이 관리하는 리소스에 대한 정리 작업은 수행되지 않는다. 


**3) 현 프로세스, 혹은 타 프로세스 내 스레드의 TerminateProcess 함수 호출**

다른 방법으로 프로세스를 종료시킬 수 없는 경우에 한해서만 TerminateProcess 함수를 호출해야 한다. 메모리 해제, 파일 닫기, Usage Count 감소, 사용자 및 GDI 오브젝트 제거 등 프로세스가 사용하던 리소스는 완벽하게 정리되지만, 메모리 정보를 디스크로 저장하는 것 등의 정리 작업은 이루어지지 않는다. 

또, TerminateProcess는 비동기 함수이므로 함수 반환 시점에 맞춰 종료될 것이라는 걸 보장할 수 없다. 종료되는 시점을 정확히 알고 싶다면 WaitForSingleObject와 같은 함수에 프로세스의 핸들을 전달하는 것이 좋다. 

**4) 프로세스 내 모든 스레드의 종료**

프로세스 내 모든 스레드가 종료되면 운영체제가 프로세스를 자동으로 종료하며, 프로세스의 종료 코드는 마지막으로 종료된 스레드의 종료 코드로 설정된다. 

# **5. 프로세스의 종료 과정**

**1)** 프로세스 내 남아있던 스레드가 종료된다.

**2)** 프로세스에 의해 할당된 모든 사용자 오브젝트, GDI 오브젝트가 삭제되고 Usage Count가 0이 된 모든 커널 오브젝트가 파괴된다. 

**3)** 프로세스의 종료 코드가 STILL_ACTIVE에서 ExitProcess, TerminateProcess 호출 시 설정한 종료 코드로 변경된다. 

**4)** 프로세스 커널 오브젝트의 상태가 시그널 상태로 변경되어 다른 스레드가 프로세스 종료 시까지 대기할 수 있게 된다.

**5)** 프로세스 커널 오브젝트의 Usage Count가 1 감소한다. 

<br/>

# **6. Child Process**

## **1) Child Process**

다른 코드 블록을 수행해야 하는 상황에서, 함수나 서브루틴을 호출하여 수행할 수 있다. 함수를 호출할 경우 수행 중이던 코드는 함수가 반환될 때까지 수행을 멈추게 된다. 대부분의 경우 이러한 싱글태스킹 동기화를 사용하게 된다. 

혹은 프로세스 내 새로운 스레드를 생성하여 해당 스레드가 작업을 수행하도록 코드 블록을 제공할 수도 있다. 이 역시 유용한 방법이지만 새로 생성한 스레드의 결과값을 확인하는 과정에서 동기화에 신경 써야 한다는 문제가 있다. 

복잡한 작업을 수행하거나, 주소 공간을 보호하기 위한 목적으로 자식 프로세스를 생성하여 처리할 수도 있다. 이때 부모 프로세스의 주소 공간에 있는 자료를 건네주기 위해 DDE, OLE, 파이프,메일슬롯 등을 활용할 수 있다. 

이때 자식 프로세스를 더 이상 참조하지 않고 독립적으로 동작시키고자 한다면
CloseHandle(pi.hThread), CloseHandle(pi.hProcess) 를 이용해 바로 Usage Count를 감소시켜주는 것이 안전하다.

<br/>

# **7. 관리자 권한**

## **1) 프로세스의 권한**

보완 권한과 관련된 레벨 특성은 반드시 관리자 권한으로 수행되어야 하는 requireAdministrator,  가능한 높은 권한으로 수행되어야 하는 highestAvailable, 자신을 호출한 어플과 동일한 권한으로 수행되는 asInvoker 세가지로 나뉜다.

상승된 권한으로 프로세스를 수행하고 싶은 경우 CreateProcess 대신 ShellExecuteEx 함수를 사용해야 한다. ShellExecuteEx 함수의 lpVerb 매개변수를 "runas"로 설정하고, lpFile에 상승된 권한으로 실행할 실행 파일의 경로를 지정하면 된다. 만약 사용자가 권한 상승 요청을 거절하면 ShellExecuteEx는 FALSE를 반환하고 GetLastError가 ERROR_CANCELLED를 반환한다. 


## **2) 현재 권한 정보 확인**

GetProcessElevation 함수는 권한 상승의 형태와 관리자 권한으로 수행되었는지 여부를 BOOL 값으로 반환한다. 이때 인자로 TOKEN_ELEVATION_TYPE 열거형을 받는데 그 값의 종류는 아래와 같다. 

**TokenElevationTypeDefault**: 프로세스가 기본 사용자 권한으로 수행되었거나 UAC 기능이 꺼져있다.

**TokenElevationTypeFull**: 프로세스가 성공적으로 권한 상승을 이뤘으며, 토큰은 필터된 토큰이 아니다.

**TokenElevationTypeLimited**: 프로세스가 필터된 토큰에 의해 제한된 권한으로 수행되었다. 

<br/>

