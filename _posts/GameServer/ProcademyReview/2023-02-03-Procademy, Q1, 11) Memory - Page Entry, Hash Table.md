---
title: Procademy, Q1, 11) Memory - Page Entry, Hash Table
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. VAD와 Page Entry**

VirtualAlloc을 사용하면 64kb 배수의 주소 지점을 집어서 할당하게 된다. 그보다 상세한 주소로 접근해서 예약, 해제하는 것은 불가능하다. 그리고 VAD 안에 저 64kb 배수의 주소가 VAD에 기록되어서 reserve 상태인지 commit 상태인지 알 수 있게 된다. 이때, reserve 되어 있던 영역을 commit으로 바꾸어도 그 당시에는 VAD에만 기록되지 page entry (가상 메모리 테이블)에는 기록되지 않는다. 참고로 VAD가 어떤 식으로 관리되고 있는지는 밝혀지지 않아서 명확하지 않고, 그저 64kb 혹은 128kb 단위로 관리된다는 것만 공개되어 있다. 

commit 된 영역이 page entry에 최초로 세팅되는 순간은 page fault가 발생했을 때이다. CPU의 CR3에서 어떤 주소에 접근하게 되면 우선 page entry에 접근한다. 거기에 해당 주소가 없으면 page fault를 발생하면서 VAD를 확인하게 된다. VAD에 해당 값이 없으면 예외를 발생시키고, 해당 값이 있다면 VAD에 있는 주소로 접근하여 page entry에 정보를 넣게 된다. 그리고 page entry에 정보를 넣는 시점에 물리 메모리 매핑도 이루어진다. 이렇게 지연된 작업 방식을 사용하는 이유는 commit된 자료를 page entry에 넣는데 드는 시간을 절약하기 위함이다.

<br/>

# **2. Page in / Page out**

그럼 page entry에서 주소가 사라지는 건 언제일까? 바로 page out이 발생하는 순간이다. page out은 사용하지 않는 메모리를 page entry에서 제거하고, 물리 메모리에서도 제거하는 것을 의미한다. page out 한 데이터는 어디로 갈까? 이는 폴더에서 보호된 운영 체제 파일 숨기기 (권장), 파일 확장명, 숨긴 항목을 해제하면 확인할 수 있다. 위 작업을 할 경우 pagefile.sys가 뜨는데 물리 메모리에 올라온 것 중에서 사용하지 않는 데이터를 여기에 저장하고, 필요할 때 불러온다. 이렇게 데이터를 디스크에 저장하는 과정을 page out, 이를 page entry로 불러오는 과정을 page in 이라고 부른다. 

설정 - 고급 시스템 설정 - 고급 - 성능 옵션 - 고급 - 가상 메모리 를 확인해보면 내 pagefile의 크기를 확인할 수 있다. 여기서 변경으로 들어가면 어떤 드라이브의 페이징 파일을 사용할지 결정할 수 있다. 만약 페이징 파일 없음 옵션을 사용할 경우 모든 메모리를 늘 물리 메모리에 상주시키고, 그 외의 것은 바로 지워버린다는 의미가 된다. 만약 32GB-64GB의 큰 RAM을 쓴다면 성능 향상을 위해 옵션을 꺼도 괜찮지만 용량이 없을 경우 윈도우 시스템에서 에러를 띄울 확률이 크다. 

page out은 page entry가 다 찼을 때가 아니라, 그냥 해당 메모리를 사용한 지 일정 시간이 지났을 때 자동으로 발생한다. page out이 발생하면 page entry에서 해당 영역을 invalid (최상위 비트의 수정) 상태로 만들고, pagefile.sys에서 어떤 위치에 저장해두었는지를 가리키게 된다. 정리하자면, page entry는 CPU에서 메모리를 가져올 때 접근할 수 있고,, 또 OS에서 page in/ page out을 할 때 접근할 수 있는 영역이다. 만약 CPU에서 접근했는데 해당 영역이 invalid이면 OS에서 page in을 실행시키고, 그 후 CPU가 해당 메모리를 가져오게 된다. 

물론 디스크에 정보를 저장하고 불러오는 것 자체가 알다시피 시간이 오래 걸리기 때문에 이 과정에서 성능 소모가 생긴다. 그래서 자주 쓰는 메모리의 경우 잘 page out 되지 않는다고 한다. 참고로 VirtualAlloc을 직접 하게 되면 page 를 Lock 해버릴 수 있는데, (멀티스레드에서의 Lock과 무관) 해당 영역은 page out 하지 않는다는 것을 의미한다. 이는 물리메모리의 70%까지만 가능하다. 

참고로 서버를 처음 구동할 땐 메모리 사용량이 많다가 한 이삼일 지나면 줄어들기도 하는데 이게 안쓰는 메모리는 page out 시키고, 작업 관리자의 메모리에서는 물리 메모리에 매핑된 크기만 보여주기 때문에 발생하는 현상이다. 또 메모리 누수 상황에서 메모리 사용량을 보게 되면 일직선으로 나타나지 않고 물결 치듯이 튕기는데 이것도 같은 이유로 발생하는 현상이다. 메모리가 부족해서 계속 page out, page in 을 반복하기 때문에 관찰되는 것이다. 

<br/>

# **3. 가상 메모리와 메모리 단편화**

가상 메모리를 사용하면 더 많은 메모리가 있는 것처럼 사용할 수 있다는 것과 더불어 메모리 단편화 측면에서도 장점을 취할 수 있다. 

단편화는 프로세스 안과 밖을 기준으로, 내부 단편화와 외부 단편화가 있다. 이때, 내부 단편화는 한 프로세스 내부에서 일어나는 것을 의미하며, 이는 규격화로 조금이나마 보완할 수 있다. 예를 들어 단위를 4byte로 규격화 한다면 빈 곳이 생겨도 그 곳을 재사용할 수 있게 되므로 내부 단편화로 인한 메모리 낭비가 줄어들게 된다. 외부 단편화는 물리 메모리 입장에서, 프레임에서 단편화가 생기는 것을 의미한다. 그리고 앞서 배웠던 페이징 시스템, 가상 메모리 시스템이 이러한 외부 단편화에 대한 보완책이 된다. page entry를 이용해서 물리 메모리 맵핑의 재배치가 계속 일어나기 때문에 가상 메모리 시스템에서는 물리 메모리의 단편화가 발생하지 않게 된다. 실제로 물리 메모리에서는 주소가 순서대로 맵핑되지 않고 뒤죽박죽이겠지만 그것이 문제가 되지 않는 것이다.

작업 관리자에서 작업 집합, 개인 작업 집합, 메모리 활용량 등을 확인해보면 디버그 모드일 때는 다 최대치 (약 400000K)로 잡혀있는 반면 릴리즈 모드에서는 커밋 크기만 최대치로 잡혀있고 개인 작업 집합, 메모리 활용량은 내가 사용하는 만큼 잡힌다. 동적 할당 반복 걸어두고 작업 관리자를 확인해보면 내가 만든 프로그램이 얼마나 메모리를 차지하고 있는지, 페이지 폴트가 몇차례 일어나는지 확인할 수 있다. 중요한 것은 이때 작업 집합만을 확인하면 메모리 누수가 없는지 알 수 없다. 커밋 크기가 꾸준히 증가할 때, 메모리 누수가 있다고 추측할 수 있다. 

참고로 서버를 개발할 때는 클라이언트 개발과는 다르게 런타임에 동적할당이 일어나는 것을 최소화 하는 게 좋다. 서버를 처음 켜는 순간에 공간을 다 확보해놓고 메모리 크기가 가능한 고정되도록 하는 것을 지향해야 한다. 만약 런타임 중 동적할당을 하더라도 재사용 가능한 형태로 구현해야지, 할당과 해제를 반복하는 것은 위험하기도 하고 성능 관점에서도 할당과 해제 자체에 시간 소요가 많이 들기 때문에 권장되지 않는다. 

<br/>

# **4. Hash Table**

Hash는 원래 요리에 있어서 잘게 다져서 다시 뭉쳐 굽는 기법을 의미한다. Hash Table과 Hash Potate 역시 같은 Hash를 사용하며, 잘게 다져서 일정한 규격으로 만든다는 의미에서 공통점을 갖는다. Hash Table에서 Hash는 일정한 공식을 통해 어떤 입력값을 넣던 범위, 용량, 크기 등 규격화된 결과를 출력해주는 것을 의미한다. 이때 동일한 입력값에는 늘 동일한 출력값이 나와야 하지만, 동일한 출력값이라고 늘 동일한 입력값을 갖는 것은 아니다. 암호화와의 차이점은 암호화는 복호화가 되어야 하는 반면 Hash는 오히려 복호화가 안되는 게 좋은 Hash 알고리즘이다. Hash는 1:1 맵핑이 아니기 때문에 다른 입력 값이 같은 출력값을 가질 수 있는데 이러한 상황을 Hash 충돌이라고 부른다. 

Key를 갖고 Value를 검색하기 쉽게 만든 구조를 Table이라고 하며, 이때 Key를 Hash한 값을 Value의 Index로 사용할 경우 이를 Hash Table이라고 한다. Hash Table의 장점은 Index가 몇개든 상관 없이 Hash(Key)를 Index로 사용하다보니 O(1)로 바로 찾을 수 있다는 것이다. 그러나 여러 입력값이 동일한 출력값을 가질 수도 있다는 Hash의 특징 때문에, Hash Table을 활용할 때는 어떻게 충돌을 줄일 것인가에 대한 고민이 필요하다. 일반적으로는 동일한 Index를 가지는 Value의 경우 링크드 리스트와 같은 형태로 해당 Index에 굴비처럼 줄줄이 묶어둔다. Hash Table에서는 일반적으로 % 연산을 사용하는데, 이때 나누는 수가 소수가 되면 충돌 가능성이 줄어든다고 한다. 

실무에서는 stl을 일반적으로 사용하지만, 간혹 C 컴파일러만 사용하는 팀도 존재한다. stl에 unordered_map이 Hash Table에 해당하는데 지원해주는 기능이 과하다보니 상황에 따라서는 성능을 위해 직접 구현해서 사용하는 것이 더 좋을 수도 있다. 이 외에도 공부 차원에서  Hash Table을 한번쯤 구현해보는 것은 좋은 훈련이 된다. 만약 기능에 따라 Hash Table을 사용했을 때 순회를 거쳐야 한다면 오히려 Balanced Tree를 사용하는 게 성능상 더 유리할 수도 있다. 

추가적으로, 기존에는 결과물이 32자로 나오는 md5 알고리즘을 주로 사용했으나 최근에는 64, 128자 단위의 알고리즘으로 넘어가는 곳이 많다고 한다. 그러나 32자라고 해도 key가 10자 이상만 넘어가도 걸리는 기간이 년 단위로 넘어가기 때문에, md5 알고리즘도 충분히 안전하다고 볼 수 있다.
