---
title: Byte Order, 바이트 오더
categories: OS
tags: 
toc: true
toc_sticky: true
---

### **📌 Byte Order, 바이트 오더**

![image](https://user-images.githubusercontent.com/96677719/210227587-baff2567-c3e4-4a42-bc79-332d58372235.png)

![image](https://user-images.githubusercontent.com/96677719/210228322-eb41de90-9842-4f31-83ec-0e5abb599fa7.png)

이 두 사진은 어셈블리어로 메모리에 값을 넣은 예시이다. 자세히 보면 분명히 변수에 오름차순의 숫자값을 넣었으나, 메모리에는 변수의 크기 단위만큼 끊어서, 적었던 것의 반대 순서로 값이 들어가있음을 볼 수 있다. 
```
0x1234, 0x5678 => 0x5678, 0x1234

0x12, 0x34, 0x56, 0x78 => 0x78, 0x56, 0x34, 0x12
```
이처럼 컴퓨터 메모리에 바이트가 저장되는 순서를 Byte Order, 바이트 오더라고 부르며 이는 크게 빅 엔디안, 리틀 엔디안으로 나뉜다. 이때 엔디안, Endianness이라는 단어는 메모리와 같은 1차원 공간에 여러개의 연속된 대상을 배열하는 방법을 의미한다. 

![image](https://user-images.githubusercontent.com/96677719/210232150-0baf7cba-1eba-4626-b8a5-c8bf8bbe4328.png)

x64-86을 사용하는 컴퓨터는 대부분 리틀 엔디안을 사용하며, 모토로라 프로세스나 일부 네트워크 통신에서는 빅 엔디안을 사용한다. 

<br/>

### **📌 빅 엔디안** 

![image](https://user-images.githubusercontent.com/96677719/210232777-d69dd780-0d2b-40c3-aba3-79c9a64de13a.png)

최상위 바이트(MSB)부터 차례로 값을 저장하는 방식. 즉, 사람이 숫자를 쓰는 방식처럼 상위 바이트(왼쪽에 있는 바이트)에 있는 값을 앞(낮은 메모리 주소)에서부터 순서대로 저장한다.

빅 엔디안은 사람이 숫자를 쓰는 방식과 같기 때문에 디버깅이 편하다는 장점이 있다. 또, 비교 연산 시, 최상위 바이트가 주소 위치에 있기 때문에 비교 연산에서 보다 빠르다. 반면, 저장된 값의 하위 바이트만을 사용할 때는 리틀 엔디안에 비해 상대적으로 느리다. 예를 들어 0x1122334455667788이라는 rax가 있을 때, 빅 엔디안으로 저장할 경우 시작 주소부터 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88 순으로 저장된다. 따라서 해당 레지스터의 ax를 구하고자 할 때, 빅 엔디안의 경우 하위 2 byte를 얻기 위해서는 변수 주소에 6 byte를 더한 위치로 이동해야 한다.  

### **📌 리틀 엔디안** 

![image](https://user-images.githubusercontent.com/96677719/210232789-436c7802-cbfc-4dcb-93a0-335d87bdca44.png)

최하위 바이트(LSB)부터 차례로 값을 저장하는 방식. 즉, 사람이 숫자를 쓰는 방식과 반대로 하위 바이트(오른쪽에 있는 바이트)에 있는 값을 앞(낮은 메모리 주소)에서부터 순서대로 저장한다.  

리틀 엔디안은 메모리에 저장된 값의 하위 바이트만 사용할 때 별도의 계산을 필요로 하지 않는다는 것이 장점이 있다. 예를 들어 0x1122334455667788이라는 rax가 있을 때, 리틀 엔디안으로 저장할 경우 시작 주소부터 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11 순으로 저장된다. 따라서 해당 레지스터의 ax를 구하고자 할 때, 시작 주소로부터 2 byte에 해당하는 0x88, 0x77 만 가져오면 된다. 반면 빅 엔디안이 되면 하위 2 byte를 얻기 위해 변수 주소에 6 byte를 더한 위치로 이동해야 한다. 

또 다른 장점으로는, 가산기가 덧셈을 하는 과정에서 LSB부터 자리 올림을 계산하게 되므로, 첫 바이트가 LSB인 리틀 엔디안일 때 가산기 설계가 더 단순해진다. 빅 엔디안에서는 마지막 바이트에서 첫번째 바이트로 역방향으로 진행하는 가산기를 설계해야 한다. 그러나 오늘 날의 프로세서는 여러개의 바이트를 동시에 읽어들여 덧셈을 수행하기 때문에 이것에는 사실상 차이가 없다. 

### **📌 그 외**

빅 엔디안, 리틀 엔디안 두 경우에 모두 속하지 않는 경우, 즉 한 방향으로 순서를 정하지 않는 경우는 미들 엔디안이라 부른다. 예를 들면 32비트 정수가 2바이트 단위로는 빅 엔디안이고 1바이트 단위로는 리틀 엔디안인 경우 등이 있다. 또, 둘을 모두 지원하는 경우도 존재한다. ARM, MIPS, IA-64 등은 둘 중 하나를 선택할 수 있도록 설계되어 있는데 이를 바이 엔디안이라 부른다.


### **출처**

[C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈] Part1: C++ 프로그래밍 입문, Rookiss

https://dev-ahn.tistory.com/60