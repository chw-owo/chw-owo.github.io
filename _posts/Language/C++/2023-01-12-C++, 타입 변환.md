---
title: C++, 타입 변환
categories: C++
tags: 
toc: true
toc_sticky: true
---
## **1. 변환의 유형**

**1) 변환 타입별 유형**

**- 값 타입 변환**
```c++
int a = 12345678;   // 2의 보수
float b = (float)a; // 부동 소수점
```
위 코드를 실행해보면 b에 1.23456e+08, 즉 12345678과 유사한 값이 들어간다. 그리고 메모리에 올라간 비트열이 변화한 것을 확인할 수 있다. 값 타입 변환은 이처럼 의미를 유지하기 위해서 원본 객체와 다른 비트열로 재구성하는 변환을 의미한다. 

<br/>

**- 참조 타입 변환**

```c++
int a = 12345678;   // 2의 보수
float b = (float&)a; // 부동 소수점
```
위 코드를 실행해보면 b에 12345678이 아니라 1.6536e-34라는 값이 들어간다. 그리고 메모리에 올라간 비트열이 변하지 않은 것을 확인할 수 있다. 참조 타입 변환은 이처럼 원본 객체의 비트열은 유지하되 그것을 읽는 방법을 바꾸는 변환을 의미한다. 포인터 타입 변환도 이와 동일한 규칙을 따른다.

<br/>

**2) 안전도별 유형**

**- 안전한 변환**

```c++
int a = 12345678;   
__int64 b = a; 
```

의미가 항상 100% 완전히 일치하는 경우를 의미한다. 예를 들면 char -> short, short -> int, int -> __int64와 같이 타입은 동일하되 크기만 더 큰 타입으로 이동하는 경우가 있다. 이러한 경우를 up-casting이라고 부른다. 

<br/>

**- 불안전한 변환**

```c++
int a = 123456789;   
short b = a;    // -13035
float c = a;    //1.23456e+08
```

의미가 항상 100% 완전히 일치한다고 보장하지 못하는 경우를 의미한다. 예를 들면 타입은 동일하되 크기만 더 작은 타입으로 이동하는 경우가 있다. 이러한 경우를 down-casting이라고 부른다. 또, 타입 자체가 달라지는 경우도 이러한 불안전한 변환에 포함된다.

<br/>

**3) 프로그래머의 의도별 유형**

**- 암시적 변환**
```c++
int a = 12345678;   
float b = a; 
```
이미 알려진 타입 변환 규칙에 따라서 컴파일러가 자동으로 타입 변환을 한다.

<br/>

**- 명시적 변환**

```c++
int a = 12345678;   
int* b = (int*)a; 
```
어떤 타입으로 변환할지에 대해 프로그래머가 명시해주면 컴파일러가 그에 따라 타입 변환을 한다. 위 코드의 경우에는 (int*) 로 명시해주지 않으면 에러가 난다. 위험한 경우라고 판단하는 것이다. 따라서 의도적인 변환임을 명시해주어야 한다. 

<br/>

## **2. 클래스 사이의 변환**

**1) 연관 없는 클래스 사이의 값 타입 변환**

```c++
class Knight
{
public:
    int _hp = 10;
};

class Dog
{
public:
    int _age = 1;
    int _cuteness = 2;
};

int main()
{
    Knight k;
    Dog d = (Dog)k;

    return 0;
}
```

위의 코드를 쳐보면 (Dog)k; 부분에 빨간줄이 생기면서 코드가 실행되지 않는다. 일반적으로는 연관 없는 클래스 사이의 값 타입 변환이 안되는 것이다. 

```c++
class Knight
{
public:
    int _hp = 10;
};

class Dog
{
public:
    // 타입 변환 생성자
    Dog(const Knight& knight)
    {
        _age = knight._hp;
    }

    // 타입 변환 연산자
    operator Knight()
    {
        return (Knight)(*this);
    }

public:
    int _age = 1;
    int cuteness = 2;
};

int main()
{
    // 타입 변환 생성자를 이용
    Knight k;
    Dog d = (Dog)k;

    // 타입 변환 연산자를 이용
    Knight k2 = dog;

    return 0;
}
```
그러나 반드시 필요한 상황이라면 위의 예시처럼 타입 변환 생성자 혹은 타입 변화 연산자를 이용해서 변환해줄 수 있다. 

<br/>

**2) 연관 없는 클래스 사이의 참조 타입 변환**

```c++
class Knight
{
public:
    int _hp = 10;
};

class Dog
{
public:
    int _age = 1;
    int _cuteness = 2;
};

int main()
{
    Knight k;
    Dog& d = (Dog&)k;

    return 0;
}
```

참조 타입 변환의 경우 별도의 연산자, 생성자를 만들지 않고도 바꿀 수 있다. 암시적 형변환은 불가능하지만 (Dog&)를 명시적으로 표시할 경우 가능하다. 이는 어셈블리 단계에서 포인터와 참조를 내부적으로 같은 것으로 해석하기 때문에 있는 일이다. 그러나 위의 예시에서 dog._cuteness를 하게 될 경우 건드리면 안되는 메모리를 건드는 위험한 일이 생길 수 있다. 

**3 ) 상속 관계 클래스 사이의 값 타입 변환**

```c++
class Dog
{
public:
    int _age = 1;
    int _cuteness = 2;
};

class Bulldog: public Dog
{
public:
    bool _french = true;
};

int main()
{
    Dog dog0;
    Bulldog bulldog0 = (Bulldog)dog0;   // Error!!

    Bulldog bulldog1;
    Dog dog1 = bulldog1;                // OK
    return 0;
}
```
부모 클래스를 자식 클래스로 바꾸는 것은 불가능하지만 자식 클래스를 부모 클래스로 바꾸는 것은 가능하다. 실제로도 부모 클래스에서 필요한 값을 자식 클래스는 상속을 통해 모두 갖고 있지만 그 역은 성립하지 않는다. 

<br/>

**4 ) 상속 관계 클래스 사이의 참조 타입 변환**


```c++
class Dog
{
public:
    int _age = 1;
    int _cuteness = 2;
};

class Bulldog: public Dog
{
public:
    bool _french = true;
};

int main()
{
    Dog dog0;
    Bulldog& bulldog0 = (Bulldog&)dog0; 

    Bulldog bulldog1;
    Dog& dog1 = bulldog1;            
    return 0;
}
```

부모 클래스를 자식 클래스로 바꾸는 경우에는 암시적으로는 불가능하고 (Bulldog&)를 명시적으로 표시할 경우에만 가능하다. 그러나 이런 변환은 잘못된 주소를 건드릴 수 있기 때문에 위험하다. 자식 클래스를 부모 클래스로 바꾸는 것은 암시적으로도 명시적으로도 가능하다. 자식 클래스는 부모 클래스와 비교했을 때 크기가 같거나 더 크기 때문에 상대적으로 안전하다고 판단하는 것이다.

<br/>

## **3. 포인터 타입 변환**

클래스 객체 포인터 간의 타입 변환 예시를 보자.

```c++
class Item
{
public:
    Item(int itemType) : _itemType(itemType) {  }

public:
    int _itemType = 0;
    int _itemDbId = 0;
};

enum ItemType { IT_WEAPON = 1, IT_ARMOR = 2 }

class Weapon: public Item
{
public:
    Weapon(): Item(IT_WEAPON){ }
public:
    int _damage;
};

class Armor: public Item
{
public:
    Armor(): Item(IT_ARMOR){ }
public:
    int _level;
};


int main()
{
    Item* inventory[20] = {};

    srand((unsigned int)time(nullptr));

    for(int i = 0; i < 20; i++)
    {
        int randValue = rand() % 2;
        switch(randValue)
        {
        case0:
            inventory[i] = new Weapon();
            break;

        case1:
            inventory[i] = new Armor();
            break;
        }
    }   
    return 0;
}
```
이는 아주 간단한 아이템 랜덤 생성 코드이다. new Weapon(), new Armor()로 Weapon, Armor를 동적 할당하여 그 포인터를 자연스럽게 부모 클래스 객체의 포인터인 Item 포인터 변수에 넣는 것을 확인할 수 있다. 위에서 봤듯이, 자식 클래스 객체 참조를 부모 클래스 객체 참조로 형변환하는 것은 비교적 안전하다. 참조나 포인터나 내부적으로는 동일하게 작동하기 때문에, 포인터에서도 마찬가지로 암시적 형변환이 가능한 것을 확인할 수 있다. 

반면 같은 맥락에서 부모 클래스 객체 포인터를 자식 클래스 객체 포인터로 형변환 하는 것은 위험할 수 있다. 따라서 이 경우에도 명시적 형변환만 가능하고 암시적 형변환은 불가능하다. 되도록이면 이러한 형변환은 위험하니 사용하지 않는 것이 좋지만, 하지만 부모 클래스 객체의 포인터를 자식 클래스 객체의 포인터로 형변환 해야 하는 일이 생기기도 한다. 그 예시는 아래와 같다. 

```c++
...
int main()
{
    Item* inventory[20] = {};

    srand((unsigned int)time(nullptr));

    for(int i = 0; i < 20; i++)
    {
        int randValue = rand() % 2;
        switch(randValue)
        {
        case0:
            inventory[i] = new Weapon();
            break;

        case1:
            inventory[i] = new Armor();
            break;
        }
    }   

    for(int i = 0; i < 20; i++)
    {
        Item* item = inventory[i];
        if (item == nullptr)
            continue;

        if(item -> _itemType == IT_WEAPON)
        {
            Weapon* weapon = (Weapon*)item;
        }
        else if(item -> _itemType == IT_ARMOR)
        {
            Armor* armor = (Armor*)item;
        }
    }  
    return 0;
}
```

이는 itemType 체크를 거쳐서, weapon이었던 item을 다시 weapon으로, armor였던 item을 다시 armor로 형변환 해주는 코드이다. 이처럼 변환 전후에 무슨 값이었고 무슨 크기였는지, 그것이 메모리를 침범하지는 않는지 명확히 확인할 수 있는 경우에는 명시적 형변환을 사용할 수 있다.  

이렇게 형변환을 거친 경우에는 동적 할당했던 변수를 다시 소멸시킬 때도 유의해야 한다. 

```c++
...
int main()
{
    Item* inventory[20] = {};

    srand((unsigned int)time(nullptr));

    for(int i = 0; i < 20; i++)
    {
        int randValue = rand() % 2;
        switch(randValue)
        {
        case0:
            inventory[i] = new Weapon();
            break;

        case1:
            inventory[i] = new Armor();
            break;
        }
    }   

    for(int i = 0; i < 20; i++)
    {
        Item* item = inventory[i];
        if (item == nullptr)
            continue;

        if(item -> _itemType == IT_WEAPON)
        {
            Weapon* weapon = (Weapon*)item;
        }
        else if(item -> _itemType == IT_ARMOR)
        {
            Armor* armor = (Armor*)item;
        }
    } 

    ...

    for(int i = 0; i < 20; i++)
    {
        Item* item = inventory[i];
        if (item == nullptr)
            continue;

        delete item;
    }  

    return 0;
}
```

위의 경우를 보면 할당할 때는 Weapon, Armor로 할당했지만 소멸시킬 때는 Item으로 소멸시키고 있다. 이때 확인해보면 Weapon, Armor의 소멸자는 호출되지 않고 Item의 소멸자만 호출된다. 이런 일이 누적되다보면 메모리 누수로 언젠가 크래쉬가 날 수 있다. 따라서 소멸시킬 때도 아래와 같이 처음 할당했을 때의 형태로 바꾸어 소멸시켜주어야 안전하다. 

```c++
    for(int i = 0; i < 20; i++)
    {
        Item* item = inventory[i];
        if (item == nullptr)
            continue;

        if(item -> _itemType == IT_WEAPON)
        {
            Weapon* weapon = (Weapon*)item;
            delete weapon;
        }
        else if(item -> _itemType == IT_ARMOR)
        {
            Armor* armor = (Armor*)item;
            delete armor;  
        }
    }  
```
그러나 매번 이런 과정을 거치는 것은 번거로운 일이다. 이를 대비하여 최상위 부모 클래스의 소멸자는 가상 함수로 만들어주는 것이 편하다. 최상위 부모 클래스만 가상 함수로 만들면 그의 자식 클래스들의 소멸자 역시 자동으로 가상 함수가 되기 때문에, 소멸 시에 실수로 메모리 누수가 생기는 일을 예방할 수 있다. 

```c++
class Item
{
public:
    Item(int itemType) : _itemType(itemType) {  }
    virtual ~Item() {}

public:
    int _itemType = 0;
    int _itemDbId = 0;
};

...

int main()
{
    ...
    for(int i = 0; i < 20; i++)
    {
        Item* item = inventory[i];
        if (item == nullptr)
            continue;

        delete item;
    }  
    return 0;
}
```

위와 같이 소멸자를 가상 함수로 만들어준다면, delete item 만으로도 자동으로 Weapon, Armor의 소멸자로 동적 바인딩을 해준다. 

<br/>

## **4. 캐스팅**



<br/>

## **출처**

[C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈] Part1: C++ 프로그래밍 입문, Rookiss
