---
title: Procademy, Q1, 24) Stateful, Stateless
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. Scale up, Scale out**

서버 확장을 해야 할 때 Scale up, Scale out 개념이 나온다. Scale up은 하드웨어의 사양을 향상시켜서 수직적으로 확장하는 것이며 Scale out은 서버의 개수를 늘려서 수평적으로 확장하는 것이다. 기본적으로는 확장성을 고려하여 Scale out 방식을 지향하는 것이 좋으며, Scale up은 Scale out이 불가능한 상황에서 시도해야 한다.  

웹 서비스와 같은 Stateless 서버는 Scale out을 선택할 수 있는 반면 Stateful 서버는 어쩔 수 없이 Scale up을 선택해야 하는 경우가 많다. Stateless 서버는 모든 데이터를 DB에 저장해두고 서버의 경우 코드의 작동만 일어나므로 Scale out이 되어도 문제가 없지만 Stateful 서버는 서버 자체에 데이터를 저장하고 그 데이터를 바탕으로 상호작용이 이루어지기 때문이다.

<br/>

# **2. Stateless**

Stateless는 클라에서 요청이 있을 때만 연결을 하고 서버에서 응답을 받으면 연결을 끊는 구조이다. 유저 간 상호작용이 적은 방치형 게임, 싱글 RPG 등에서 일반적으로 사용한다. 메모리 대신 DB에서 데이터를 불러오기 때문에 서버보다 DB에 더 부담이 간다. 레디스도 많이 쓰는데, mysql 등은 디스크에 데이터를 저장하는 반면 레디스는 메모리에 저장하므로 빠른 접근이 가능하기 때문이다. 

Stateless는 상대적으로 쉽게 scale out 할 수 있어서 c++ 대신 node.js 와 같은 스크립트 언어로 만드는 경우가 많다. 스크립트 언어는 프레임워크 위에서 프로그램이 돌기 때문에 서버가 꺼지는 일이 적으며 점검도 용이하다. 이때 초당 처리 수, Daily Active User 등을 지표로 삼으며, 서버 개발 유지 비용이 상대적으로 적기 때문에 가능하면 Stateless로 하는 게 낫다.  

Stateless 게임인 아이러브커피 같은 경우에는 매출이 올라가는 것이 실시간처럼 보이지만, 이는 클라 로직에서 가져온 데이터를 바탕으로 계산하여 보여주는 것이지 실시간으로 서버에서 데이터를 보내는 것이 아니다. 메뉴를 추가하거나 무언가를 구매하는 등의 행동을 할 때만 연결이 이어지고, 그렇게 DB에 저장된 값을 바탕으로 계산된 결과를 보여주기만 한다. 

크래시 오브 클랜과 같이 덱 형식이지만 전투에서 유저의 개입이 들어갈 수 있는 경우, 유저가 개입할 때 요청을 보내서 바뀐 결과를 응답하는 Stateless 방식과 전투에 한해서만 서버에서 실제 전투를 돌리는 Stateful 방식 두가지를 선택할 수 있다. 전투 알고리즘이 얼마나 복잡한지, 유저의 개입이 어떻게 영향을 미치는지에 따라 어느것을 택하는지가 달라진다. 

<br/>

# **3. Stateful**

Stateful은 연결을 계속 유지하면서 클라가 요청하지 않아도 서버에서 실시간으로 데이터를 보내준다. 메모리의 데이터를 기반으로 처리하다보니 DB 활용도가 떨어진다. 유저 간 실시간 상호작용이 주가 되는 게임에서 이 방식을 사용하는데, 실제로는 한 게임 안에서도 친구 추가, 커스터마이징 등은 stateless로, 전투는 stateful로 하는 등 혼용하여 구현한다. 

로그인할 때 DB에서 데이터를 불러오고 나면 이후엔 메모리에서만 로직을 처리하고 DB에는 쓰기만 한다. 이때, DB는 느리기 때문에 실시간으로 저장하는 대신 비동기적으로 처리를 한다. 사람이 적을 땐 1-2초, 많을 땐 분단위로 걸리게 되는데 이 때문에 롤백이라는 현상이 생긴다. 읽는 것은 기다리는 시간이 필요하므로 읽기 작업은 최소화 한다. 

옛날에는 동접자 처리가 불가능해서 채널을 늘렸다면, 최근에는 하드웨어가 좋아져서 오히려 DB를 더 잘 활용하기 위해서 수평적 분산을 한다. 서버와 DB의 연결 방식은 병렬이 아니라 직렬이기 때문에, DB와의 통신 속도는 느리지만 정작 DB의 CPU 사용률은 10%인 상황이 생길 수 있다. 그런 경우 하나의 DB를 활용하는 채널을 늘리면 낭비되는 것을 줄일 수 있다. 


