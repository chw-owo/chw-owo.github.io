---
title: Procademy, Q2, 26) Algorithm - 길찾기 개요
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 게임에서의 길찾기**

길을 찾는 가장 단순한 방법은 일단 목표지점 방향으로 나아간 뒤 벽에 막히면 다른 길을 탐색하는 것이다. 이때 갔던 장소를 또 가는 것을 막기 위해 왔던 경로를 기억해두었다가 그걸 바탕으로 최적화를 해야 한다. 또, 갔던 장소임을 어떻게 기억할 것인지, "장소"의 기준을 무엇으로 둘지 역시 고민해야 한다. 

길찾기의 가장 기본은 다익스트라 알고리즘이지만, 게임처럼 맵이 촘촘하고 넓은 경우 이를 그대로 적용하기 어렵다. 이것을 보완하기 위해 넓은 맵에 다익스트라를 적용할 수 있게끔 한 알고리즘이 A star 알고리즘이다. 지역을 격자로 조각내어 각 조각을 "장소", 즉 다익스트라의 노드처럼 파악하는 것이다. 

이때 다익스트라에서는 노드가 이미 정해져있는 반면 게임에서는 경로가 동적으로 변할 수 있고 또 경로의 수가 너무 많기 때문에, 모든 조각을 처음부터 노드로 등록해두는 대신 각 격자를 그때 그때 노드로 지정하여 길을 찾는다. A star 알고리즘은 이렇게 동적으로 변하는 맵에 대한 정보를 매 순간 노드처럼 파악하여 길을 찾는다.

이때 격자(이동 단위)의 모양과 크기는 A star 알고리즘과 상관이 없다. 기본 원리는 다익스트라와 같기 때문에 이동하는 경로를 기록할 수만 있다면, 삼각형이든 육각형이든 각 경로의 크기와 형태가 다르든 상관 없다. 사각형이 2D 맵을 표현하고 좌표를 계산하기에 가장 편하기 때문에 사각형 격자가 보편적으로 사용되는 것이다. 

<br/>

# **2. 상황 별 길찾기**

길을 찾아서 가다가 중간에 길이 막히는 경우 이를 인식하고 바로 우회하는 방법과 원래 예정대로 가다가 부딪히면 새로 길을 찾는 방법이 있다. 전자는 한칸씩 이동할 때마다 길찾기를 매번 돌려야 하기에 성능 저하가 생길 수 있지만, 맵이 동적으로 변하는 게임이라면 이 방법을 많이 사용한다. 이 경우 보통 최종 경로까지 계산하는 PathFind(curPos, destPos)를 매 프레임마다 돌리되, 정작 함수 자체는 다음 칸 하나만 반환하도록 구현한다. 

여러개의 유닛이 한번에 길찾기를 하는 경우, 각각의 유닛이 각자 길찾기 알고리즘을 돌린다면 서로를 장애물로 인식하는 바람에 경로가 꼬여서 지그재그로 움직이며 이동하게 된다. 따라서 스타의 경우 여러개의 유닛을 이동시키면 일렬로 모여서 한번에 이동한다. 이 경우 맨 앞의 유닛만 길찾기 알고리즘을 돌리고 뒤의 유닛들은 앞의 유닛을 따라가도록 하면 된다. 물론 중간에 유닛들이 끊겼을 때를 대비한 예외처리가 필요하다. 

만약 유닛들이 목적지를 둘러싸서 도달할 방법이 없다면, 길을 찾지 못하기 때문에 아예 출발을 못한다. 그러나 롤에서는 일단 가까이 간 다음 유닛들에 비비적거리는 것을 볼 수 있다. 이 경우 유닛과 맵의 레이어를 따로 만들고, 길찾기를 할 때는 맵만 반영하기 때문이다. 따라서 유닛에 의한 경로 막힘은 인식하지 못하고, 유닛은 부딪혔을 때 좌우로 비비는 방법으로 뚫게 된다. 게임 컨텐츠에 따라 비행이 있는 경우 등에는 레이어를 3-4개로 나누기도 한다. 

만약 갈 수 없는 지점을 목적지로 잡을 경우, 목적지로부터 원형으로 확대하면서 갈 수 있는 지점을 찾는다. 갈 수 있는 지점이 나오면 그 지점을 목적지로 길찾기 알고리즘을 실행한다. 또, A star는 출발지점 목적지점을 뒤바꾸면 걸리는 시간이 달라지기도 하기 때문에, 일정 시간까지 길찾기를 못하면 출발지점 목적지점을 뒤바꿔서 한번 더 시도해보기도 한다. 또, 가중치에 따라 시간이 달라지므로 맵의 특성에 맞게 정해야 한다. 

<br/>

# **3. MMORPG에서의 길찾기**

MMORPG에서는 대부분 이동 중인 유저는 길찾기, 충돌 처리 대상으로 두지 않고 정지한 유저만 고려한다. 이동 중인 유저까지 길찾기에 포함하면 길찾기를 서버에서 모두 처리한 뒤 클라에 통보하는 방식이 되어야 하기도 하고, 길찾기를 병렬로 두기도 어려워지기 때문이다. 물론 느슨한 동기화나 지연 처리로 해결할 수는 있지만 일반적으로 그렇게 하지 않는다. 간혹 충돌 처리는 하는 경우도 있는데 이 경우 충돌한 유저들이 서로 비비면서 지나간다. 

<br/>

# **4. 길찾기 최적화**

길찾기가 느린 이유는 그리드, 즉 길찾기에 쓰이는 각 노드가 촘촘하고 많기 때문이다. 그 노드들을 다 훑고 나서야 다른 길을 찾는데다가 매번 노드를 동적으로 생성하기 때문에 이에 비용이 많이 든다. 따라서 직선 거리로 갈 수 있는 곳까지 (즉 방향 전환이 필요한 코너까지) 한 노드로 판단하는 방법으로 최적화를 할 수 있다. A star 알고리즘은 격자를 한칸씩 계산하다 보니 시간이 오래 걸리는데 굳이 격자를 유닛과 같은 크기로 만들 이유는 없기 때문이다.

또, 큰 단위의 그리드로 먼저 이동하고 작은 단위의 그리드로 이동하는 방법으로 최적화를 할 수도 있다. 큰 단위로 구역을 나눈 후 다익스트라 알고리즘을 적용하는 것이다. 출발 지점과 목적 지점을 지정했을 때 다음 경로가 어디인지에 대한 테이블을 만들고, 이를 미리 저장해두었다가 길찾기가 필요할 때 불러오는 것이다. 이렇게 큰 단위의 이동을 미리 처리하고 구역 내의 길 찾기만 런타임에서 처리하면 비용을 훨씬 줄일 수 있다.

싱글 코어 시절에는 길찾기를 빠르게 해야 됐지만, 멀티 코어가 일반화된 요즘은 어떻게 길찾기를 빠르게 할지 고민하는 것보다 길찾기를 멀티스레드로 돌린 후 어떻게 병렬처리를 더 효율적으로 할지 고민하는 게 나을 수 있다. 또 고성능의 길찾기를 요구하는 전략 시뮬레이션 게임 역시 유행이 지났고, 최근에는 유니티, 언리얼 등에서 자동화된 길찾기 툴을 제공하기 때문에 클라에서 길찾기를 한 뒤 경로만 서버에 보내고, 서버는 갈 수 있는 영역인지만 체크하여 승인을 내리는 게 일반적인 형태가 되고 있다.

