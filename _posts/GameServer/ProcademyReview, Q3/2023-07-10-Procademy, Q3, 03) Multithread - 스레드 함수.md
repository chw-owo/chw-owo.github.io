---
title: Procademy, Q3, 03) Multithread - 스레드 함수
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 스레드의 라이프 사이클**

다른 스레드가 CreateThread 함수를 호출하면 스레드 커널 객체가 생성된다. 그럼 OS가 해당 스레드의 커널 객체를 초기화 하는데, 이때 스레드 스택 및 스레드 수행 상태를 저장할 문맥 구조 등을 생성한다. 생성 시 스레드는 수행 시작 지점, 즉 시작 프로시저에 해당하는 함수의 포인터를 얻는다. 이후 스레드는 스레드의 시작 프로시저에서 수행을 시작하며, 수행을 마치면 종료 코드와 함께 종료된다. 이 종료 코드는 스레드 커널 객체에 저장되고, 종료와 함께 스레드의 usage count가 감소한다. 이 값이 0이 되면 커널이 해당 스레드를 삭제한다. 만약 스레드의 핸들을 타 스레드가 갖고 있었다면 이걸로 스레드의 종료 코드를 확인할 수 있다.  

```c++
DWORD WINAPI ThreadStartFunc(LPVOID lpThreadParameter);
```

스레드 시작 프로시저가 되는 함수의 포인터는 THREAD_START_ROUTINE 형태의 함수여야 한다. 이는 스레드 생성 API에 의해 직접 호출되지 않고, 스레드에만 해당하는 데이터를 초기화해야 할 때 커널 내부 혹은 런타임 라이브러리 함수에 의해 간접 호출된다. 이 함수는 위의 원형을 지켜야 한다. 

<br/>

# **2. 윈도우 API 함수**

```c++
HANDLE CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    DWORD dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreateionFlags, 
    LPDWORD lpThreadId
);

void ExitThread(DWORD dwExitCode);
void TerminateThread(HANDLE hThread, DWORD dwExitCode);

DWORD SuspendThread(HANDLE hThread);
DWORD ResumeThread(HANDLE hThread);
```

위 함수들은 가장 기본적인 윈도우 스레드 생성/소멸 함수이다. CreateThread는 호출하는 프로세스 안에 새 스레드를 생성한다. 새 스레드는 자신의 스택과 레지스터 복사본을 가지며 OS에 의해 독립적으로 스케줄링 된다.

주 스레드를 제외한 모든 스레드는 시작 프로시저에서 리턴될 때 자동으로 ExitThread가 호출된다. 만약 임의의 시점에서 종료시키고 싶다면 ExitThread를 사용할 수 있다. 스레드를 종료해도 스레드 커널 객체는 usage count가 0이 되기 전까지 없어지지 않는다. 종료된 스레드 커널 객체는 객체의 상태가 signaled로 바뀌기 때문에 언제 종료됐는지 외부에서 판단할 수 있다. 

TerminateThread는 다른 스레드를 강제 종료 시킨다. 이 경우 시스템 객체를 닫고, 스레드 스택을 회수하고, DLL_THREAD_DETACH를 DLL에 넘기는 등의 정리 루틴이 이루어지지 않기 때문에 정상적인 상황에서는 사용해서는 안된다. 

SuspendThread는 스레드를 대기 상태로 만들 때 사용한다. 모든 스레드는 대기 카운트를 가지며, 이 값이 0보다 크면 스레드는 대기 상태가 되어 스케줄러가 해당 스레드에 CPU 시간을 할당하지 않게 된다. 플래그 대신 카운터를 사용하여 타 스레드에 의해 여러번 대기 상태로 둘 수 있다. 이 함수가 성공하면 해당 스레드의 이전 대기 카운트 값이 반환된다. 

대기 상태의 스레드는 스스로 자신을 수행하게 할 수 없으며, 다시 수행시킬 때는 타 스레드가 ResumeThread를 호출해야 한다. 이 함수를 호출하면 대기 카운트 값이 1씩 감소되며 이 값이 0이 되면 스레드가 수행을 재개한다. 스레드가 여전히 대기 상태면 1보다 큰 값을, 수행을 재개하면 1을 반환한다. 

스레드의 동작에 대해 외부에서 개입하는 것은 위험한 방법이기에 Suspend/Resume Thread는 잘 쓰이지 않는다. 디버깅 시 관찰하려는 문제가 나타나는 순간 스레드를 정지시키고 메모리 덤프를 남기기 위해 사용할 수는 있다. 특정 스레드에서 예외가 나도 그 스레드가 인터럽트를 통해 프로세스 종료 코드를 실행시키지 않는 이상 다른 스레드는 쭉 돌고 있기 때문에 문제 상황이 나타나도 다른 스레드가 순식간에 덮어써서 파악하기 어려운 상황이 생긴다. 그럴 때 활용할 수 있는 함수이나, 일반적인 사용법은 아니다. 

또 다른 스레드 정지 함수로는 Sleep이 있다. 정지가 아닌 컨텍스트 스위칭을 위해 Sleep(0)을 쓸 수도 있다. 멀티스레드 디버깅 시 작동 순서를 조절하여 경합을 일으키기 위해 Sleep(0)을 사용할 수도 있다.

C 런타임 라이브러리를 사용할 때 되도록 CreateThread 사용을 지양해야 한다. 이는 API 함수라 언어 입장에서는 스레드 생성 여부를 알 수 없으므로 스레드 생성도 C 함수를 사용하는 것을 권장한다. C의 일부 함수(strtok, rand)는 함수와 함수 사이에서 값을 유지하기 위해 TLS를 사용하는데, API 함수들을 사용할 경우 해당 영역의 정리 및 초기화를 적절하게 수행하지 못한다. 

TLS는 스레드 생성 시 바로 확보되는 것을 보장하지 않는다. 물론 접근 시 없으면 생성하는 예외 처리가 포함되어 있어서 사용 시 문제가 되지는 않는다. 반면 종료 시에는 문제가 된다. 정리할 시간을 충분히 주지 않기 때문에 사라진 스레드 내에 유지되고 있는 데이터가 있는 식으로 누수가 생긴다. C는 이를 위한 스레드 생성/종료 함수를 제공하며, 이것을 사용해야 올바른 정리 절차를 밟을 수 있다. 

<br/>

# **3. C 런타임 라이브러리 함수**

```c++
unsigned long _beginthread(
    void (__cdecl *start_address)(void*), 
    unsigned stack_size,
    void* arglist
    );
```

이는 CreateThread보다 간소화된 인자를 가진다. 이때 스레드 리턴 이전에 _endthread 함수가 스레드 핸들을 닫으면 타 스레드에서 해당 스레드의 종료 코드를 확인할 수 없다는 단점이 있다. 이 때문에 아래 함수를 사용하길 권장한다. 

```c++
unsigned long _beginthreadex(
    void* security,
    unsigned stack_size,
    void (__cdecl *start_address)(void*),
    void* arglist,
    unsigned initflag,
    unsigned* thraddr
    );

void _endthreadex(unsigned retval);
```

이는 CreateThread와 거의 유사한 인자를 가진다. 이때 ExitThread를 사용하면 스레드가 런타임 환경을 지원하기 위해 할당한 자원을 정리할 수 없다. 따라서 시작 함수에서 반환되지 않고 종료하는 경우에는 _endthreadex를 호출해야 한다. 

endthreadex는 스레드에 정리 작업을 하고 ExitThread를 호출한다. 이 경우 전역 객체에 대한 소멸자는 호출되지 않는다. 이때 ExitThread, endthreadex 모두 해당 스레드가 주 스레드인지 확인하지 않기 때문에 주 스레드에 대해 이를 호출할 경우 전역, 정적 변수에 대한 정리가 이루어지지 않는다. 만약 주 스레드에서 exit 하고 싶다면 C 언어의 exit를 호출한다. 이는 프로세스를 정리하는 것이기 때문에 전역, 정적 객체 소멸자가 호출된다. 다른 스레드에서 그 객체에 접근하고 있다면 문제가 생길 수 있다. 

이 방법으로 만들어진 스레드들은 스레드 별로 ptd를 갖는다. 이는 런타임 라이브러리가 안전한 멀티스레드 사용을 위해 만든 기능이다. 예를 들어 rand 타고 들어가보면 FlsGetValue가 있는데 여기서 F는 Fiber. Fiber Local Storage, Fiber를 사용하고 있지 않는다면 TLS와 같은 역할의 저장소이다. TLS는 OS 차원에서 제공하는 공간으로, C 런타임 라이브러리가 이를 이용해 스레드 별 저장 공간을 내부적으로 구현하고 있는 것이다. 종료 시 이런 언어가 만든 이런 공간에 대해서는 OS가 알지 못한다. 즉 _beginthreadex 함수를 쓰지 않으면 이로 인해 스레드 제거 시 마다 메모리 누수가 생긴다. 

이때 _endthreadex를 쓰지 않아도 함수가 반환되면 정리 작업이 보장된다. _beginthreadex 함수를 쓰고 콜 스택을 보면 실제로는 _beginthreadex 함수가 바로 스레드를 생성하는 것이 아니라 thread_start라는 함수를 통해 스레드를 만든다. thread_start를 보면 스레드 초기화 작업, 요청한 함수를 포인터로 전달, 작업 종료 시 _endthreadex를 호출의 절차를 거친다. 즉 _beginthreadex는 요청한 함수를 실행하는 스레드를 만드는 대신, 초기화-함수-정리를 실행하는 별도의 함수를 만들고 스레드가 해당 함수를 실행하도록 하는 것이다. 즉, 우리가 요청한 함수를 실행 함수로 쓰는 대신 언어 차원에서 래핑한 함수를 사용한다. 

컴파일러 입장에서 절차대로 정리해야 하는 것과 언어 입장에서 절차대로 정리해야 되는 것(ex 소멸자 호출)이 다소 다르다. endthreadex는 함수 호출이기 때문에 컴파일러 입장에서는 해당 코드를 실행할 뿐 소멸자 호출 여부까지 확인하지는 않는다. 반면 return으로 종료할 경우 컴파일러가 해당 스코프 내 객체의 소멸자를 정리 시점에서 호출해준다. 따라서 스택 내 객체의 소멸자까지 제대로 처리하기 위해서는 return으로 유도하는 방식을 사용해야 한다. 객체들이 연계될 경우 소멸자를 호출하지 않았을 때 예상하지 못한 문제가 생길 수 있다. 

예시로, vs 2013 debug에서는 stl은 컨테이너도 iter를 바라보며, 컨테이너 소멸자 호출 시 iter가 있으면 예외를 냈다. 지금은 예외를 내진 않지만 그럼에도 깔끔하게 관리하기를 권장한다. 참고로 한 스코프 내에 있는 경우 생성의 역순을 컴파일러가 보장한다. 

추가적으로 iter를 먼저 선언할 경우, Debug 빌드일 땐 iter가 list를 보고 있고 소멸자는 생성자의 역순으로 호출된다. list가 proxy 멤버에 iter에 대한 주소를 저장하고 있다가 list 소멸자에서 iter에 연결된 게 있다면 iter 주소로 이동해서 자기 자신 (list)를 바라보지 못하게 연결을 끊기 때문에 문제가 나지 않는다. Release 빌드일 땐 이 과정이 존재하지 않는다. 

<br/>

# **4. 스레드와 스레드 커널 객체**

스레드는 TCB 블럭에 의해 도는 실행 단위, 스레드 객체는 이에 접근하기 위해 존재하는 객체로 둘은 별도로 존재한다. 스레드 커널 객체는 usage count 2로 시작된다. 실제 스레드와 스레드 생성 시 반환되는 핸들, 총 두가지가 스레드 커널 객체를 보고 있기 때문이다. 여기서 바로 CloseHandle 하면 스레드 커널 객체의 usage count가 1이 된다. 보통 프로세스 종료 시점에 스레드도 종료될 것이므로 보통은 종료까지 책임지지 않기에 생성 직후 CloseHandle을 하는 경우가 많다. 

이때 핸들을 보관하다가 WaitForObject 함수로 종료를 확인한 뒤 프로세스를 종료할 수도 있다. 프로세스가 종료되면 main 스레드의 정리 코드를 실행하고, 이 정리 코드들이 다 실행되면 생성했던 스레드들을 파괴한다. 정리 코드에는 전역 객체 소멸자 호출 코드가 atexit에 등록되어 한번에 실행된다. 그 이후에도 스레드들은 계속 동작하는 상태인데, 만약 전역 객체 소멸자가 호출되었고 이후 스레드들이 싱글톤이나 전역 객체를 호출한다면 오작동이 생길 수 있다. 안전하게 종료하고 싶다면 핸들을 바탕으로 종료까지 책임지는 것이 좋다. 

멀티스레드 디버깅을 하다보면 gs 레지스터를 자주 보게된다. TCB는 커널 메모리에 생성되어 커널이 관리하는 것이라 사용자가 직접 접근할 수 없는 반면, TEB(Thread Environment Block)는 유저 메모리에 생성되기에 사용자가 접근할 수 있다. 이는 스레드 환경에 대한 정보 블록으로, TCB 하나 당 TEB 하나씩 생성되며 스택도 힙도 데이터도 아닌 메모리 공간에 있다. gs 레지스터가 이 주소를 가리키고 있으며, 이는 컨텍스트 스위칭 시 함께 교체된다. GetCurrentThreadId도 이를 바탕으로 값을 가져오므로 커널 전환 없이 mov eax 2줄로 Id를 얻어올 수 있다. 

GetCurrentThread가 현 스레드의 핸들을 얻어주는 것인데 실제로는 가상 핸들(-2, fffffffe) 을 반환한다. 자신 안에서만 유효하기 때문에 usage count가 증가하지 않으며 CloseHandle도 아무 동작을 하지 않는다. 실제 핸들을 얻고 싶다면 Duplicate Handle을 이용해야 한다. 
