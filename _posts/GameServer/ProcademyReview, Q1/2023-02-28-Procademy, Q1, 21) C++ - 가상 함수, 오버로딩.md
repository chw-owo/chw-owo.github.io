---
title: Procademy, Q1, 21) C++ - 가상 함수, 오버로딩
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 순수 가상함수**

## **1) 순수 가상함수**

CPlayer CEnemyA CEnemyB CBullet CItem…과 같이 여러 자료형을 가진 객체가 있을 때 이들을 하나의 함수로 일괄적으로 처리하고 싶은 상황이 생길 수 있다. 이때 만약 각 객체가 공통된 하나의 부모를 상속받고 있다면 아래와 같이 처리하여 해결할 수 있을 것이다. 

```
CBaseObject

CPlayer : public CBaseObject
CEnemyA : public CBaseObject
CEnemyB : public CBaseObject
CBullet : public CBaseObject
CItem : public CBaseObject

List <CBaseObject *> ObjectList;
```

만약 Update, Render를 가상함수로 만들어서 각각 자기 객체 타입에 맞는 Update와 Render를 실행할 수 있도록 하면 같은 타입의 객체들마다 Update, Render를 새로 돌리는 것보다 코드를 깔끔하게 할 수 있을 것이다. 이런 상황을 위해 사용되는 것이 순수 가상함수이다.

```c++
class IBaseObject
{
public:
	virtual void Update() = 0;
	virtual void Render() = 0;
private:
	int _x;
	int _y;
}
```
위처럼 virtual void Render() = 0; 형태로 선언할 경우 이는 순수 가상함수가 되며, 순수 가상 함수가 한개라도 있는 클래스는 인터페이스 클래스가 된다. 인터페이스 클래스는 독립적으로 객체를 만들거나 동작할 수 없으며 상속 용도로만 사용할 수 있다. 

하지만 컨텐츠를 구현할 때는 객체들 간의 상호작용이 너무 강하기 때문에 객체지향적으로 완벽하게 코드를 설계하는 것이 쉽지 않다. 그래서 절차지향이 오히려 유지보수 관점에서 좋다는 얘기도 하셨던 것. 반면 라이브러리, 프레임워크, 엔진 등은 컨텐츠 코드와 완전히 분리되어야 하기 때문에 이러한 순수 가상 함수를 적극적으로 사용하는 것이 좋다. 

클라이언트 쪽에서 특히 순수 가상함수와 인터페이스 클래스를 유용하게 사용할 수 있다. 사운드, 이펙트, UI의 글자 하나하나 객체로 만들어서 필요한 시점에 new로 생성하기만 하면 자동으로 Update 돌면서 재생해주는 구조로 만들면 객체를 따로 관리하는 것보다 편하게 관리할 수 있게 된다.

참고로 동적 할당에 대해서는 서버의 관점과 클라의 관점이 약간 다를 수 있다. 클라는 객체가 많으면 메모리 사용량이 많아지고 느려지기 때문에 new -delete를 상대적으로 더 많이 사용하는 반면 서버는 일관된 메모리 사용량을 선호하기 때문에 꼭 필요한 상황이 아니면 동적할당을 많이 사용하지 않는다. 

또, 순수 가상 함수에 정의를 만든 뒤, 자식이 이를 호출할 수 있다. 오버라이딩을 컴파일 에러를 통해 강제하는 것은 동일하며, 공통의 로직을 갖고 싶을 때 <부모 class 이름:: 함수 이름>과 같은 형태로 호출하기 위해 정의할 수 있다. 순수 가상 함수라는 개념에는 어긋나는 문법이라서 일반적으로 사용되는 형태는 아니다. 

**+)** 

만약 어떤 행동이 끝났을 때 멤버 함수 안에서 delete this로 지운다면 어떻게 될까? delete this 뒤에 바로 return 하거나, 이후에 멤버에 대한 접근이 없다면 동작할 때 문제가 생기지는 않는다. 물론 이후 멤버에 대한 접근이 있다면 nullptr 에러가 날 것이다. 따라서 안전하게 가기 위해서는 "나는 이제 죽었다"는 flag를 만들어서 나를 할당했던, 나를 관리하는 계층에 통지를 하고 그쪽에서 나의 delete를 처리하도록 하는 것이 좋다. 그 외의 상황에서도 되도록 동적 할당을 했던 계층에서 해제까지 처리할 수 있도록 설계하는 것을 권장한다. 

<br/>

## **2) _purecall**

C++ 예외 중 다소 독특한 예외로, 순수 가상 함수만 존재하는 상황이 됐을 때 그 함수를 호출시키면 발생한다. 아래와 같이 코드를 작성하면 생길 수 있다. 

```c++
class CTest
{
public: 

	CTest()
	{
		_pTest = this;
	}
	~CTest()
	{
		_pTest -> A();
	}
	virtual void A() = 0;
	CTest* _pTest;
};

class CTest2: public CTest
{
	void A()
	{
		// ...
	}
}

int main()
{
	CTest2 a;
}
```
CTest2로 객체를 만들어도CTest2가 존재하지 않는 순간이 존재한다. 생성자는 부모 - 자식 순으로, 소멸자는 자식 - 부모 순으로 호출되기 때문에 그 사이에는 부모의 객체만 존재하게 된다. 그 타이밍에 CTest에서 나 자신을 가리키게 한 뒤 CTest -> A를 호출한다면 그 시점에서는 해당 객체가 CTest2가 아닌 CTest로 존재하기 때문에 CTest의 A가 호출되면서 purecall 에러가 나게 된다. 위 상황에서 _pTest안에 자기 자신이 존재한다는 걸 소멸자에서는 알지 못하기 때문에 컴파일 상황에서는 에러가 나지 않지만 런타임 에러인 purecall 에러가 난다. 이를 통해 CTest도 사용하지 않을 뿐 가상함수 테이블이 존재함을 알 수 있다. 

이러한 실수는 핸들러를 가상함수로 만들 때 발생할 수 있다. 나중에 서버를 만들 게 되면 purecall을 비롯한 예외들을 모두 핸들링 할 수 있도록 할 예정이다. C/C++이 자동으로 예외를 처리해버리게 두는 것보다 우리가 예외를 어떻게 처리할지 직접 컨트롤 하는 게 더 안전하기 때문이다. 이때, C 스타일로 가면 함수 포인터를 건네주고 문제가 생길 때마다 CALLBACK 하는 방식으로 예외를 처리하는 게 일반적인데 Cpp 스타일로 갈 경우 지금 쓰인 순수가상함수를 적극적으로 사용하게 된다. 그러다보면 위와 같은 설계가 생길 수도 있는데 피해야 한다. 

<br/>

# **2. 오버로딩**

## **1) 연산자 오버로딩**

컨텐츠 로직을 짤 때 연산자 오버로딩을 사용하는 건 좋은 습관이 아니다. 자료구조를 만드는 게 아니라면 다른 사람이 봤을 때 의미를 파악하기 애매하기 때문에 지양하는 것이 좋다. 

참고로 후위 단항연산자의 경우 이전 값을 반환해야 하므로 사본을 만들었다가 return 하게 된다.

```c++
(pos++)++; // 컴파일 에러~
```
이때 후위 단항 연산자를 오버로딩 할 때는 위와 같은 후위 단항 연산자의 특성을 지켜주기 위해 const 함수로 만들어주는 게 좋다.

shift 연산자 오버로딩으로 cout cin을 오버로딩 할 수도 있다. 

**+)**

전역적으로 오버로딩이 가능한 연산자, 멤버 함수로만 연산자 오버로딩이 되는 연산자, 오버로딩이 불가능한 연산자들에 대해서 회사에서 가끔 문제로 나오기도 한다. 시험 보기전에 간단하게 암기해가는 것을 권장한다. 

```c++
CDATA a;
CDATA b = a;
CDATA c;
c = a + b;
if(a==b)
{
}
```
또, 위 코드를 문제없이 안전하게 동작시키기 위해 오버로딩 해야 하는 연산자들을 손코딩 하라는 문제가 나온 적도 있었다고 한다.

## **2) new 연산자 오버로딩**

new 연산자의 경우 메모리 공간의 할당하고, 생성자의 호출하고, 할당하고자 하는 자료형에 맞게 반환된 주소 값을 형변환하는 일을 모두 처리한다. 이 중 오버로딩으로 컨트롤 할 수 있는 부분은 메모리 공간을 할당하는 부분 뿐이다. 생성자/소멸자의 호출은 오버로딩으로 커버할 수 없다. 

```c++
void * operator new (size_t size)
{
void … = new ..
return ..
}
```
참고로 이렇게 해도 재귀에 빠지지는 않는다. new 오버로딩 함수 내의 new는 기존의 new처럼 사용되기 때문이다. 하지만 delete는 재귀에 빠지니 유의해서 오버로딩 해야 한다. 

이때 new 와 new[]를 각각 오버로딩 할 수 있다. 그러나 배열의 크기를 받아올 방법이 없다. 그래서 오버로딩 용도로 쓰라고 존재하는 게 char*와 int를 추가로 더 받는 new이다. 이를 이용하면 어떤 파일의 몇번째 라인에서 new를 호출했는지 알 수 있게 된다. 반면 delete는 그냥 delete를 사용할 예정. 동일하게 인자를 받는 delete도 존재하지만 이건 new 안에서 문제가 발생했을 때 호출할 목적으로 존재하는 것이지 오버로딩을 위해 존재하는 것은 아니다. 따라서 컴파일 에러를 안일으키기 위해서는 반드시 선언해주어야 하는데 그걸 사용자가 호출할 방법도 없고 호출할 일도 없다.

사실 new 연산자의 오버로딩은 일반적으로 많이 하는 작업은 아니지만, 잘 사용하면 생각보다 써먹을 곳이 많다. 메모리 사용량을 항목별로 모니터링 할 수 있도록 부가적인 처리를 할 수도 있고, 내가 만든 메모리 풀에서 돌아가게끔 수정할 수도 있다. 물론 클래스 타입 이름을 받지는 못하지만 객체들의 사이즈가 서로 다를 경우 사이즈만 받아도 유용한 정보가 된다. 오버로딩에 관한 코드를 단순히 넣고 빼는 것만으로도 코드의 수정 없이 모니터링 할 수 있다는 게 큰 장점이 된다.

나중에 예외처리하는 함수를 만들어서 예외가 생기면 메모리 덤프를 해버리는 코드를 작성하게 될 텐데, 여기서 문제는 메모리 덤프하는 함수가 디폴트 힙을 사용한다. 따라서 디폴트 힙에서 힙이 깨지는 예외가 나는 경우 디폴트 힙을 쓰는 다른 함수도 비정상적으로 동작하게 되면서, 메모리 덤프가 안된채로 꺼지는 상황이 생길 수 있다. 이처럼 디폴트 힙이 깨지면 window api 가 쓰는 모든 힙도 위험해진다. 이때 디폴트 힙은 사용하지 않고, new -delete를 오버로딩 해서 따로 만든 힙 안에서 오버로딩 하는 방법으로 이러한 상황을 보완할 수 있다. 

만약 10 byte 크기인 CTest가 있을 때 new CTest[10]; 이 된다면 이의 크기는 104가 될 것이고 배열 개수에 대한 정보가 담겨있는 맨 앞 주소값이 들어올 것이다. 그리고 사용자에게는 첫 포인터가 아니라 그 다음 위치, 즉 배열이 실제로 시작되는 주소를 반환할 것이다. 우리가 이렇게 오버로딩 한 상황에서 new[]로 만들고 delete 를 배열 형태가 아닌 일반 형태로 하게 되면 할당 받은 주소가 아니라 할당 받은 것의 다음 주소가 올 것이다. 즉, 아예 할당한적이 없는 값이 들어왔기 때문에 찾을 수가 없게 되는 것이다. 따라서 입력 받은 주소를 일단 탐색한 뒤, 포인터 크기만큼 뺀 주소가 실제로 있는지 확인해야 될 것이다. 힙 할당이 일어날 때는 힙 자체가 사용하는 데이터가 할당해주는 공간 앞뒤로 들어간다. 힙은 4 혹은 8바이트 간격으로 메모리를 건네줄 수 없기 때문에 이렇게 해도 우연한 문제가 생기지는 않는다. 

반대로 일반으로 선언한 것을 배열로 delete 하게 되면 어떻게 해야할까? 우리가 delete를 오버로딩 하게 되면 소멸자가 먼저 호출되고 delete가 호출 될 것이다. 하지만 오버로딩으로 소멸자 호출을 제어할 수는 없기 때문에 일반을 배열로 해제했을 때 생기는 예외는 우리가 핸들링 할 수 없게 된다. 만약 운좋게 소멸자에서 아무 멤버를 건드리지 않아서 문제가 생기지 않았다면 반대로 포인터 크기만큼 더해볼 수도 있긴 하겠지만 보통은 소멸자에서 예외가 터지게 된다. 
