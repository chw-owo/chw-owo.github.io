---
title: TCP-IP 03) 데이터 송수신
categories: 1%Network
tags: 
toc: true
toc_sticky: true
---

이 포스트는 Tsutomu tone의 <성공과 실패를 결정하는 1%의 네트워크 원리(성안당)> 내용을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 프로토콜 스택에 송신 의뢰**

connect에서 애플리케이션으로 제어가 돌아오면 애플리케이션이 write, read를 호출하여 데이터를 송수신한다. write를 호출하면 송신 데이터를 프로토콜 스택에 건네주고 스택이 송신 동작을 실행하는데, 이때 프로토콜 스택은 데이터 내용을 알지 못한다. write를 호출할 때 데이터 길이를 지정하면 스택은 해당 길이만큼 바이너리 데이터가 1byte씩 나열되어 있다는 것만 인식할 수 있다.

프로토콜 스택은 데이터를 바로 송신하는 대신 내부 송신용 버퍼 메모리 영역에 저장하고, 애플리케이션이 다음 데이터를 건네주길 기다린다. 송신을 의뢰할 때 건네주는 데이터 길이는 애플리케이션 종류, 방법에 따라 결정되는데, 이것들을 곧바로 보내면 작은 패킷을 많이 보내게 되며 네트워크 이용 효율이 저하될 수 있기 때문이다. 어느 정도까지 저장한 뒤 송신하는지는 OS 종류 및 버전에 따라 달라지는데 MTU와 타이밍을 바탕으로 판단한다. 

MTU(Maximum Transmission Unit)는 한 패킷으로 운반할 수 있는 데이터의 최대 크기로, 이더넷에서는 보통 1500byte가 된다. 이때 MTU는 IP 헤더, TCP 헤더, 데이터의 크기를 모두 합산한 크기이며, 헤더를 제외한 데이터의 최대 길이는 MSS (Maximum Segment Size)라고 한다. 애플리케이션에서 받은 데이터 크기가 MSS가 될 때까지 데이터를 저장하고 송신 동작을 하면 패킷이 불필요하게 잘게 나누어질 걱정을 하지 않아도 된다. 

이때 데이터 저장에 시간이 너무 오래 걸리면 송신이 지연되므로, 실제로는 프로토콜 스택 내부 타이머를 바탕으로 일정 시간 이상 경과하면 데이터가 다 모이지 않아도 패킷을 송신한다. MSS를 중시하면 네트워크 이용 효율이 높아지지만 송신 동작이 지연될 수 있으며, 타이밍을 중시하면 이용 효율이 떨어지므로 적당히 절충하여 사용해야 한다. 필요시 애플리케이션에서 송신 타이밍을 제어할 수 있다. 

HTTP 리퀘스트 메시지는 일반적으로 한개의 패킷에 충분히 들어가지만, 폼을 사용하여 긴 데이터를 보낼 경우 MSS를 초과하기도 한다. 긴 데이터의 경우엔 버퍼에 들어있는 데이터를 맨 앞부터 MSS에 맞게 분할해야 한다. 분할한 데이터에 IP 헤더, TCP 헤더를 부가하여 여러개의 패킷으로 송신하게 된다. 

<br/>

# **2. ACK 번호로 패킷 도착 확인**

TCP에는 송신한 패킷이 잘 도착했는지 확인하고 도착하지 않았으면 재송신하는 기능을 갖고 있다. TCP 담당 부분은 데이터가 통신 개시부터 몇번째 byte인지 계산하여, TCP 헤더에 시퀀스 번호라는 항목으로 기록한다. 수신 측에서는 패킷 길이에서 헤더 길이를 빼서 데이터 크기를 확인한다.이 둘을 바탕으로 데이터가 몇 byte부터 시작하여 몇 byte 분의 것인지 알 수 있으며, 수신측에서 패킷이 누락되었는지 확인할 수 있다. 

만약 누락이 없는 것을 확인하면 수신측은 데이터를 몇 byte까지 수신했는지 계산한 뒤 그 값을 TCP 헤더의 ACK 번호에 기록해 송신측에 알려준다. 이 동작을 수신 확인 응답이라 부르며, 송신측은 이걸 바탕으로 상대가 어디까지 수신했는지 파악한다.이때 악의적 공격을 막기 위해 시퀀스 번호는 랜덤값으로 시작하여 데이터 송수신 이전에 이 값을 먼저 알린다. SYN 제어 비트를 1로 하여 서버에 보낼 때 시퀀스 번호도 함께 설정하여 보낸다. 

이렇게 시퀀스 번호 초기값과 ACK 번호를 주고 받아야 본격적인 데이터 송수신 동작에 들어갈 수 있다. 먼저 클라 측에서 시퀀스 번호를 산출해 데이터와 함께 서버에 통지하고, 이것이 도착하면 서버측에서 초기값으로부터 ACK 번호를 산출해 클라에 반송한다. 이를 통해 초기값 통지가 무사히 도착했음을 확인한다. TCP의 송수신은 양방향이므로 반대로 동작할 땐 서버에서 시퀀스 번호를 산출, 통지하고, 클라에서 ACK 번호를 반송한다. 

TCP는 이러한 방법으로 상대가 데이터를 받았음을 확인하고, 확인할 때까지 송신한 패킷을 송신용 버퍼 메모리 영역에 보관해두었다가 ACK 번호가 돌아오지 않을 시 재송신한다. 이 방법을 사용하면 네트워크 어디에서 오류가 생기든 회복 조치를 취할 수 있기 때문에 LAN, 버퍼, 라우터 등은 별도의 회복 조치를 하지 않는다. 만약 여러차례 재송신해도 회복의 전망이 없다면 데이터 송신 동작을 강제 종료하고 애플리케이션에 오류를 통지한다. 

ACK 번호가 돌아오는 것을 기다리는 시간을 타임아웃 값이라고 한다. 네트워크가 혼잡하여 정체가 생기면 이 시간이 지연되므로 대기 시간을 길게 조정해야 아직 도착하지 않았는데 다시 재송신 하는 상황을 막을 수 있다. 이러한 대기 시간은 네트워크 상황에 따라 변할 수 있기 때문에 TCP는 ACK 대기 시간을 항상 계측한 뒤 이에 맞춰 대기 시간을 동적으로 변경한다. 

<br/>

# **3. ACK 번호의 효율적 관리**

TCP는 한 패킷을 보낸 후 ACK 번호를 기다리지 않고 차례대로 연속해서 복수의 패킷을 보냄으로서 대기 시간에 의한 낭비를 방지한다. 그러나 이 경우 수신 측의 능력을 초과하여 패킷을 보내는 사태가 생길 수 있다. 수신측은 수신 버퍼에 데이터를 임시 보관하며 수신 처리를 차례로 진행하는데, 이 버퍼 크기를 초과하는 것이다. 따라서 수신측에서는 송신측에 수신 가능한 데이터 양을 사전에 통지하고 이 양을 초과하지 않도록 송신 동작을 실행한다. 이를 윈도우 제어 방식이라고 한다. 

수신 처리로 인해 수신 버퍼에 빈 부분이 생기면 TCP 헤더의 윈도우 필드를 통해 송신 측에 수신 가능한 양이 늘어났음을 알린다. 이떄 수신 가능한 데이터 양의 최대값을 윈도우 사이즈라고 부르며, TCP를 정밀 조정하는 매개변수의 하나이다. 수신 측은 패킷을 수신 즉시 처리를 시작하므로 수신 가능한 양은 수시로 변하며, 데이터만 두고 봤을 땐 일방적인 송신으로 보여도 실제로는 이러한 신호를 계속 양방향으로 주고 받는다. 

<br/>

# **4. ACK 번호와 윈도우의 합승**

송수신 효율성을 높이기 위해서는 ACK 번호와 윈도우 통지 타이밍도 고려해야 한다. 이 둘을 분리해서 생각해보면 윈도우 통지 동작은 수신 버퍼에서 데이터를 추출하여 빈 공간이 늘어났을 때, 즉 송신과는 무관한 타이밍에 발생할 것이다. 반면 ACK 번호는 데이터를 정상 수신한 후 즉시 보내야 될 것이다. 그러나 이렇게 따로 송신할 경우 패킷이 늘어나 효율성이 저하된다. 

수신측은 ACK 번호 송신 및 윈도우 통지가 필요할 때 소켓을 바로 보내는 대신 잠시 기다렸다가, 다음 통지 동작이 일어났을 때 양쪽을 상승시켜서 한 개의 패킷으로 묶어보낸다. 이렇게 할 경우 복수의 ACK 번호 통지가 연속으로 일어났을 때도 패킷 수를 줄일 수 있다. ACK 번호는 수신한 데이터의 끝을 알리는 것이므로 최후의 것만 통지해도 되며 이럴 경우 패킷 수를 줄일 수 있으며 윈도우 통지의 경우도 마찬가지이다. 

<br/>

# **5. HTTP 응답 메시지 수신**

위와 같은 과정을 거쳐 프로토콜 스택은 HTTP 리퀘스트 메시지를 보낸다. 이후에는 웹 서버에서 응답 메시지를 기다리고 이를 수신하기 위해 read를 호출한다. 그러면 read를 통해 프로토콜 스택에 제어가 넘어가고, 송신할 때와 마찬가지로 수신 버퍼를 사용하여 데이터를 받는다. 데이터가 수신될 때까지 잠시 기다리다가, 데이터가 도착하면 유효한 데이터인지 확인한 후 이를 애플리케이션에 건네주게 된다. 

확인하는 과정은 다음과 같다. 우선 수신 데이터와 TCP 헤더 내용을 조사하여 도중에 누락된 것은 없는지 검사하고 없을 경우 ACK 번호를 반송한다. 그 후 데이터 조각을 수신 버퍼에 일시 보관하다가, 충분히 쌓이게 되면 원래 모습으로 연결, 복원하여 애플리케이션이 지정한 메모리 영역에 기록한다. 그 후 애플리케이션에 제어를 되돌려주고, 타이밍을 가늠하여 윈도우를 송신 측에 통지한다. 