---
title: 어셈블리어 기초 2) 기본 명령어
categories: OS
tags: 
toc: true
toc_sticky: true
---

## **1. 사칙 연산**

**1) add, 더하기 연산**
```
add a, b
```
$a$에 $a+b$ 값을 넣어주는 연산. 

이때, 조건이 몇가지 있다.

- a는 레지스터 혹은 메모리여야 한다. 

- b는 레지스터 혹은 메모리 혹은 상수여야 한다.

- 단, a, b 모두 메모리면 안된다. 

- b에는 a보다 큰 크기(byte)의 값이 올 수 없다.

<br/>

메모리에 상수를 더하는 예시는 아래와 같다. mov로 메모리에 상수를 넣었을 때와 마찬가지로 상수의 크기를 표시해주어야 한다.

```
section .text
global CMAIN

CMAIN:
    add [a], byte 1 
    ...

section .bss
    a resb 1
    
```

**2) sub, 빼기 연산**
```
sub a, b
```
$a$에 $a-b$ 값을 넣어주는 연산. 사용하는 방식 및 유의사항은 add와 동일하다. 

<br/>

**+) 왜 add memory, memory 연산은 안될까?**

[참고1](https://www.quora.com/Why-is-it-not-possible-to-add-the-contents-of-two-memory-locations-variables-in-8086-assembly-language),  [참고2](https://myfreechild.tistory.com/entry/Assembly-%EC%97%B0%EC%82%B0%EC%97%90%EC%84%9C-Memory-To-Memory-%EC%97%B0%EC%82%B0%EC%9D%B4-%EB%B6%88%EA%B0%80%EB%8A%A5%ED%95%9C-%EC%9D%B4%EC%9C%A0)

프로세서 제조사의 공식 입장은 찾지 못했고, 비효율적이기 때문에 설계 과정에서 배제되었을 것이라는 추측이 주도적이었다. 한 명령어에서 두 메모리 접근을 가능하게 하려면 처리해야 되는 비용이 늘어난다는 것, 그리고 그렇게 했을 때 큰 이점이 없다는 것이 이유이다. 

이런 추측에 대해 자세히 이해하려면 명령어 사이클에 대해 이해해야 한다. [명령어 사이클](https://chw-owo.github.io/computer/structure/%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%82%AC%EC%9D%B4%ED%81%B4/)

명령어 사이클을 보면 레지스터에 있는 값을 더하거나, 상수 값을 더하는 것과 달리 메모리에 있는 값을 가져오기 위해서는 MAR, MBR을 거치는 다소 복잡한 과정이 필요함을 알 수 있다. 두 메모리에 있는 값을 가져와 더하는 과정을 임의로 디자인해보면 아래와 같다.

```
    //1. 첫번째 오퍼랜드 인출
    MAR <- PC
    MBR <- M[MAR], PC <- PC + 1
    IR     <- MBR
 
    // 2. 임시 저장
    MAR <- IR
    MBR <- M[MAR]
    AC    <- MBR
 
    //3. 두번째 오퍼랜드 인출
    MAR <- PC
    MBR <- M[MAR], PC <- PC + 1
    IR     <- MBR
   
    //4. 대상 메모리 주소를 엑세스하여 저장
    MAR <- IR
    M[MAR] <- AC

```
보다시피 이렇게 되면, 한 사이클에 1 마이크로 연산이라는 가정 하에 한 명령어가 최소 11사이클을 차지하는 셈이 된다. Program Control Unit의 Control Memory에서 위와 같이 큰 루틴을 저장하게 되면 기억 장소의 낭비가 클 것이며, 동일한 과정을 거치는 2번의 인출 과정을 하나의 루틴으로 구성하기 때문에 비효율적일 것이다. 또, 기존의 일반적인 프로세서의 Data Bus는 8bit - 64bit 사이의 크기를 가지는데, 한 명령어에서 두 가지 operand 모두에 대해 주소 지정이 가능하려면 32bit 프로세서 기준 최소 64bit가 주소 지정에 쓰여야 한다. 한 명령어에서 두 메모리에 동시에 접근하기 위해서는 Data Bus의 수용 크기 뿐 아니라 MBR, IR, IBR 등 레지스터의 수용 크기 역시 커져야하는데 이럴 경우 프로세서 제조 비용이 상승하게 된다. 

참고로 일부 CISC 아키텍쳐에서는 한 명령어에서 두 가지 operand 모두 메모리를 쓸 수 있도록 설계한 경우도 있다고 한다. RISC의 경우 한 사이클에 하나의 Instruction 처리를 설계의 기본으로 하기 때문에 메모리 접근, Instruction 인출, 읽기/쓰기 등을 한 사이클 내에 처리할 수 없어서 이러한 설계가 더 어려운 반면 CISC는 하나의 Instruction이 여러개의 Micro-Operation 조합으로 구성될 수 있기 때문에, 비용만 감수한다면 설계가 가능하다고 한다. 

**3) mul, 곱하기 연산**

곱하기 나누기 연산에는 몇 가지 규칙이 있다. 
```
mul bl
```
위와 같이 입력할 경우 al * bl의 연산 결과가 ax에 저장된다.

```
mul bx
```
위와 같이 입력할 경우 ax * bx의 연산 결과 중 상위 16bits는 dx에, 하위 16bits는 ax에 저장하게 된다.

따라서 만약 5 * 8을 ax에 저장하고 싶다면 아래와 같이 쓸 수 있다.

```
mov ax, 0
mov al, 5
mov bl, 8
mul bl
```

**4) div, 나누기 연산**

부호 없는 정수의 나눗셈을 수행하며, 뒤에 레지스터와 메모리만 올 수 있고 상수는 올 수 없다.

```
div bl
```
위와 같이 입력할 경우 ax/bl 의 연산 결과 중 몫을 al에, 나머지를 ah에 넣게 된다. 

따라서 만약 100 / 3의 몫과 나머지를 각각 al, ah에 저장하고 싶다면 아래와 같이 쓸 수 있다.

```
mov ax, 100
mov bl, 3
div bl
```

## **2. 시프트 연산**

**1) shr, shl**

shift, 영어 단어 뜻 그대로 옮기는 연산이다. 

shift left의 준말인 shl의 경우 왼쪽으로 밀고 그 자리에 0을 채우는 것을 의미한다.

```
mov eax, 0x12345678
shl eax, 8
```
eax를 8bit 만큼 왼쪽으로 옮기고(shift) 그 자리에 0을 채워넣는 것이므로 연산 후의 eax 값은 0x34567800이 된다. 

반대로 오른쪽으로 다시 당길 수도 있다. 

shift right의 준말인 shr의 경우 오른쪽으로 밀고 그 자리에 0을 채우는 것을 의미한다.

```
shr eax, 8
```

이렇게 할 경우, eax는 처음 값인 0x12345678으로 돌아오는 게 아니라 0x00345678이라는 값이 된다. 기존에 어떤 값이었든 간에 옮겼던 만큼 0으로 채우기 때문이다. 

**2) shift 연산의 응용**

2진수에서는 왼쪽으로 갈 수록 각 bit가 * 2 만큼 더 큰 숫자를 의미하므로 왼쪽으로 한칸을 미는 행동은 * 2 를, 오른쪽으로 한칸을 미는 행동은 / 2 를 하는 것과 같은 결과가 나온다. 즉, 2의 배수에 해당하는 곱하기 나누기 연산을 보다 빠르게 수행할 수 있게 된다. 

계산기에서 시행할 경우 산술적 시프트와 논리적 시프트가 나누어져 있기도 하다. 보통 2진수의 맨 앞자리는 부호 비트로 사용되는데, 산술적 시프트의 경우에는 부호 비트는 유지한 채 나머지 부분에서 shift가 일어나고, 논리적 시프트의 경우에는 맨 앞자리도 포함해서 shift가 일어난다. 

그 외에도 게임 제작 시 ObjectID를 만들 때 활용하거나 상태를 정의할 때 활용하는 등에 메모리 공간을 줄이거나, 성능을 향상하기 위해 응용하기도 한다. 

<br/>

## **3. 논리 연산**


## **4. 분기문과 반복문**


## **5. 배열**


## **6. 함수**


## **출처**

[C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈] Part1: C++ 프로그래밍 입문, Rookiss

https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=hjyang0&logNo=152390859
