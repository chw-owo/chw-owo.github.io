---
title: Task 04) Thread Scheduling
categories: WindowsViaC-Cpp
tags: 
toc: true
toc_sticky: true
---

이 포스트는 <제프리 리처의 Windows via C/C++ (한빛미디어)> 내용을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 스레드 스케줄링**

## **1) 스레드 스케줄링**

윈도우는 언제라도 특정 스레드를 정지하고 다른 스레드를 수행할 수 있기 때문에 선점형 멀티스레드 기반 운영체제라고 불린다. 선점형 운영체제는 스레드 스케줄링에 대한 알고리즘을 갖고 있다. 또, 각 스레드의 컨텍스트 구조체에는 스레드가 마지막으로 수행되었을 때의 레지스터 정보를 갖고 있으며, 윈도우는 각 스레드들이 얼마나 많이 수행될 수 있는 기회를 부여받았는지 정보를 유지한다. 

윈도우는 매 20 밀리초 정도마다 모든 스레드 커널 오브젝트 중 스케줄 가능 상태의 스레드 커널 오브젝트를 검색하고, 이 중 하나를 선택하여 해당 구조체의 레지스터 값을 CPU 레지스터로 로드한다. 이를 Context Switch라고 한다. Context Switch가 발생하면 CPU 시간을 할당받은 스레드는 프로세스 주소 공간 내에 위치한 코드를 수행하고 데이터를 사용한다. 다시 20 밀리초 정도가 지나면 윈도우는 CPU 레지스터 정보를 컨텍스트에 저장하며 스레드 수행이 정지된다. 그리고 새로운 스레드를 탐색, 선택하기를 반복한다. 

이때 시스템은 스케줄 가능 상태의 스레드에 대해서만 스케줄링을 수행한다. 그러나 시스템 내 대부분의 스레드는 보통 스케줄 불가능한 상태이다. CreateThread 호출 시 CREATE_SUSPENDED 플래그를 전달하여 정지된 스레드를 생성한 경우가 그 예에 해당한다. 또 Input을 기다리는 상태도 수행할 작업이 없는 상태이므로 CPU 시간을 할당 받을 수 없다. 이때 input이 들어와 작업이 있는 상태가 된다고 해서 바로 스레드가 수행되는 것은 아니고, 그냥 해당 스레드가 스케줄 가능한 상태가 되는 것 뿐이다. 

## **2) 스레드의 정지와 계속 수행**

CreateProcess, CreateThread 로 스레드 커널 오브젝트를 생성한 직후 정지 카운트는 1로 초기화 된다. 이 덕분에 스레드가 완전히 초기화 될 때까지 스레드는 스케줄 불가능 상태가 된다. 완전히 초기화 된 이후에 CREATE_SUSPENDED를 확인하는데 전달되지 않았다면 정지 카운트를 0으로 감소하고 스레드는 스케줄 가능 상태가 된다. 

만약 CREATE_SUSPENDED 플래그로 인해 스레드가 멈춰있다면 ResumeThread를 호출하면 된다. 실패할 경우 0xFFFFFFFF가, 성공할 경우 이전 정지 카운트 값이 반환된다. 그 외에도 SuspendThread 함수를 호출하여 핸들로 전달된 스레드를 정지시킬 수 있다. SuspendThread를 호출하면 커널 모드에서 수행 중인 코드는 비동기적으로 수행을 완료하는 반면 유저 모드의 코드는 즉시 정지된다. 스레드는 MAXIMUM_SUSPEND_COUNT만큼 반복 정지할 수 있으며 해당 값은 winNT.h에 127로 정의되어 있다.  

실제로 SuspendThread를 호출할 때는 주의해야 한다. 수행 중인 스레드가 어떤 작업을 수행하던 중에 정지될지 알 수 없기 때문이다. 만약 힙에 메모리를 할당하던 중에 정지되면 힙은 lock이 되며, 다른 스레드가 힙에 접근하려 시도하면 첫번째 스레드가 다시 수행되기 전까지 함께 수행이 정지된다. 따라서 이 함수는 스레드 정지시 발생할 수 있는 deadlock과 같은 각종 문제들을 피할 수 있을 때 사용해야 한다. 

## **3) 프로세스의 정지와 계속 수행**

프로세스는 CPU로부터 시간을 할당 받는 대상이 아니지만, 프로세스 내의 모든 스레드를 정지시킴으로서 사실상 정지시킬 수 있다. 그러나 이는 경합 상태 (race condition)을 유발할 가능성이 있기 때문에 디버깅 매커니즘에서만 이러한 방법을 제공하고 있다. 디버거의 경우 WaitForDebugEvent 함수가 반환한 디버그 이벤트를 처리하고 ContinueDebugEvent를 호출할 때까지 프로세스 내 모든 스레드를 정지 상태로 만든다. 이를 응용하여 구현한 예시는 아래와 같다. 

```c++
VOID SuspendProcess(DWORD dwProcessID, BOOL fSuspend)
{
     HANDLE hSnapshot = CreateToolhelp32Snapshot(
        TH32CS_SNAPTHREAD, dwProcessID);

    if(hSnapshot != INVALID_HANDLE_VALUE)
    {
        THREADENTRY32 te = {sizeof(te)};
        BOOL fOk = Thread32First(hSnapshot,, &te);
        for(; fOk; fOk = Thread32Next(hSnapshot, &te))
        {
            if(te.th32OwnerProcessID == dwProcessID)
            {
                HANDLE hThread = OpenThread(THREAD_SUSPEND_RESUME,
                FALSE, te.th32ThreadID);

                if(hThread != NULL)
                {
                    if(fSuspend)
                        SuspendThread(hThread);
                    else
                        ResumeThread(hThread);
                }
                CloseHandle(hThread);
            }
        }
        CloseHandle(hSnapshot);
    }        
}
```

Toolhelp 함수를 사용하면 시스템 내의 스레드 목록을 얻을 수 있으며, OpenThread 함수를 이용하면 입력한 스레드 ID에 해당하는 스레드 커널 오브젝트의 핸들을 반환하고 해당 오브젝트의 Usage Count를 증가시킨다. 위 코드에서는 이를 이용해 SuspendThread를 호출하고 있다. 

그러나 이 코드는 100% 확실한 동작을 보장하지 않는다. 스레드 목록을 순회하는 동안 새로운 스레드가 생성되거나 목록에 있는 스레드가 파괴될 수 있기 때문이다. 만약 Toolhelp 함수 이후 생성된 스레드가 있다면 정지되지 않았던 스레드를 재실행할 수 있다. 더 최악의 경우로, 만약 스레드 ID를 순회하는 동안 기존 스레드가 종료되고 동일한 스레드 ID의 새 스레드가 생겼다면 이 경우 원치 않던 타 프로세스 내의 스레드가 대신 정지될 수도 있다. 따라서 지정한 프로세스의 동작 방식을 잘 숙지하고 적절하게 사용해야 한다. 

## **4) Sleep**

스레드는 Sleep 함수를 통해 일정 시간동안 자신을 스케줄하지 않도록 할 수 있다. Sleep을 호출하면 자발적으로 남은 타임 슬라이스를 포기하며, 해당 시간동안 스레드를 스케줄 불가 상태로 만든다. 또한 윈도우는 실시간 운영체제가 아니기 때문에 해당 시간이 지났을 때 반드시 스케줄 가능 상태로 돌아올 것이라고 보장할 수 없다. 만약 인자로 0을 전달할 경우 남은 타임슬라이스를 포기하는 기능만 수행한다. 

## **5) 스레드 전환**

스케줄 가능 상태에 있는 다른 스레드를 수행하기 위해 SwitchToThread 함수를 호출할 수 있다. 이 함수를 호출하면 일정 시간 동안 CPU 시간을 받지 못했던 스레드를 찾아 스케줄하고, 만약 없을 경우 바로 FALSE를 반환된다. CPU 시간을 할당 받은 스레드는 단일 퀀텀 시간 동안만 수행되며 이후로는 이전과 동일하게 스케줄링을 수행한다. 이를 통해 낮은 우선순위의 스레드가 리소스를 빨리 사용하고 반환하게 할 수 있다. 

## **6) 하이퍼 스레드 CPU 상에서의 전환**

하이퍼 스레딩 기술이 적용된 프로세서 칩은 다수의 논리적 CPU를 가지며 각기 다른 스레드를 수행할 수 있다. 이 같은 CPU에서 수행되는 스레드는 자신만의 레지스터 정보를 가지고 있지만 CPU 캐시와 같은 자원은 공유한다. 특정 스레드가 캐시 미스, 분기 예측 실패, 명령어 결과에 대한 대기 등으로 일시적으로 멈출 경우 이러한 CPU는 OS의 개입 없이도 자동으로 다른 스레드를 수행한다. 인텔은 이러한 하이퍼 스레딩 기술을 이용하면 10-30% 정도의 성능 개선 효과를 볼 수 있다고 한다.

하이퍼 스레드 기반 CPU에서 스핀 루프를 수행할 경우 다른 스레드가 공유 리소스에 접근할 수 있도록 현재 스레드를 일시적으로 멈추는 것이 좋다 이때 x86 아키텍쳐일 경우 PAUSE 명령을 사용하면 메모리 순서 위반을 회피하여 성능 향상에 도움을 줄 수 있으며, 루프 중간에 적절히 배치하면 전력 소모도 줄일 수 있다. 이를 C/C++에서 사용하려면 WinNT.h의 YieldProcessor 매크로를 사용하면 된다. 

## **7) 스레드 수행 시간 구하기**

일반적으로 GetTickCount64로 시간차를 구해서 스레드가 얼마만큼의 시간을 사용했는지 알 수 있다. 그러나 선점형 운영체제에서 스레드는 현재 코드 수행 중간에 얼마든지 다른 작업을 수행할 수 있는 반면, 이를 이용한 코드는 코드 수행 중 인터럽트가 수행되지 않는다는 가정이 필요하다. 

따라서 정확한 시간을 구하려면 GetThreadTimes 함수를 사용하는 것이 좋다. 이는 생성 시간, 종료 시간, 커널 모드에서 코드 수행에 소요된 시간인 커널 시간, 코드 수행에 소요된 시간인 유저 시간을 반환한다. GetProcessTimes 함수 역시 이와 유사하게 동작하며, 프로세스 내 모든 스레드들이 소요한 시간 정보를 얻어온다. 

더 정밀한 시간 측정이 필요하다면 QueryPerformanceFrequency, QueryPerformanceCount 함수를 응용하는 것이 좋다. 이는 스케줄러가 해당 스레드를 선점하지 않을 경우에만 시간을 정확하게 측정할 수 있지만, 정밀한 시간 측정은 보통 코드 상 일부분에서만 사용되므로 크게 문제가 되지 않는다. 

<br/>

# **2. CONTEXT 구조체**

## **1) CONTEXT 구조체**

CONTEXT 구조체는 시스템이 저장하는 스레드의 상태 정보로, 다음번에 CPU가 해당 스레드를 수행할 때 어디서부터 수행을 시작해야 하는지 알려준다. 이때 CPU 별로 구조체 내에 정의된 멤버들이 조금씩 달라진다.

CONTEXT 구조체 몇개의 영역으로 나뉘는데 그 구조는 아래와 같다. 

**CONTEXT_CONTROL**: instruction pointer, stack pointer, flags, function return address 와 같은 CPU 제어 레지스터를 포함한다. 

**CONTEXT_INTEGER**: CPU의 정수 레지스터 값을 포함한다. 

**CONTEXT_FLOATING_POINT**: CPU의 부동소수점 레지스터 값을 포함한다. 

**CONTEXT_SEGMENTS**: CPU의 세그먼트 레지스터 값을 포함한다. 

**CONTEXT_DEBUG_REGISTERS**: CPU의 디버그 레지스터 값을 포함한다. 

**CONTEXT_EXTENDED_REGISTER**: CPU의 확장 레지스터 값을 포함한다. 

## **2) CONTEXT 값 가져오기**

스레드는 유저 모드 컨텍스트와 커널 모드 컨텍스트를 갖고 있는데, GetThreadContext 함수를 통해 유저 모드 컨텍스트의 정보를 가져올 수 있다. 이때 반드시 SuspendThread 함수를 먼저 호출해주어야 의도된 컨텍스트 정보를 반환받을 수 있다. 만약 스레드가 커널 모드의 코드를 수행하는 중이었다면 스레드는 즉각 정지되지 않을 텐데, 어차피 유저 모드 컨텍스트 내용을 변경하지 않기 때문에 문제가 되지 않는다. 

CONTEXT 구조체에는 ContextFlags 멤버가 있는데 이는 레지스터와 연관이 없으며 단순히 GetThreadContext 함수가 어떤 레지스터의 값을 설정하거나 획득하고자 했는지 알려주는 용도로 사용된다. 따라서 이 값을 원하는 영역의 플래그로 반드시 설정해주어야 한다. 사용 예시는 아래와 같다. 

```c++
CONTEXT Context;
Context.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
GetThreadContext(hThread, &Context);
```
이때 CONTEXT_FULL을 사용하면  CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS와 동일하게 동작한다. 

## **3) GetThreadContext의 응용**

아래 코드는 스레드 Context 정보를 변경하여 스레드가 접근 위반을 발생시키도록 유도한다. 

```c++
CONTEXT Context;
SuspendThread(hThread);

Context.ContextFlags = CONTEXT_CONTROL;
GetThreadContext(hThread, &Context);

Context.Eip = 0x00010000; 
Context.ContextFlags = CONTEXT_CONTROL;
SetThreadContext(hThread, &Context);

ResumeThread(hThread);
```

이를 실행하면 처리되지 않은 예외 메시지 박스가 나타나며, (이 코드를 수행한 스레드가 아니라) 컨텍스트 정보가 변경된 스레드와 그 스레드를 소유한 프로세스가 종료될 것이다. 따라서 기존 스레드는 코드를 정상적으로 수행하며 프로세스는 성공적으로 에러를 발생시킨다. 

이처럼 GetThreadContext, SetThreadContext를 잘 사용할 경우 시스템으로부터 상당한 제어권을 얻을 수 있다. 이는 일반적으로 어플리케이션에서 직접적으로 사용되기보다는, 디버거 혹은 유틸리티 성격의 도구에서 제한적으로 활용되는 경우가 많다.

<br/>

# **3. 우선순위**

## **1) 스레드 우선순위**

모든 스레드는 0-31 범위의 우선순위 번호를 가지며, 다음에 수행할 스레드를 선택할 때 높은 우선 순위의 스케줄 가능한 스레드를 선택한 후 라운드 로빈 방식으로 이들을 수행한다. 타임 슬라이스가 끝나면 31번 우선순위 스레드 중 스케줄 가능한 스레드를 먼저 탐색한 뒤, 없을 경우 30번 우선순위 스레드를 탐색하게 된다. 

따라서 1개 이상의 31 우선순위 스레드가 늘 스케줄 가능한 상태에 있다면 그보다 낮은 우선순위의 스레드는 절대 CPU 시간을 할당 받지 못하게 되는데 이를 기아 상태라고 한다. 물론 대부분의 스레드는 스케줄 불가능한 상태를 유지할 때가 많기 때문에 이러한 상황이 자주 발생하지는 않는다. 

만약 낮은 우선순위의 스레드가 작업을 수행하던 중, 높은 우선순위의 스레드가 스케줄 가능상태가 되면 어떻게 될까? 낮은 우선순위의 스레드는 남은 타임 슬라이스에 상관 없이 바로 정지되며 높은 우선순위 스레드가 CPU 시간을 할당받게 된다. 

시스템이 부팅되면 제로 페이지 스레드라는 특별한 스레드가 생성되는데, 이는 시스템 전체에서 0번 우선순위를 가진 유일한 스레드이다. 스케줄 가능한 스레드가 하나도 없을 때 호출되어서 램의 사용되지 않는 페이지를 0으로 만들어주는 작업을 수행한다. 

이때, 윈도우가 어떠한 스케줄링 알고리즘을 사용하는지에 대해서는 정확하게 알 수 없다. 마이크로 소프트는 스케줄러의 동작 방식을 완벽하게 문서화하지 않고 있으며, 이러한 알고리즘이 언제든 변경될 수 있으니 코드를 방어적으로 작성할 것을 권고한다. 

그 이유는 스케줄링 알고리즘이 사용자가 수행하는 어플리케이션 형태에 상당한 영향을 받기 때문이다. 그러나 보편적으로 수행하는 어플리케이션의 유형은 시간이 지나면서 꾸준히 변화하고, 스케줄링 알고리즘은 이에 상관 없이 언제나 정상적으로 수행되어야 한다. 따라서 이러한 정책을 택한 것으로 보인다.

우선순위 레벨이 0-31까지 존재하지만 어플리케이션 개발자는 이러한 우선 순위 레벨을 직접 사용할 수 없으며 아래의 우선순위 클래스를 사용하면 시스템이 이를 매핑하여 적용한다. 이때 매핑 정보는 시스템의 버전별로 상이하다.

## **2) 프로세스 우선순위 클래스**

**Realtime, 실시간**: 즉각적 응답이 필요한 경우 사용하며, 해당 스레드는 운영체제가 운용하는 스레드보다도 우선적으로 수행된다. 이는 디스크 IO, 키보드 마우스 입력, 네트워크 트래픽 등을 방해할 수 있으므로 주의하여 사용해야 한다. 

**High, 높음**: 즉각적 응답이 필요한 경우 사용하며, 작업 관리자의 경우 사용자가 수행 중인 프로세스를 종료할 수 있도록 하기 위해 이 클래스로 수행된다. 

**Above Normal, 보통 이상**: 보통과 높음 사이의 클래스이다. 

**Normal, 보통**: 특별한 스케줄링 규칙이 필요하지 않은 경우 사용된다.

**Below Normal, 보통 이하**: 보통과 유휴 상태 사이의 클래스이다. 

**Idle, 유휴 상태**: 수행할 다른 스레드가 없는 경우에 사용한다. 주로 화면 보호기나 백그라운드 유틸리티, 통계 및 정보수집 프로그램에서 사용된다. 


## **3) 상대 스레드 우선순위 클래스**

**Time-critical, 타임 크리티컬**: 실시간 우선순위 클래스에서는 31, 다른 우선순위 클래스에서는 15로 동작한다.  

**Highest, 가장 높음**: 보통 + 2

**Above Normal, 보통 이상**: 보통 + 1

**Normal, 보통**: 프로세스 우선순위 클래스에 대해 보통으로 수행된다. 

**Below Normal, 보통 이하**: 보통 - 1

**Lowest, 가장 낮음**: 보통 - 2

**Idle, 유휴 상태**: 실시간 우선순위 클래스에서는 16, 다른 우선순위 클래스에서는 1로 동작한다. 

<br/>

# **4. 우선순위 프로그래밍**

## **1) 우선순위 설정**

프로세스의 우선순위 클래스는 CreateProcess를 호출할 때 fdwCreate 매개변수로 우선순위 클래스를 전달하면 해당 우선순위를 지닌 프로세스가 생성된다. 스레드의 상대 우선순위를 설정하기 위해서는 SetThreadPriority를 사용한다. 

## **2) 동적인 우선순위 레벨 상승**

시스템은 IO 이벤트에 대해 응답하거나 윈도우 메세지, 디스크 등을 읽기 위해 우선순위 레벨을 상승시키기도 한다. 예를 들면 키보드 디바이스 드라이버가 시스템에게 스레드 우선순위 레벨을 한 타임 슬라이스 동안만 높여줄 것을 요청하는 식이다. 

각각의 디바이스 드라이버가 얼마만큼의 우선순위 레벨을 상승시키는 지에 대해 서는 문서화 되어있지 않지만, 시스템은 우선순위 레벨이 1-15인 스레드에 대해서만 레벨 상승을 시도한다. 이 범위를 동적 우선순위 범위라고 한다. 이 범위를 넘어갈 경우 운영체제의 동작에 영향을 미칠 수 있기 때문이다. 

만약 이러한 기능이 개발 중인 어플리케이션의 스레드에 좋지 않은 영향을 준다면 SetProcessPriorityBoot, SetThreadPriorityBoot 함수를 이용할 수 있다. 이를 이용하면 해당 스레드의 동적 우선순위 레벨 상승의 가능 여부를 설정할 수 있다. 반대로 GetProcessPriorityBoot, GetThreadPriorityBoot 을 사용하면 가능 여부를 반환값으로 확인할 수 있다. 

또, 스케줄 가능 상태의 특정 스레드가 우선순위 레벨로 인해 3-4초동안 CPU 시간을 전혀 받지 못함을 감지하면, 시스템은 해당 스레드의 우선순위를 15까지 일시적으로 상승시켜서 두번의 퀀텀 시간동안 스레드가 수행되도록 한다. 두번의 퀀텀 시간이 지나면 다시 기본 우선순위 레벨로 돌아간다. 

## **3) 포그라운드 프로세스를 위한 스케줄러 변경**

어떤 프로세스가 윈도우를 가지고 있고 사용자가 그 윈도우로 작업을 수행한다면 이러한 프로세스를 포그라운드 프로세스, 그 외의 다른 프로세스를 백그라운드 프로세스라고 한다. 이때 윈도우는 포그라운드 프로세스의 응답성을 개선하기 위해 해당 프로세스에게 일반적인 퀀텀 시간보다 조금 더 긴 퀀텀 시간을 제공할 수 있도록 한다. 이는 포그라운드가 보통 우선순위 클래스에서 수행될 때만 적용되된다.

윈도우 비스타 기준 시스템 속성 - 고급 - 성능 - 설정 - 성능 옵션 - 고급 - 다음의 최적 성능을 위해 조정 - 프로그램에서 설정할 수 있다. 

## **4) IO 요청 우선순위 스케줄링**

스레드 우선순위를 변경하는 것은 CPU 리소스를 어떻게 사용하는지에 영향을 미친다. 이때 IO 요청은 일반적으로 장시간의 처리 시간을 필요로 하며, 이 경우 낮은 우선순위에서 IO 요청을 하는 스레드가 높은 우선순위 스레드의 스케줄링에 영향을 주기도 한다. 

윈도우 비스타 이후로는 이를 해결하기 위해 스레드가 IO 요청에 대해 우선순위를 지정할 수 있게 되었다. 이는 위에서 언급했듯이 SetThreadPriority를 이용하면 된다. 이때 다른 프로세스에 속한 스레드의 IO 우선순위는 변경할 수 없다. 

만약 특정 파일에 대해서만 백그라운드 우선순위로 IO를 수행하고 싶다면 아래와 같이 코드를 작성할 수 있다. 

```c++
FILE_IO_PRITORITY_HINT_INFO phi;
phi.PriorityHint = IoPriorityHintLow;
SetFileInformationByhandle(
    hFile, FileIoPriorityHintInfo, &phi, sizeof(PriorityHint));
```
