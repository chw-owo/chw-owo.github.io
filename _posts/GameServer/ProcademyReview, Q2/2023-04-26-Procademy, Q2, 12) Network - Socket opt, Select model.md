---
title: Procademy, Q2, 12) Network - Socket opt, Select model
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. Socket Option**

## **1) SO_BUF**

SO_RCVBUF. SO_SNDBUF로 송수신 버퍼의 크기를 수정할 수 있다. 일반적으로 잘 건드리지 않으며,  Connect, Accept 전에 수정해야 적용이 된다. SO_RCVBUF는 0으로 설정해도 자동으로 늘어나므로 0으로 설정할 수 없지만 SO_SNDBUF는 0으로 설정할 수 있다. SO_SNDBUF를 0으로 설정하는 상황은 Overlapped 모델에서 사용되므로 그때 다시 언급할 것이다. 

## **2) SO_REUSEADDR**

사용 중인 소켓을 재사용하겠다는 의미이다. 수천개의 클라로 테스트 할 경우 TIME_WAIT이 남으면 몇 초만에 포트가 고갈되곤 하는데, 이때 SO_REUSEADDR를 설정하여 TIME_WAIT이 남아도 덮어쓰도록 만들면 문제 없이 테스트할 수 있다. 하지만 이보다는 Linger를 통해 rst로 종료하여 TIME_WAIT이 안 남도록 하는 것이 더 적절한 방식이다. 윈도우 환경에서 동작하지 않는 것으로 보인다. 

## **3) IP_ADD_MEMBERSHIP**

이 옵션을 통해 멀티캐스트 그룹을 설정할 수 있다. 멀티캐스트는 그룹 내 목적지 전체에 한번에 메시지를 전송하는 것이다. 이를 통해 특정 IP에 가입된 대상만 데이터를 받을 수 있도록 설정할 수 있다. LAN 단위로만 사용 가능하기 때문에 테스트 상황이 아니면 잘쓰이지 않는다. 

## **4) TCP_NODELAY**

이 옵션으로 Nagle 알고리즘을 설정할 수 있다. Nagle 알고리즘을 켠 경우 송신 조건은 (어떤 것에 대한 ACK인지 상관없이) ACK가 온 상황 혹은 송신 버퍼 데이터가 MSS 1460에 도달한 상황이다. 이런 이유로, 연결 후 첫 Send는 3-way Handshake에 대한 ACK 때문에 요청한 크기대로 전송된다. 

Nagle은 송신에만 적용되는 알고리즘이므로 어느 한쪽만 켜거나 끌 수도 있다. Nagle 알고리즘을 사용할 경우 헤더로 인한 트래픽이 주는 대신 응답성이 떨어지므로 상황에 맞게 적절히 선택해야 한다. 참고로 네트워크 요금을 매길 때 들어오는 트래픽은 비용을 측정하지 않고 나가는 트래픽만 측정하기 때문에 클라이언트는 끄고 서버만 켜는 경우도 많다.

<br/>

# **2. 방화벽**

## **1) 용어 설명**

방화벽 설정에 들어가면 개인 네트워크와 공용 네트워크를 설정할 수 있다. 개인 네트워크는 안전한 LAN을 사용하고 있으니 다양한 네트워크 기능을 활성화 해도 된다는 것을 의미한다. 반면 공용 네트워크는 더 방어적인 설정으로 미디어 검색 및 공유 기능 등 제한이 생긴다. 

또, 방화벽 설정에서 인바운드 규칙은 들어오는 것에 대한 규칙, 아웃바운드 규칙은 나가는 것들에 대한 규칙을 의미한다. 방화벽은 기본적으로 인바운드 규칙과 일치하지 않을 때 차단하고, 아웃바운드 규칙과 일치하지 않을 때 허용한다. 즉 들어오는 것은 일단 다 막기 때문에 허용하려면 따로 설정해야 하고, 나가는 것은 일단 다 허용하기 때문에 막으려면 따로 설정해야 된다.

소켓 예제를 테스트해보면 Listen이 호출되는 순간에 방화벽 창이 뜬다. 이 창이 “인바운드 규칙에 없는 건데 허용할 것입니까?”를 의미한다. 이때 확인을 누르면 자동으로 인바운드 규칙에 등록된다. 서버 테스트를 할 때는 이 창이 뜨지 않으니 규칙을 수동으로 등록해야 한다. 아웃바운드는 웬만하면 신경쓰지 않아도 된다. 

## **2) 세팅이 필요한 이유**

Window 9 이후부터 서버용 OS에도 Defender이 기본으로 설정되어 있다. 그러나 성능을 위해서는 Defender 설정을 다 해제하고 사용하는 것이 좋다. 이때 서버용 OS는 보안이 최고 레벨로 설정되므로 익스플로러 깔아도 모든 URL에서 경고창이 뜨며 하나씩 등록해야만 접근할 수 있다.

참고로 서버용 OS의 성능이 좋은 건 불필요한 기능을 덜기 때문이지 OS 동작 방식 자체는 동일하다. 리눅스가 윈도우보다 성능이 좋다고 하는 것 역시 콘솔 환경이라 그래픽 기능이 없기 때문이지 OS 자체가 더 뛰어나다고 보기는 어렵다. 리눅스를 윈도우 환경으로 만들면 별 차이도 없고, 오히려 콘솔 창만 남긴 윈도우 서버 코어, 윈도우 나노의 경우 리눅스보다 성능이 좋다는 테스트 결과도 있다.

## **3) 방화벽 세팅 방법**

우선 안쓰는 포트를 열어 둘 필요는 없으니 공용으로 설정하는 것이 좋다. 이후 방화벽 - 고급 보안 - 작업 - 인바운드 규칙 - 새 규칙에서 프로그램 혹은 특정 포트를 지정해서 방화벽을 열 수 있다. 이때 프로그램으로 열 경우 실행 파일 이름이 일치하면 경로가 다르니 차단이 되면서도 방화벽 경고창은 뜨지 않는다. 그러니 헷갈리지 않게 프로그램 대신 포트로 열기를 권장한다. 

<br/>

# **3. Non-Blocking**

## **1) Block vs Non-Block**

지금까지 작업한 것은 작업이 완료될 때까지 Block이 걸리는 Blocking 소켓이었다. Non Blocking은 일단 요청을 하고 바로 함수를 return 하는데, connect로 예를 들면 SYN만 보내고 결과를 확인하지 않은 채 return 하는 셈이다. 따라서 결과를 다른 방식으로 다시 확인해야 되며, 예외 코드가 Would Block인지 혹은 정말 예외 상황인지 체크해야 한다. 

## **2) Non-Block 설정 방법**

```c++
// Set Socket Non-Blocking Mode
	u_long on = 1;
	ret = ioctlsocket(sock, FIONBIO, &on);
	if (ret == SOCKET_ERROR) return 0;
```

위 코드를 통해 Non-Blocking 소켓으로 설정할 수 있다. 

<br/>

# **4. Select Model**

## **1) Select Model**

이는 Block 함수인 select()를 사용해서 소켓 사용 가능 시점을 알려주는 모델로 Block, Non block 소켓에 모두 적용할 수 있다. select()는 unix, 윈도우 호환이 가능한 함수이며 성능이 다른 모델들에 비해 상대적으로 약하긴 하지만 가장 단순하고 가장 확실한 모델이다. 이런 이유로 아직 현업에서도 간혹 사용되며, 실제로 언리얼 데디케이트 서버 역시 이 방식을 채택하고 있다. 

## **2) fd_set**

fd_set 구조체는 소켓의 집합으로, 우선 fd_set 구조체에 확인하고 싶은 소켓들을 넣는다. 이후 해당 구조체를 전달하여 select()를 호출하면 set 내에서 현재 작업 가능한 소켓들만 남기고 다 없애버린다. 이후엔 남은 소켓들로 작업을 수행하면 된다. 단점은 set 하나 당 64개의 소켓만 받을 수 있으며, select를 반복적으로 호출해야 하다보니 여기서 성능 저하가 발생한다. 

fd_set에는 read set, write set, exception set이 있다. read set은 backlog 큐나 수신 버퍼에 무언가 있을 때, fin이 왔을 때 수신 가능한 상태에 반환된다. write set은 connect()에 성공했을 때, 소켓 송신 버퍼의 여유 공간이 충분할 때 등 송신 가능한 상태에 반환된다. exception set은 OOB 감지 용도로, 잘 사용되진 않는다. 가끔 connect 관련하여 제한적으로 사용된다.

write set의 한계는 현재 여유가 있음을 알 수는 있지만 버퍼의 남은 공간 크기까지 알 수는 없다는 것이다. 따라서 write set이 반응을 보여도 남은 공간보다 보내려는 데이터가 더 클 경우 block 소켓이라면 block이 걸리고, Non block 소켓이라면 WouldBlock이 반환된다. block이 걸리는 것보다는 낫기 때문에 보통 select 모델에는 Non block 소켓을 사용한다. 

FD는 file descriptor의 약자로 추정된다. unix에서는 파일과 소켓을 동급의 입출력 대상으로 묶어서 다 파일이라고 부르는데, select() 함수는 unix에서 사용하던 것을 그대로 가져온 것이기 때문에 그 영향을 받은 것으로 보인다. 


## **3) select()**

```c++
int select
(
    int n, 
    fd_set * readfds, 
    fd_set * writefds, 
    fd_set * exceptfds, 
    struct timeval * timeout
);
```

n에는 검사 대상이 되는 파일 디스크럽트의 수를 전달한다. fd_set에는 fd_set의 포인터를 전달하는데 사용하지 않는 set 종류에는 nullptr을 전달하면 된다. timeout은 최대 검사 시간으로, 하나라도 반응이 있으면 이 전에 return 되지만 없을 경우 그 시간까지 기다린다. 0을 넣으면 대기 없이 바로 반환하고 NULL을 넣으면 무한 대기한다. 현재 작업 가능한 소켓의 수를 반환한다. 

이때 select를 실행하고 나면 준비되지 않았던 소켓이 모두 사라지므로 매번 fd_set을 다시 세팅해야 한다. 전역에 두고 재사용하는 게 불가능하진 않지만 정석적으로 지역에서 사용하길 권장한다. 또, 윈도우의 경우 define 되어 있는 fd_set 크기를 수정하면 값을 바꿀 수 있다고 MS에 나와있으나 이미 컴파일 된 파일의 경우 반영되지 않을 수도 있으므로 권장하지 않는다. unix의 경우 아예 OS를 재컴파일 해야 된다.

## **4) FD Macro**

FD_SET 내부를 확인해보면 fd_count 만큼 반복문을 돌려서 중복이 나타나면 break 하고 없을 경우 차례대로 넣는 것을 볼 수 있다. 특정 소켓을 지우는 FD_CLR 역시 중간에 빈 공간이 없어야 하므로 단순하게 지운 곳에서부터 하나씩 앞으로 복사한다. FD_ISSET 역시 동일하게 반복문으로 확인한다. 

## **5) send - recv 구조**

**구조 1**
```c++
while(1)
{
 	Network - recv, send
	Logic 
	Frame Wait
}
```

**구조 2**
```c++
while(1)
{
 	Network - recv
	Logic 
    Network - send
	Frame Wait 
}
```

구조 2의 경우 select가 두번 호출되므로 성능 낭비가 생기는 대신 더 좋은 응답성을 보일 수 있다. 

게임에서 로직은 수신부에서 처리할 수 있는 로직과 모든 데이터를 recv 한 이후에 처리할 수 있는 로직으로 나뉜다. 날아오는 무기를 보고 피할 수 있는 컨텐츠라면 recv 이후에 오는 Logic 단계에서만 충돌 처리를 계산할 수 있을 것이다. 

이때 더 빠른 반응성을 보이고 싶다면 send를 recv 받고 바로 처리하여 send 하는 것과, Logic 처리 이후에 send 하는 것으로 나누어서 처리할 수도 있다. 배틀 그라운드가 이런 방식을 채택하고 있다. 그러나 사용자에게 유의미하게 체감되는 차이는 아니다. 또, 이 경우 send를 두번 하기 때문에 트래픽과 서버 부하가 늘어난다. 서버에 여유가 있다면 괜찮지만 부담이 큰 상태라면 적합하지 않은 방식이 될 수 있다. 


