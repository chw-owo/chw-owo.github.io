---
title: Procademy, Q1, 06) C - 호출규약, 전처리기, 포인터
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 스택 프레임**

## **1) bp가 오염되는 사례**

지난 주에는 ip가 오염되는 예제를 봤는데 이번에는 bp가 잘못되는 예제를 보았다. 32bit 체제에서는 ebp주소를 기반으로 지역 변수 위치를 파악하기 때문에 stack에 저장된 old ebp를 잘못 건드릴 경우 그 이후에 지역 변수 값으로 잘못된 위치를 가리키게 된다. 따라서 문제의 함수가 ret 된 이후로 지역 변수에 이상한 값들이 들어갈 것이다.

```c++
#include <iostream>
void Test()
{
	int* p;
	int x = 0;
	p = &x;
	*p = 0;
	p++;
	p++;
	*p += 4;
}

int main()
{
	int a = 0;
	Test();
	printf("%d", a);
}
```
위 예제를 실행해보면, 콘솔에서 a값이 출력은 되지만 엉뚱한 값을 가리키고 있으며 에러가 뜨게 된다. 만약 이러한 과정을 거쳐 우연히 유효한 값, 그러나 의도되지 않은 값이 들어가게 되면 큰 문제가 생길 수 있다. 이러한 문제를 피하기 위해 유저가 보낸 데이터를 사용할 때는 깐깐한 검사와 예외처리를 거쳐야 한다.

<br/>

# **2. 함수의 호출규약**

## **1) 인자의 전달 순서**

```c++
#include <iostream>
void Test(int a, int b, int c)
{
	int x = a + b + c;
}
int main()
{
	Test(1,2,3);
}
```
파라미터에 넣는 값이 일반적인 변수라면 전달 순서가 중요하지 않지만 만약 함수를 넣을 경우 전달 순서가 곧 함수의 호출 순서가 되기 때문에 중요해진다. 어셈블리어를 확인해보면 오른쪽에서 왼쪽, 즉 뒤에서 앞에 순서대로 호출되는 것을 확인할 수 있는데, 오늘날 대부분의 호출 규약이 이 순서를 따른다. 하지만 애초에 파라미터로 전달되는 함수 호출 순서에 영향 받는 코드는 위험한 방식이니 지양하는 것이 좋다. 디폴트 파라미터의 경우, 컴파일러가 인자 전달 단계에서 디폴트 파라미터를 처리하기 때문에 동일하게 오른쪽에서 왼쪽으로 전달된다. stack에서 보자면 왼쪽에 있는 인자값이 더 bottom에 가깝게 위치하는 것이다.

## **2) 스택 정리 위치**

호출규약에는 함수 반환 시 stack의 ebp, esp 정리를 호출부에서 할지 함수 내부에서 할지에 대한 정보도 담고 있다. 

```c++
#include <iostream>
void Test(int a, int b, int c)
{
	int x = a + b + c;
}
int main()
{
	Test(1,2,3);
}
```

```
push        ebp  
mov         ebp,esp  
push        ecx  

;int x = a + b + c
mov         eax,dword ptr [a]  
add         eax,dword ptr [b]  
add         eax,dword ptr [c]  
mov         dword ptr [x],eax  

mov         esp,ebp  
pop         ebp  
ret  
```
(참고로 이처럼 변수가 적은 함수에서는 esp 조정 부분에 sub esp 대신 push ecx가 들어가는 것을 확인할 수 있다. 이때 ecx는 아무 의미가 없는 값이고, 그저 지역 변수 크기를 확보하는데에 sub보다 push가 더 빠를 것이라 생각해서 컴파일러가 이런 작업을 한 것이다.)

위 코드에서 add esp, 즉 esp를 정리하는 부분이 보이지 않는다. 그리고 ret 이후를 보면 main함수에서 해당 부분이 나온다. 즉 stack을 함수 내부에서 정리하고 나오는 대신, 호출자가 정리하는 규약을 택한 것이다.

현재 쓰이는 호출 규약은 크게 __stdcall, __cdecl 두 가지가 있음. stack을 사용하는 것은 둘 다 동일하지만 그 stack 정리를 내부에서 하는지 호출함수가 하는지에 대한 것만 다르다. 디폴트 호출 규약은 프로젝트 속성 - C++ - 고급 - 호출 규칙에서 수정할 수 있으며, 특정한 함수만 수정하고 싶다면 아래와 같이 함수 이름에 명시해주면 된다.

```c++
void __stdcall Test(int a, int b, int c)
{
	int x = a + b + c;
}
```
이렇게 하고 실행해보면
```
push        ebp  
mov         ebp,esp  
push        ecx  

;int x = a + b + c
mov         eax,dword ptr [a]  
add         eax,dword ptr [b]  
add         eax,dword ptr [c]  
mov         dword ptr [x],eax  

mov         esp,ebp  
pop         ebp  
ret  	 	0Ch

```
위의 경우오 모두 동일하지만 ret 뒤에 0Ch가 추가된 것을 확인할 수 있다. 이는 stack의 esp를 ret 뒤의 숫자만큼 당긴다는 것을 의미한다. ret는 기본적으로 인자를 받는 명령어이다. 인자를 받지 않을 경우 ip를 바꾸고 stack을 조정하는 역할만 하지만, 위의 경우처럼 인자를 넣으면 그만큼 esp를 add 하라는 의미가 된다. 돌아갈 주소 다음에 Parameter stack이 깔려있어서 함수 내부에서 add esp를 할 경우 동작이 잘못되기 때문에 저런 방식을 사용하는 것이다. 내부적으로 보면 ret에 \[ ip 조정 - stack 조정 - esp 조정 ] 의 과정이 포함된다고 생각하면 된다. 

호출 규약이 서로 다르면 stack을 두번 정리하거나 혹은 정리하지 않는 일이 생길 수도 있다. 따라서 함수 하나만 호출 규약을 지정해줘도 그것을 호출하는 모든 함수들에 다 자동으로 적용된다. 참고로 printf 같이 가변인자를 사용하는 함수의 경우 변수의 개수를 정하지 않았기 때문에 호출자에서만 이를 정리할 수 있다. stack을 상수로 정할 수 없으니 ret로 stack을 정리할 수 없는 것이다.

## **3) Windows의 호출 규약**

windows CALLBACK 함수는 프로그래머가 직접 호출하는 대신 윈도우에게 함수의 포인터를 전달하고 정해지는 조건에서 호출되기를 기다리는 함수를 의미한다. 이때 함수 이름 앞에 붙이는 CALLBACK이 어떻게 define 되었는지 확인해보면 내부에서 __stdcall로 변환되는 것을 알 수 있다. Windows API가 모두 __stdcall로 이루어져있기 때문이다.

참고로 64bit에서는 stack을 적극 활용하는 대신 register를 더 활용하는 것을 지향하기 때문에 조금 다를 수 있다. 64bit가 되면 호출 규약 역시 stdcall, cdecl로 나뉘지 않고 Windows, Linux로 나뉜다. 이는 Windows API에도 동일하게 적용된다. 이러한 호출 규약은 언어마다 조금씩 다르기 때문에 표준으로 보기는 어렵다. 

## **4) 번외**

```c++
void Test(int a, int b, int c)
{
	printf("%d, %d, %d", a, b, c);

}
int main()
{
	int a = 0;
	Test(++a,++a,++a);
}
```
이 예제를 실행해보면 컴파일러에 따라 ++a 3번 한 결과물을 넘기기도 하고, ++a를 한번씩 하고 하나씩 넘기기도 하는 등 결과가 다르게 나온다. 그러니 이렇게 호출 규약에 따라 달라질 수 있는 애매한 코드는 지양해야 한다.

<br/>

# **3. 정적 변수**

## **1) static 변수의 초기화**

```c++
#include <iostream>

int AAA()
{
	return rand();
}
void Test()
{
	static int a = AAA();
	a++;
	printf("%d", a);
}

int main()
{
	Test();
	Test();
	Test();
	Test();
}
```
여기서 a 는 data 영역에 만들어지는 정적변수로 처음 초기화 할 때 값이 고정된다. 따라서 저렇게 함수가 호출되어야 값이 정해지는 경우엔, 일단 0으로 data 영역에 초기화된 다음에 처음 초기화될 때 AAA()의 결과물을 얻게 된다. 그 과정을 컴파일러가 알아서 처리해주는데, 내부적으로는 bool 값을 하나 만들어서 초기화 했는지 아닌지 체크한 뒤, 초기화 되어 있다면 다시 값을 변경할 수 없도록 하는 구조로 이루어져있다. 문제는 멀티스레드까지 고려하다보니 동기화 코드를 포함하게 되어 매우 긴 명령어로 이루어지는 것을 확인할 수 있다. 물론 2번째 이후로 호출할 때는 거치는 명령어의 수가 비교적 줄어들지만 그럼에도 매번 cmp를 거치게 된다. 따라서 정적 변수를 초기화 할 때는 되도록 상수로 해주는 것이 성능상 좋다. 만약 class의 객체를 static으로 선언할 경우 생성자를 반드시 호출해야 되기 때문에 어쩔 수 없이 그 긴 코드가 포함되게 된다. 따라서 static 객체도 성능을 고려하면 지양하는 것이 좋다. 

<br/>

# **4. 전처리**

## **1) define - ifdef의 활용**

#define은 상수값을 치환할 때도 쓰지만 #ifdef, #undef를 사용하여 #define이 걸렸는지 아닌지에 따라 다른 결과를 내게끔 사용할 수도 있다. 실제로 DEBUG MODE, RELEASE MODE, 32bit, 64bit를 전환하는 것도 내부적으로 뜯어보면 아래처럼 이루어져서 무엇이 define 되었느냐에 따라 다른 함수를 호출하는 것을 확인할 수 있다. 

```c++
#define WIN32
#define _DEBUG
```

만약 버전별로 소스코드가 많아지면 한번 에러에 모든 소스코드를 수정해야만 하는 비효율적인 상황이 생긴다. 따라서 여러 버전이 필요할 경우 #define을 이용하여 코드를 추가하고 소스 코드 개수는 되도록 유지하는 것이 좋다. 

## **2) 매크로**

```c++
__DATE__
__FILE__
__LINE__
__TIME__
```
위 매크로를 사용하면 컴파일 단계에서 알아서 상수값으로 바꿔준다.

<br/>

# **6. enum**

## **1) enum**

enum에서는 값을 지정할 수 있는데 한번 지정하면 그 다음값도 지정한 값에서 ++ 되는 형태로 값이 정해진다. 참고로 요즘 visual studio는 마우스를 대면 어떤 값인지 보여준다. 이때 enum type 자체를 변수의 type으로 가져오게 되면 엉뚱한 상수값이 들어갈 가능성을 줄여준다. 그 예시는 아래와 같다.

```c++
enum eSKILL 
{
..
};

int Skill(eSKILL e)
{
switch(e)
…
}

int main()
{
	Skill(eSKILL:: ~~);
}
```
이렇게 해두면 일반적인 int 값으로는 인자를 전달할 수 없게 된다. 반드시 eSKILL::FIRE 와 같은 형식으로 넣어야 하기 때문에, 예상치 못한 에러를 줄일 수 있다. 

## **2) enum class**

C++11 enum class의 경우, enum과 달리 중복된 이름을 사용할 수 있다. 대신 어떤 enum class에 해당하는지 매번 표기해주어야 한다. 

<br/>

# **7. 재귀함수**

## **1) 재귀함수와 오버플로우**

재귀함수는 스택 오버플로우의 위험을 갖고있지만, 잘 활용할 경우 매우 효율적으로 사용할 수 있다. 재귀를 사용한 대표적 예시가 레드블랙트리다. 일반 이진 트리의 경우 재귀를 사용하면 한쪽으로만 노드가 쏠리며 오버플로우가 발생할 수 있지만 balanced tree의 경우, depth가 1000만 되어도 2의 1000승까지 담을 수 있기 때문에 거의 위험하지 않다. 실수가 없다는 가정하에 그 용량을 인간이 초과할 가능성은 거의 없다. 참고로 최근에는 아무리봐도 스택 오버플로우가 발생할 것 같은 상황은 미리 에러를 띄워주기도 한다. 

<br/>

# **8. 포인터**

## **1) 함수 포인터**

위에서 언급했듯이 CALLBACK의 경우 인자를 함수 포인터로 받는다. 이럴 때 우리가 만든 함수를 함수 포인터의 형태로 던지게 되는데, 그 선언 예시는 아래와 같다. 

```c++
int main()
{
	void (*ptr)(void);
	ptr = AAA;
	ptr();
}
```
반환형 (*함수 포인터 이름)(매개변수) 순으로 적고, 담고자 하는 함수의 이름(주소값)을 넣어주면 된다. 기본적으로 괄호를 쓰면 호출, 이름만 쓰면 함수 주소 전달을 의미한다. 함수포인터도 자료형 자체는 포인터 자료형이므로 (32bit 혹은 64bit로 크기가 정해진) 배열로 만들어 사용할 수도 있다. 그 예시는 아래와 같다. 

```c++
int main()
{
	void (*ptr[5])(void);
	ptr[0] = Test1;
	ptr[1] = Test2;
	ptr[2] = Test3;
	ptr[3] = Test4;
	ptr[4] = Test5;

	ptr[4]();
}
```
선생님은 가독성이 떨어져서 선호하지 않는다고 하셨지만, 일본 게임 업계에서는 이를 많이 사용한다고 한다. switch-case로 함수를 호출하는 경우, 이걸 사용하면 switch문을 간결하게 대체할 수 있다.

## **2) const와 포인터**

```c++
const int * p = &a;			// 역참조 값을 변경할 수 없다
int const *p = &a;			// 역참조 값을 변경할 수 없다
int* const p = &a;			// p의 값을 변경할 수 없다
const int* const p = &a;	// p와 역참조 값 모두 변경할 수 없다.
```

자료형을 떼고 보면 조금 더 쉽다

```c++

const * p = &a;			// 역참조 값을 변경할 수 없다
const *p = &a;			// 역참조 값을 변경할 수 없다
* const p = &a;			// p의 값을 변경할 수 없다
const * const p = &a;	// p와 역참조 값 모두 변경할 수 없다.
```

변수 타입을 제외하면 위와 같다. 살펴보면 const가 *의 앞에 붙냐 뒤에 붙냐에 따라 달라지는 것을 알 수 있다.

```c++
int* const p = &a;	: p의 값을 변경할 수 없다
```

사실 위 경우는 거의 사용되지 않는다. 

포인터에 대한 const는 함수의 매개변수로 포인터를 넘겨줄 때 많이 쓰인다. 전달하는 값을 읽기는 하지만, 함수 내부에서 수정할 수 없도록 막아야 할 때 주로 사용된다. 사용 예시는 아래와 같다. 

```c++
void Test1(const CPlayer* p)
{
	//
}
```
실제로 strcpy 함수를 봐도 Destination은 일반 char*, Source는 const char* 인 걸 확인할 수 있다. 

<br/>

# **9. 질문**

**Q. 32bit를 쓰다가 64bit를 쓸 때 차이점은?**

64bit는 bp를 사용하는 대신 rsp 만 갖고 그에 대한 상대 주소로 주소를 표현합니다. 또, 함수의 인자를 전달할 때 stack에 인자를 push 하는 대신 register를 적극적으로 활용합니다. 그 외에도 명령어 주소 크기, 변수 크기에서 차이를 보입니다. 처음 배울 때 32bit 기준으로 하는 이유는 32bit의 디스어셈블리가 조금 더 일관적이기 때문입니다. 64bit는 보다 복잡하고 환경에 따라 과정이 조금씩 달라지므로 32bit로 어셈블리에 익숙해진 뒤 64bit에서 어떻게 달라지는지 익히는 것을 권장합니다. 최근에 새롭게 개발하는 게임들은 다 64bit로 만들지만, 이전부터 서비스 되던 게임들은 32bit 체제로 계속 유지 보수 하는 경우도 많으니 결과적으로는 둘 다 익숙해져야 합니다. 

**Q. 64bit에서 rsp만 사용한다면, bp 오염으로 스택이 깨지는 것과 같은 문제를 피할 수 있나요?**

bp 오염으로 인해 깨지지는 않겠지만, rsp를 어떻게 백업하고 활용하는지에 따라 여전히 스택이 깨질 위험은 있습니다.

**Q. Windows API를 이용할 때 함수 호출 규약 관련하여 고려해야 할 점은?**

CALLBACK처럼 우리가 만든 함수를 Windows에서 사용하게 만들 경우에만 주의하면 됩니다. (그리고 사실 이건 컴파일 단계에서 에러를 내줍니다) 그 외에 Windows API를 사용하는 경우엔 컴파일러가 알아서 작업해줍니다.
