---
title: 프로세스와 IPC 1) 컴퓨터 구조 (2)
categories: WindowsSystem
tags: 
toc: true
toc_sticky: true
---

이 포스트는 윤성우님의 <뇌를 자극하는 윈도우즈 시스템 프로그래밍 (한빛미디어)> 내용을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 컴퓨터 구조의 접근 방법**

## **1) 레지스터 디자인**

### **I. 컴퓨터 디자인에서 레지스터란**

프로그래머가 컴퓨터를 디자인 한다고 하면 일반적으로 이는 CPU 디자인을 의미한다. 그 중에서도 특히 레지스터에 집중하여 디자인 하게 된다. CPU의 특성을 알 필요가 있는 시스템 프로그래머 입장에서, CPU를 보는 관점은 대부분 레지스터에 집중된다. ALU와 컨트롤 유닛의 동작 원리는 상대적으로 고정되어 있기 때문이다.

### **II. 레지스터 디자인 결정 요소**

**-** 레지스터를 몇 비트로 구성할 것인가?

**-** 몇 개 정도로 레지스터를 구성할 것인가?

**-** 레지스터 각각을 무슨 용도로 사용할 것인가?

64bit 컴퓨터를 사용한다면 레지스터도 64bit로 디자인 하는 게 맞지만, 공부하는 입장에서는 64bit를 표현하는데에 많은 불편함이 따른다. 따라서 16bit의 레지스터 8개로 구성된 CPU를 만드는 것으로 가정하려고 한다. 이를 그림으로 표현하면 아래와 같다. 

![image](https://user-images.githubusercontent.com/96677719/213084533-b58366de-0d62-45bf-8681-fd4da2ae996b.png)

ir, sp, lr, pc 라는 이름의 레지스터는 특수한 목적으로 사용된다. CPU 구성 형태(레지스터 구성 형태)에 따라서 명령어 구조가 달라지기 때문에, 명령어 디자인에 앞서 이처럼 레지스터 디자인을 하고 넘어가야 한다. 따라서 CPU가 달라지면 이에 따른 명령어 구조가 달라지기 때문에 어셈블리 언어로 구현된 프로그램은 다른 구조의 CPU로 이식할 수 없다. 

참고로 위 구조는 ARM 코어를 참조한 것으로, 다른 CPU 보다 하드웨어 구성과 명령어 구조가 간단한 특징을 갖는다. 따라서 전력소비가 적고, 핸드폰과 같은 작은 기기에 적합하다. 

<br/>

## **2) 명령어 디자인**

### **I. 명령어 디자인의 과정**

명령어도 몇 비트로 구성할 것인지 결정해야 하는데, 레지스터가 16bit이니 명령어도 16bit로 구성하도록 하자. CPU 종류에 따라 레지스터 크기와 명령어의 크기가 다른 경우도 있지만 여기서는 통일하여 사용하려고 한다. 

만약 16bit를 모두 명령어로 사용한다면 2의 16승인 65536개의 명령어를 만들 수 있다. 그러나 C++도 연산자를 포함하는 키워드 개수가 100개를 넘지 않는데 이러한 활용은 비효율적이다. 따라서 16bit를 모두 명령어로 사용하는 대신 명령어, 피연산자 1, 피연산자 2, 결과 저장 장소로 나누어 사용하고자 한다. 이렇게 짜여진 명령어 기본 구성은 아래와 같다. 

![image](https://user-images.githubusercontent.com/96677719/213085543-e3033848-291d-45a8-95db-5ae49f656680.png)

연산자를 많이 만들지 않을 예정이므로 3bit로, 레지스터가 총 8개이므로 저장소도 3bit로, 피연산자는 각각 4bit로 구성하였다. 

![image](https://user-images.githubusercontent.com/96677719/213086004-6cd5853b-f90a-48f6-812e-1b8b24c9d2b0.png)

이 경우 위와 같이 명령어 번호를 지정해줄 수 있을 것이다. 레지스터 역시 인덱스에 맞는 2진 숫자로 찾아가면 된다. 

이때, 만약 피연산자 1 위치에 0001이란 값을 넣었다고 해보자. 이 경우 register 1에 있는 값을 의미하는지 값 1을 의미하는지 알 수 없다. 따라서 피연산자 1 위치의 첫 bit는 이에 대한 판별 비트로 사용한다. 0이면 값 정보를, 1이면 레지스터 정보를 담은 것으로 해석하는 것이다. 이 경우, 첫번째 피연산자 값의 범위는 (unsigned 정수 기준) 0~8로 제한된다는 한계가 있다. 실제 CPU에서도 이와 비슷한 제약 사항을 겪는다. 

어쨌든 이로서 명령어 디자인을 마쳤다. 만약 r1에 있는 값에 7을 더해서 r2에 넣어주고 싶다면 어셈블리어로는 아래와 같이 쓸 수 있을 것이다. 

```
add r2, r1, 7
```
그리고 이를 우리가 정한 2진 숫자에 맞게 기계어로 변환하면 아래와 같다.

```
00 001 010 1001 0111
```
실제 기계어 명령어도 위와 같은 과정으로 설계가 된다. 00 001 010 1001 0111가 CPU로 전달되면 우선 Instruction Register, IR에 올라간다. 그러면 컨트롤 유닛이 IR에 있는 코드를 해석하여 CPU의 각 모듈에 명령을 내리고, 다음번에 실행할 명령어가 다시 IR로 올라온다. 그 후 ALU, 레지스터 등의 모듈이 적절한 연산을 진행하게 된다. 참고로 프로그래머가 IR을 직접 컨트롤 할 일은 잘 없다.  

이때, 왜 피연산자나 저장소의 주소로 레지스터의 주소만 올 수 있고, 메인 메모리에서 직접 가져올 수는 없을까? 이에 대해서 [어셈블리어 기초 2) 기본 명령어][1] 포스트의 사칙 연산 부분에서 다룬 적이 있다. 간단하게 설명하자면 일반적으로 메인 메모리는 레지스터보다 더 큰 용량, 더 긴 주소값을 가진다. 이를 고려하여 피연산자 크기를 늘리면 CPU 제작에 비용이 많이 들며 하드웨어 구조, 명령어 구조 역시 더 복잡해진다. 또, 메인 메모리까지 오가는데 걸리는 시간을 고려하면 더 비효율적인 작업이 될 수 있다. 이러한 명령어들은 CPU 제작에 드는 비용, 성능 등을 종합적으로 고려하여 디자인 된다. 

### **II. RISC vs CISC**

앞에서 명령어를 설계한 방식은 RISC의 명령어 디자인 방식에 해당한다. RISC는 명령어의 길이가 고정되어 있어서 다양한 명령어를 사용할 수 없는 컴퓨터를 의미한다. 반면 다양한 명령어 크기를 가질 수 있는 컴퓨터를 CISC (Complex Instruction Set Computer)라고 부른다. CISC같은 앞서 명령어 개수를 세자리수로 제한했던 것과 달리 다양한 길이의 명령어를 가질 수 있다. 그러나 명령어가 다양한 대신 일정하지 않은 크기의 명령어를 해석해야 하므로 CPU 설계가 복잡해진다. 그에 비해, CISC 구조에서 지니는 전체 명령어 중 주로 사용하는 명령어는 10% 정도 밖에 되지 않는다. 잘 쓰이지 않는 90% 이상의 명령어를 위해 CPU를 복잡하게 디자인 하는 것은 비효율적이라는 이유로 명령어 수를 대폭 줄이고, 길이를 일정하게 만든 RISC구조가 만들어졌다. RISC가 성능상 이점을 보이는 것에는, 초당 클럭 수 못지 않게 클럭당 처리 할 수 있는 명령어 개수가 중요하기 때문이다. RISC는 명령어 길이가 일정하기 때문에 클럭당 둘 이상의 명령어 처리가 가능하다. 이 때문에 RISC 구조가 성능 향상에 있어서 장점을 갖게 된다. 

AMD 64, Intel x86 프로세서는 CISC 구조를 채택하고 있고, 

ARM, MIPS, 임베디드 환경의 대부분의 CPU는 RISC 구조를 채택하고 있다. 

<br/>

# **2. Load & Store 명령어**

## **1) Load & Store의 디자인**

Load는 메인 메모리에서 데이터를 읽어오는 명령어를, Store은 메인 메모리에 데이터를 저장하는 명령어를 의미한다. 이를 위해서는 register의 주소, 메모리의 주소 두개의 정보가 필요할 것이다. 따라서 기존에 피연산자를 위해 사용되었던 8bit를 메모리 주소를 담는 공간으로 사용하도록 하겠다. 그리고 Load, Store에도 이전의 사칙연산처럼 110, 111이라는 이진 코드를 각각 붙여준다. 그 예시는 아래와 같다. 

![image](https://user-images.githubusercontent.com/96677719/213089881-5b3adc80-02f8-4d25-8625-b57cbce25065.png)

![image](https://user-images.githubusercontent.com/96677719/213089825-fd18b89a-9a7e-4a5e-b8bc-b7d871e56a6e.png)

메모리 주소 0x10, 0x20 있는 두 값을 더해 0x30에 넣다고 가정해보자. 여기서 설계한 16bit 명령어 시스템에서는 피연산자로 레지스터와 숫자만 올 수 있다. 따라서 아래와 같이 Load / Add / Store의 과정을 거쳐야 할 것이다. 

```
load    r1,     0x10
load    r2,     0x20
add     r3,     r1, r1
store   r3      0x30
```

실제 32bit, 64bit에서의 연산도 메모리에서 레지스터로 값을 불러오고, 레지스터에 있는 값으로 연산을 진행하고, 다시 메모리에 값을 저장하는, 위와 유사한 과정을 통해 이루어진다. 

<br/>

# **3. Direct/Indirect 모드**

## **1) Indirect 모드의 필요성**

위의 예시에서 문제가 하나 있다. 위와 같은 방식을 사용할 경우 0x0000 - 0x00ff 까지의 메모리 주소에는 접근할 수 있지만, 명령어 크기의 제한 때문에 0x0100에는 접근할 수 없게 된다. 위에서 사용했던 메모리 접근 방법을 Direct 모드라고 하는데, 이 경우 할당 된 비트 수 안에서 수를 모두 표시해야 하므로 이러한 문제를 겪게 된다. 이를 해결하기 위해 Indirect 모드를 사용할 수 있다. 

## **2) Indirect 모드의 이해**

Indirect 모드는 특정 메모리에 접근하여 직접 해당 메모리의 값을 가져오는 대신, 특정 메모리가 가리키는 주소로 이동해서 그 메모리의 값을 가져오는 것이다. 

![image](https://user-images.githubusercontent.com/96677719/213091676-3690e583-cb24-4c87-834e-2e324d80ea5c.png)

이미지로 설명하면 다음과 같다. 명령어에서 지정하는 주소값이 Direct 인지 Indirect인지 구분하기 위해, 앞서 남겨두었던 예약 비트 2bit를 사용할 수 있다. 

## **3) Indirect 모드의 활용 예제**

위에서 언급했던 문제를 Indirect Mode를 이용해 해결할 수 있다. 이번에는 메모리 주소 0x10, 0x100 있는 두 값을 더해 0x30에 넣다고 가정해보자.

```
load    r1,     0x10

mul     r0,     4, 4    // 0x10
mul     r2,     4, 4    // 0x10
mul     r3,     r0, r2  // 0x100

store   r3,      0x30    // 0x30에 0x100 값을 담는다
load    r2,     [0x30]  // Indirect Mode
add     r3,     r1, r2

load    0x30,   r3
```
mul로 0x100의 수를 만들고, 이를 0x30에 넣는다. 그 후 Indirect Mode로 0x30에 있는 값을 주소 삼아, 0x100에 있는 값을 로드해온다. 그 이후로는 이전처럼 add 연산 후 0x30에 넣어주면 된다. 

<br/>

# **출처**

뇌를 자극하는 윈도우즈 시스템 프로그래밍, 윤성우, 한빛미디어

[1]: https://chw-owo.github.io/os/%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC%EC%96%B4-%EA%B8%B0%EC%B4%88-2)-%EA%B8%B0%EB%B3%B8-%EB%AA%85%EB%A0%B9%EC%96%B4/