---
title: Procademy, Q2, 27) Algorithm - AStar
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. Node**

```c++
struct Node
{
	x, y
	g,
	h,
	f,
	Node *pParent
}
```

g는 출발점으로부터의 이동 횟수, 즉 이동 거리를 의미한다. 현재 노드는 부모로부터 다음 칸이므로 pParent->g + 1이 된다. 출발점으로부터의 이동 횟수가 적을 수록 효율적인 길이 된다. 

h는 목적지와의 거리를 의미한다. g는 거쳐온 경로를 모두 포함하는 거리인 반면 h는 직접적인 최단 거리를 저장한다. 수학적으로는 대각선이 되어야겠지만 이러면 g와 비교하여 계산할 때 값이 조금씩 달라지기 때문에, 보통 x축 거리와 y축 거리를 더하는 맨하탄 방식을 사용한다. 한칸 한칸마다 h를 갖고 있으며 이걸로 목적지와 더 가까운 노드임을 파악하여 그 방향으로 나아간다. 

f는 g와 h를 더한 값으로, f가 제일 적은 경로를 최종 경로로 지정한다. 이를 바탕으로 출발점으로부터의 이동 횟수와 목적지와의 거리의 합이 최소가 되는 경로를 찾을 수 있다. 

pParent는 현재 노드가 어디서 왔는지. 어떤 부모로부터 어떻게 와서 이 노드를 만들었는지 파악하기 위한 것이다. 부모 노드를 중심으로 자식 노드를 생성하고, 자식 노드 중 하나가 목적지에 닿았을 때 거쳐온 부모 노드를 타고 돌아가면 그게 경로가 된다. 

<br/>

# **2. OpenList, CloseList**

길찾기의 기본은 갔던 길을 다시 가지 않는 것이다. 따라서 OpenList와 CloseList를 따로 만들어서 가봐야 될 노드와 이미 가봐서 가보지 않아도 되는 노드를 분리한다. 현 위치를 중심으로 8 방향 노드를 생성하여 생성 직후에는 OpenList에, 탐색 이후에는 CloseList에 넣는다. 

1   2   3
4   5   6    --------------------------------->  목적지
7   8   9

5가 출발점이라고 할 때, 맨 처음에는 OpenList에 5가 들어간다. 이것의 g, f, h를 구해서 저장한 후 5를 CloseList로 이동시키고 그 주변에 새로 생성한 노드인 1,2,3,4,6,7,8,9를 OpenList에 넣는다. 노드의 주변에 새 노드를 만들 땐 OpenList, CloseList를 순서대로 한번씩 더 탐색을 해서 새로 만들려는 노드가 이미 만들어진 적이 있는지 살펴봐야 한다. 1, 2, 3, 4, 5, 6, 7, 8, 9 모두 g는 1이지만 h의 경우 6이 제일 작을 것이다. 따라서 그 합산인 f가 제일 적은 노드 6으로 이동해야 한다. 이때 OpenList를 순회하면서 f가 제일 적은 노드를 반환하면 된다. 

이 알고리즘은 목적지와 출발지 사이에 ㄷ 형태의 막다른 길이 있을 경우, 다시 원래 지점으로 돌아오게 된다. 이 경우 최적의 길을 구하기 위해 pParent를 바꿔주어야 한다. 다시 노드를 확인하는 과정에서 현재 경로가 비효율적인 경로라고 판단되면, 즉 현재 인근 노드의 부모 노드보다 현 노드를 부모로 재연결하는 게 더 g를 줄일 수 있다고 판단되면 부모를 바꾸어야 한다. 이때 새로운 연결을 만들 때는 g 값이 작은 것을 기준으로 한다. 막다른 길로 들어갔다 나오면 g 값이 비대해지기 때문에 결국 g 값이 작은, 도착지점에서 최대한 일직선으로 가는 노드들이 선택된다. 

이때 CloseList는 이미 갔던 곳을 다시 가지 않기 위해 있는지 아닌지 확인하는 역할만 하기 때문에 자료구조로 관리하지 않고 flag를 만들어서 true/false로 확인할 수도 있다. 반면 OpenList는 이 중 어떤 노드가 제일 효율적인지에 대해 살펴보는 역할도 한다. 따라서 동적으로 늘어날 수 있고, 정렬과 탐색이 가능한 자료구조를 사용해야 효율적으로 길을 찾을 수 있다. 

갈 곳을 다 가봤는데도 길을 못찾은 경우 OpenList가 비는 상황이 생긴다. 이 경우 맵 상에 생성될 수 있는 모든 노드가 CloseList에 들어가있을 것이다. 같은 f일 때 h가 더 적은 방향으로 가도록 할 수도 있는데, 엄밀하게 이 방식을 따르려면 이중 정렬이 필요하다. 따라서 보통은 g, h의 가중치를 1:1로 두는 대신 1:3으로 두는 등의 방법을 선택한다. 길의 결과는 어차피 동일하지만 더 빠른 탐색을 원한다면 시도해볼 수 있다.  

만약 인근 노드의 h 값이 모두 동일하다면 OpenList가 어떤 정렬 방식을 택하고 있는지에 따라 선택 노드가 달라진다. 안정 정렬은 똑같은 데이터가 있을 때 그대로 밀어내므로 동일한 데이터들 간의 순서는 바뀌지 않는 것을 의미한다. 버블 정렬이 이에 해당하며 이 경우엔 넣은 순서의 역순으로 선택될 것이다. 반대로 이 순서가 바뀌는 것은 불안정 정렬이라 하며 스와핑 하면서 데이터를 정렬하는 퀵 정렬이 이에 해당한다. 이 경우라면 어떤 게 선택될 지 알 수 없다. 
