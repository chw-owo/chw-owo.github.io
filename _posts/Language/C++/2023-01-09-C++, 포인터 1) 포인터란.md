---
title: C++, 포인터 1) 포인터란?
categories: C++
tags: 
toc: true
toc_sticky: true
---

## **0. 들어가기에 앞서**

![image](https://user-images.githubusercontent.com/96677719/211467364-f7d22675-b896-4ec2-85cd-4f84ac754dfb.png)

좋아하는 짤... 사실 이 짤이 이 파트 내용의 거의 모든 걸 담고 있다. 

<br/>

## **1. 포인터 선언**

변수의 주소에 접근할 수 있도록 해주는 문법. 예시는 아래와 같다.

```c++
int* ptr;
```

선언하는 방법은 위처럼 매우 간단하다. 다만 데이터가 아니라 int형의 주소를 넣기 위한 변수가 되는 것이다. char, float 등의 다른 자료형의 포인터도 마찬가지로 TYPE*으로 선언하면 된다. 

이때, 포인터는 어떤 자료형의 포인터인지에 상관 없이 고정 크기를 갖는다. 32bit 체제를 사용할 경우 32bit, 64bit일 경우 64bit의 크기를 갖는다. 그렇다면 왜 자료형을 선언하나 의문일 수도 있겠지만, 자료형이 정수인지 실수인지 문자인지에 따라 같은 bit도 다르게 해석될 수 있기 때문에, 이후에 이를 이용해 조작, 연산 과정을 거치려면 명시해주는 것이 필요하다. 

## **2. 포인터로 값 조작하기**

```c++
int* ptr = &number;
```
특정 변수의 **주소**를 가져올 때는 변수 이름 앞에 &를 붙이면 된다. 

```c++
int address = ptr;
int value = *ptr;
```
해당 **주소**를 그대로 가져오고 싶을 땐 포인터 이름만, 해당 주소에 있는 **값**을 가져오고 싶을 땐 포인터 이름 앞에 *을 붙인다. 

```c++
*ptr = 2;
```
위처럼 포인터가 가리키는 주소에 있는 값을 변경할 수도 있다. 

*이 크게 두가지 용도로 쓰이는데, 변수를 선언할 때는 해당 변수가 포인터라는 표시로, 사용할 때는 이 주소 안에 있는 값이라는 표시로 해석하면 된다. 

이를 함수에서 유용하게 활용할 수 있다. 

```c++
void SetHp(int* hp)
{
    *hp = 100;
}

int main()
{
    int hp = 0;
    SetHp(&hp);

    return 0;
}
```

기존에는 지역변수의 값을 다른 함수에서 조작할 수 없었으나, 이런 식으로 지역변수 hp의 주소를 매개변수로 전달, 해당 주소에 접근해서 값을 바꾸는 방식을 사용할 경우 다른 함수에서도 지역변수의 값을 조작할 수 있게 된다. 

## **3. 어셈블리어**
```c++
int* ptr = &number;
```
이 과정을 어셈블리어로 보면 다음과 같다. 
```
lea     eax, [number]
mov     dword ptr [ptr], eax
```
lea는 주소값을 전달할 때 사용하는 명령어로, number의 주소 값을 ptr에 넣는 과정을 볼 수 있다. 

<br/>

```c++
int address = ptr;
int value = *ptr;
```
이 과정은 각각 아래와 같이 해석된다.
```
mov     eax, dword ptr [ptr]
mov     dword ptr [address], eax

mov     eax, dword ptr [ptr]
mov     ecx, dword ptr [eax]
mov     dword ptr [value], ecx
```
ptr에 담긴 주소를 찾아서, 다시 그 주소의 값을 찾기 때문에 mov 과정이 한번 더 추가된 것을 확인할 수 있다. 

<br/>

```c++
*ptr = 2;
```
이 과정은 아래와 같이 해석된다.
```
mov     eax, dword ptr [ptr]
mov     dword ptr [eax], 2
```

어셈블리어로 확인해보면 기존에 일반적인 변수를 사용하던 때와 크게 달라지지 않은 것을 알 수 있다. 

<br/>

## **4. 포인터와 함수**

포인터를 사용하지 않고 함수에서 다른 함수의 지역 변수 값을 바꾸는 것과 포인터를 사용해서 지역 변수 값을 바꾸는 것 두가지 상황을 비교해보자. 

**1) 포인터를 사용하지 않고 바꾸는 방법**

```c++
struct Player
{
    int hp;
    int mp;
}

Player CreatePlayer()
{
    Player player;
    player.hp = 100;
    player.mp = 100;

    return player;
}

int main()
{
    Player chw; 
    chw = CreatePlayer();

    return 0;
}
```

위 방법을 어셈블리어로 확인해보자. 일단 CreatePlayer 함수 부분을 보면 아래와 같다. 

```
mov     dword ptr [player], 64h
mov     dword ptr [ebp - 0ch], 64h

mov     eax, dword ptr [ebp + 8]

mov     ecx, dword ptr [player]
mov     dword ptr [eax], ecx

mov     edx, dword ptr [ebp - 0ch]
mov     dword ptr [eax + 4], edx
```

[ebp + 8]에는 CreatePlayer을 호출할 때 return값을 저장하기 위해 임시로 만들어진 주소가 들어있다. CreatePlayer()안에서 player을 만든 뒤, player의 값들을 지정해주고, 해당 값을 그 임시 주소에 하나하나씩 복사해주는 형태로 player 값의 return이 이루어진다. 

그리고 이를 main에서 어떻게 chw에 넣는지 확인해보면 아래와 같다.

```
mov     ecx, dword ptr [eax]
mov     dword ptr [ebp-0FCh], ecx

mov     edx, dword ptr [eax + 4]
mov     dword ptr [ebp-0F8h], edx

```
즉, 임시로 만들어진 주소의 값들을 다시 chw 주소(ebp-0FCh)로 하나씩 복사하는 것을 확인할 수 있다. 컴파일러 환경 및 설정에 따라 더 최적화 될 가능성도 있지만 보장받을 수는 없다.  


<br/>

**2) 포인터를 사용하여 바꾸는 방법**

```c++
struct Player
{
    int hp;
    int mp;
}

void CreatePlayer(Player* player)
{
    player.hp = 100;
    player.mp = 100;
}

int main()
{
    Player chw; 
    CreatePlayer(&chw);

    return 0;
}
```

위 방법을 어셈블리어로 확인해보면 다음과 같다. 

```
mov     eax, dword ptr [player]
mov     dword ptr [eax], 64h

mov     eax, dword ptr [player]
mov     dword ptr [eax + 4], 64h
```

return 없이 매개변수로 받은 주소에 직접 접근 해서 값을 바꾸는 것을 확인할 수 있다. 포인터를 사용하지 않는 예시에서는 'CreatePlayer()의 지역변수' -> 'return을 위한 임시 공간' -> 'main()의 지역변수' 를 거치며 두 차례 복사를 통해 위 작업을 수행한 반면, 포인터를 사용한 예시에서는 이를 한번에 수행한 것이다. 현재는 Player 구조체의 크기가 아주 작지만 Player 설정이 복잡해질 경우 해당 구조체 역시 매우 큰 용량이 되며, 그럴 경우 복사에 많은 시간이 소요된다. 이런 상황에서 포인터의 적절한 사용은 최적화에 있어서 큰 도움이 된다. 

<br/>



## **출처**

[C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈] Part1: C++ 프로그래밍 입문, Rookiss
