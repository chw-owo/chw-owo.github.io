---
title: C++, 기본 자료형
categories: Cpp
tags: 
toc: true
toc_sticky: true
---

## **1. 정수**

**1) 정수 자료형**

|자료형|크기|signed일 때 범위|unsigned일 때 범위|
|-----|----|---------------|-----------------|
|char|1 byte|-128~127|0~255|
|short|2 byte|-32768 ~ 32767|0~65546| 
|int|4 byte| 약 -21.4억~ 약 21.4억|0~약 42.9억|
|__int64|8 byte|매우 큰 값|매우 큰 값|
|long long|8 byte|매우 큰 값|매우 큰 값|

<br/>

**2) signed / unsigned** 

-unsigned: byte의 첫 bit를 부호로 사용하지 않는다. 따라서 음수를 표현할 수 없다.

-signed: byte의 첫 bit를 부호로 사용한다. 따라서 음수와 양수를 모두 표현할 수 있음

<br/>

+) unsigned의 사용

레벨처럼 이론적으로 양수만 존재하는 데이터에 대해서 unsigned를 쓰는지 아닌지는 스타일에 따라 갈린다고 한다. unsigned/signed 사이의 변환, 디버깅 편의성(차라리 레벨이 음수가 될 때 크래쉬를 내서 버그를 빨리 찾자는 입장 등)등을 고려하여 결정하면 된다. 

<br/>

**3)overflow/underflow**

위/아래로 범위를 초과하는 경우 아예 다른 값이 나오게 된다. 

<br/>

## **2. Boolean**

|자료형|크기|범위|
|-----|----|---------------|
|bool|1 byte|true, false|

<br/>

사실 bool은 내부적으로 1 byte 정수와 같다. 그러나 true, false로만 사용하기로 정한 자료형이다.

<br/>

## **3. 실수 (부동소수점)**

**1) 실수 자료형**

|자료형|크기|범위|구성|
|-----|----|----|----|
|float|4 byte|true, false|부호 1bit, 지수 8bit, 유효숫자 23bit|
|double|8 byte|true, false|부호 1bit, 지수 11bit, 유효숫자 52bit|

<br/>

**2) 표현 방법**

[실수를 컴퓨터에서 어떻게 표현하는지](https://chw-owo.github.io/computerstructure/bit,-%EB%B9%84%ED%8A%B8%EC%99%80-%EC%97%B0%EC%82%B0/)포스트 참조

예를 들어 float score = -3.375f를 변환한다고 해보자

<br/>

**i) 2진수 변환**

$3 + 0.375 = 0b11 + 0b0.011 = 0b11.011$ 

$(0.375 = 0.5 * 0 + 0.25 * 1 + 0.125 * 1 = 0b0.011)$

<br/>

**ii) 정규화**

$0b11.011 = 0.b1.1011 * 2^{1}$

따라서 부호 1, 지수 1, 유효숫자 1011이 된다. 이때, 지수부는 unsigned byte라고 가정하고 + 127을 해준다.

그 결과 $-3.375$는 $0b$ $1$ $10000000$ $1011$ $0000$ $0000$ $0000$ $0000$ $0000$ 로 저장이 된다.

<br/>

예시를 든 수의 경우 딱 떨어졌지만 만약 1/3 = 0.333.... 처럼 끝없이 떨어지는 수나 소수점 아래 자리가 길어지는 수의 경우 오차 범위가 커지기도 한다. 부동소수점은 항상 근사값임을 기억해야 하며 "==" 비교 역시 지양해야 한다. 

<br/>

## **4. 문자**

**1) 문자 자료형**

|자료형|크기|특징|
|-----|----|----|
|char|1 byte|알파벳, 숫자, 문자를 나타낸다.|
|wchar_t|1 byte|유니코드 문자를 나타낸다.|

<br/>

**2) char**

```c++
char ch0 = 'a';
```

char은 내부적으로 숫자를 담지만, char에 담긴 숫자는 출력 시에 ascii 코드에 맞게 변환되어서 문자로 출력된다. 문자를 직접 넣을 때는 '문자'라는 표시로 작은 따옴표를 사용하게 된다.

```c++
char ch0 = 1;
char ch1 = '1';
```
이렇게 넣을 경우 ch0에는 0x01에 해당하는 문자가 들어가고, ch1에는 '1'이라는 문자 그 자체가 들어간다. 

```c++
char ch0 = 'a';
char ch1 = ch0 + 1;
```

이렇게 넣을 경우 ch0에는 ascii 표에서 a 보다 숫자 1만큼 더 큰 문자인 b가 들어가게 된다. 

<br/>

**3) wchar_t**

그리고 전 세계 모든 문자에 대해 유일 코드를 부여한 것이 유니코드이다. 유니코드의 경우 아래처럼 써준다.

```c++
wchar_t wch = L'안';
```

단, cout은 char 전용이므로 wchar_t를 출력할 때는 아래처럼 써주어야 한다.

```c++
wcout << wch << endl;
wcout.imbue(locale("kor"));
```
이러한 유니코드에도 종류가 있는데 대표적인 것이 UTF8, UTF16이다

UTF8의 경우 알파벳, 숫자는 ascii와 동일한 번호로 1 byte를 차지하고, 유럽 지역 문자는 2 byte, 한글이나 한자 등은 3 byte를 차지한다. UTF16의 경우 알파벳, 숫자, 한글, 한자 등 대부분 2 byte를 차지하며 매우 예외적인 극소수의 고대 문자만 4 byte를 차지한다. 따라서 영어권 지역 및 유럽 대상으로 퍼블리싱 할 것이라면 UTF8, 아시아권으로 퍼블리싱 할 것이라면 UTF16이 효율적일 것이다.

<br/>

**3) Escape Sequence**

|문자|ascii code|의미|
|-----|----|----|
|\0|0|null, 문장 종료|
|\t|9|tab|
|\n|10|line feed|
|\r|13|carriage return (커서 <<) |

그 외에도 작은 따옴표를 적을 때 역시 \를 붙이면 된다. 얘를 들면 아래와 같다.

```c++
char ch0 = '\'';
```

<br/>

**4) 문자열**

문자들을 열지어 놓은 것. 아래와 같이 선언한다. 

```c++
char str0[] = {'h','e','l','l','o', '\00'};
char str1[] = "hello";
wchar_t str2[] = L"hello";
```

문자 하나하나 넣을 경우 문자열이 끝남을 의미하기 위해 맨 마지막에 \00을 붙여야 한다. 큰 따옴표를 사용하면 문자열로 인식하여 c++이 자체적으로 \0을 넣어준다. 따라서 글자 수는 5개로 보이지만 실제로는 문자 6개 크기의 배열이 된다. 

<br/>

## **4. 타입 변환**

타입 변환 시, 변환하기에 너무 큰 데이터를 형변환 하게 되면 윗쪽 비트 데이터가 짤린 상태로 저장이 된다. 예를 들자면 아래와 같다.

```c++
int hp = 77777;
short hp2 = hp; 
```

이런 상황에서 hp2는 상위 비트가 잘린 결과물인 12241가 된다.

또, signed 변수를 unsigned로 넣을 경우에도 예상치 못한 값이 나올 수 있다. 예를 들자면 아래와 같다.

```c++
int hp = -1;
unsigned int hp2 = hp; 
```

이와 같은 상황에서 hp2는 4294967295와 같은 값이 나온다. 최상위 비트를 부호가 아닌 값으로 인식하기 때문에 생기는 일이다. 

따라서 타입 변환 시에는 값이 예상하지 않은 방향으로 변하지 않도록 유의해야 한다. 

또, 나눗셈을 진행할 때 int로 int를 나누면 값이 소수점을 버린 int로 저장된다. 나누는 값, 나누어지는 값 둘 중 하나를 float으로 만들어준 뒤 연산해야 float로 값을 얻을 수 있다. 

<br/>

## **출처**

[C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈] Part1: C++ 프로그래밍 입문, Rookiss

