---
title: Procademy, Q1, 05) C - 함수
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 함수의 동작 방식**

## **1) 함수가 사용하는 영역**

지역 변수는 stack에, 명령어는 code에 저장된다. 이때 stack과 code는 아예 분리된 영역이다. 실제로 코드 실행은 ip 레지스터가 가리키는 명령어를 실행하는 것 뿐이므로 stack이 깨져도 명령어 동작 및 수행은 계속 할 수 있다.  

## **2) 증분 링크**

이때 디버그 모드로 켜면 바로 함수를 호출하지 않고 jmp를 거쳐서 실제 함수로 이동하는 것을 볼 수 있다. 이를 증분 링크 사용이라고 한다. 속상 제어자 링커 - 일반에서 없앨 수 있다. 증분 링크는 빌드가 될 때마다 링크에 드는 시간을 줄이기 위해 사용하는 것이다. 디버그 모드에서는 빌드되는데 걸리는 시간을 단축시키는 것이 중요하고, 반면 릴리즈 모드에서는 빌드 시간은 상관없이 성능을 향상시키는 것이 중요하기 때문에 디버그 모드에서만 포함된다. 그럼 증분 링크를 사용하면 왜 시간이 단축될까?

우선 증분 링크가 없는 예시를 보자 

```c++
int main()
{
    A();
    B();
    C();
}

void B()
{
    A();
}

void C()
{
    A();
}   

void A()
{
    
}
```

원래 이 상태에서 빌드를 했는데, 이 중 A()에 해당하는 코드를 수정하여 A()의 크기가 변했다. 그렇게 되면 A()만 새로 컴파일하면 되겠지만 실제로는 다른 함수들의 위치도 다 밀리게 된다. 만약 A()라는 함수의 주소를 여러 함수에서 100번 호출하고 있다면 그 100군데의 코드를 모두 고쳐야하는 셈이다. 따라서 새로 컴파일 과정이 들어가고, 링크시간이 오래 걸리게 된다. 

반면 증분 링크의 경우 존재하는 모든 함수들을 jmp로 한곳에 모아둔다. 그리고 해당 함수를 호출했을 때 그 위치로 가서, jmp를 시키게 된다. 이렇게 될 경우 함수를 하나만 수정했다면 그 함수를 가리키는 주소만 증분 링크에서 수정해주면 된다. 이 경우 불필요한 컴파일 과정을 줄일 수 있는 반면 모든 함수가 호출 될 때마다 한단계를 더 거치기 때문에 성능에서는 손해를 본다. 

<br/>

# **2. Stack이 망가진 상황**

## **1) 함수가 돌아오는 위치를 기억하는 법**

함수의 call은 사실 eip, esp를 변경하라는 명령어이다. call을 실행하면 기존 함수의 ip의 바로 다음줄 명령어, 즉 call 한 후 돌아가야 하는 위치를 stack에 push하고 (ret 했을 때 ip가 들어가야 하는 곳) ip를 호출하는 함수의 첫 명령어로 바꾼다. 이 두 가지가 한번에 일어나는 것이 call이라는 명령어가 하는 동작이다. stack frame을 만들기 위해 ebp를 넣는 것보다도 이 동작이 먼저 수행된다.ret이 일어나면 push 했던 주소값을 pop 하여 eip에 다시 넣는다. 그러면 esp는 한칸 낮아지고 eip도 기존에 넣었던 값으로 바뀌게 된다. 그리고 이 상황에서 크리티컬한 문제가 생기기도 한다. ret을 했는데 만약 stack이 깨져있다면 ip에 이상한 값이 들어가게 되는 것이다. 

## **2) Stack이 망가진 상황**

Stack이 망가져서 ip에 이상한 값이 들어가는 경우 어떻게 실행되는지 파악하기 위해, visual studio의 메모리 창에서 메모리 값을 의도적으로 바꾸어 Stack을 망가뜨려보자. ret 직전에 stack에 push 했던 값에 다른 곳에 있는 명령어 위치를 넣어주면 놀랍게도 그 위치에 있는 게 실행된다. 만약 null이나 명령어로 읽을 수 없는 값을 가리킨다면 그냥 crash가 난다. 그리고 확인해보면, 호출 스택과 어셈블리 다 깨져있어서 어디서 에러가 났는지 확인하기 어렵게 되어있다. 이때 esp를 바탕으로 stack이 망가진 코드를 역추적 할 수 있다. 

위에서 언급했듯이 함수를 호출하기 전에는 이번 함수가 끝나면 다음에 실행해야 할 명령어를 stack에 push 한다. 그 후 ip에서 push 했던 값을 불러오게 된다. 만약 ip에 이상한 값이 들어갔다면, ip는 stack에 저장된 값을 불러오기 때문에 Stack에 문제가 있을 가능성이 크다. 또, ip 레지스터 값을 바꾸는 명령은 jmp, ret, call 밖에 없다. 그리고 jmp, call은 모두 컴파일러가 적절하게 제공한 상수값이 들어가있다. 이 중 ret 만이 내 메모리에 있는 값을 참조해서 이동시키게 된다. 고로 stack이 깨진 상황이라면 ret 부분에서 문제가 생길 가능성이 높다. 이때, ret 바로 아래, 미리 push 해뒀던 다음 ip 값을 확인하면 어떤 함수의 내부에서 문제가 터졌는지 추측할 수 있다.

그러므로 ret을 했는데 엉뚱한 주소가 나왔고, 호출 스택도 볼 수 없다면 esp를 통해 마지막 stack을 살펴보자. esp는 상대적인 연산으로만 이동하지 사용자가 esp를 대상으로 mov 와 같은 연산을 할 수 없다. 따라서 사전에 ebp가 오염된 상태에서 상대 연산으로 이동한 상태라면 esp도 근거 삼을 수 없지만, 그런 상황이 아니라면 추적의 근거로 쓸 수 있다. 현 esp 위치에서 한 칸 위를 보자. 거기에 에러창에 뜬 주소와 동일한 값이 있는가? 그렇다면 이 함수를 return하다가 문제가 생겼을 것이라 추측할 수 있다. 그럼 내가 찾고자 하는 문제의 함수 A를 호출하고 있는 이전 함수를 찾아낼 수 있다. 

요약하자면, 

```c++
void A()
{
	B();
}

void B()
{
	C1();
	C2();
	C3();
}
	
```
만약 C1, C2, C3 중 문제가 있다면, C1, C2, C3 중 누가 문제를 냈는지 알 수 없지만 B 에 대한 정보는 stack에서 확인할 수 있는 셈이다. 이러면 추적 범위를 줄일 수 있다. 

code의 주소는 stack의 주소와 조금 동떨어져있다. 그러므로 stack을 봤을 때 코드 주소처럼 생긴 값, 혼자만 약간 값이 멀리 있는 값을 디스어셈블리에 검색해보면 함수 이름이 나오게 된다. 참고로 stack 주소를 디스어셈블리에 검색해도 어셈블리어가 출력된다. 그러나 이건 stack 주소를 어셈블리어로 번역한 결과물이지 실제로 동작할 수 있는 정상적인 어셈블리어가 아니다. 따라서 검색했을 때 call 함수 이름이 있는지 확인해야한다. 주소를 검색해봤을 때 해당 명령어가 call 함수 이름 바로 다음 값이라면 그 함수 안에서 문제의 함수가 호출되고 있다는 것을 알 수 있다. 

여기까지 범위를 좁혔다면, 이제는 stack을 이용해 더 이상 범위를 좁힐 수는 없다. 그래서 일반적으로는, 다음에 같은 에러가 터졌을 때 해결의 실마리를 잡을 수 있도록 문제 상황을 추적, 감지하는 코드를 미리 입력해두고 다음에 같은 에러가 터졌을 때 해결하게 된다. 그래서 자주 발생하지 않는 에러는 고치는데에 6개월 이상의 장시간이 걸리기도 한다. 참고로 ip가 가리킨 값이 교묘하게 어떤 함수였다면, crash를 내지 않고 엉뚱한 함수를 호출하거나 상황이 안좋으면 무한 루프에 빠지기도 한다. 상황이 안좋을 경우 그냥 아무 증거 없이 하나하나 검토해야 하는 상황도 생기니 주의해야 한다. 

이 경우 보통 아래와 같은 방법으로 에러를 추적한다. 

**1.** 로그: 좋은 방법이지만 서버코드에서는 로그의 양이 너무 많아질 수 있으니 적당히 사용해야 한다. 

**2.** 변수: 지역 변수를 하나 심어서 구역마다 다른 값을 보유하게 하면 어디까지 진행됐는지 볼 수 있다. ++도 괜찮고, 값을 직접 지정하는 것도 괜찮다. 

하지만 그렇게 해서 어떤 함수가 문제였는지 알게 되었다해도 그 함수 안에서 정확히 어디가 문제인지는 알기 어렵다. 문제가 되는 시점에서 터지는 게 아니라 ret 시점에서 터지기 때문이다. 따라서 터진 데이터 인근이 변화하는 것을 감지하는 코드를 심을 수 있다. 지역변수 포인터로 ip 위치를 감시하면서 언제 값이 변하나 확인하는 것이다. 한줄한줄 체크해서 일부러 변했을 때 crash 되도록 수정한 뒤, 거기까지의 메모리 덤프를 뽑으면 정확히 어디서 문제가 생겼는지 알기 쉬워진다.

## **3) 어떤 상황에서 Stack이 망가지나**

이런 문제는 포인터를 사용했을 때 주로 발생한다. 코드로 예시를 들어보자. 

```c++
#include <iostream>
void Test()
{
	int* p;
	int x = 0;
	p = &x;
	p[0] = 0;
	p[1] = 0;
	p[2] = 0;
	p[3] = 0;
}
void Test2()
{
	Test3();
}
void Test1()
{
	Test2();
}
int main()
{
	Test1();
}
```
이렇게 만들면 아쉽게도 cookie가 오버런을 감지했다고 에러를 띄워주게 된다. cookie가 무엇인지 어셈블리에서 확인해보면, 현재 stack frame에서 old ebp를 push한 것 위에 cookie가 올라가 있다. 값을 보면 security cookie와 ebp를 xor한 값임을 볼 수 있다. 함수 종료 이전에 다시 xor 후 cmp로 저 cookie가 깨지는지 아닌지 관찰하기 위해 있는 것이다. 만약 ebp 혹은 cookie 값이 오염되었다면 xor 후 원래 값으로 돌아오지 못하므로, 이런 원리로 깨지면 에러를 내고 중단하게 된다. 한마디로 underflow를 감시하기 위한 컴파일러의 안전장치이다. 참고로 속성에서 보안 검사 옵션을 끄면 이 cookie가 사라지게 된다. 

그럼 이번에는 의도적으로 cookie와 ebp를 건너뛰고 stack에 있는 ip을 건드려보자.

```c++
void Test3()
{
	int* p;
	int x = 0;
	p = &x;
	*p = 0;
	p++;
	p++;
	p++;
	*p = 0;
}
```
이 경우 아래와 같이 에러가 뜨게 된다. 

![vs](https://user-images.githubusercontent.com/96677719/213334744-52e3aa0d-05e1-4c7b-af78-be4f4d2882a9.png)

차라리 이 경우에는 어떤 값이 들어가있는지 확인할 수 있다. 그러나 아래와 같은 경우엔 상황이 더 안좋다. 

```c++
void Test3()
{
	int* p;
	int x = 0;
	p = &x;
	*p = 0;
	p++;
	p++;
	p++;
	*p = -30;
}
```

이렇게 하면 코드가 밀려버린다. 그러면 위의 명령어는 해석이 안돼서 ???로 뜨고, 이상한 명령어를 가리키게 된다. 그 자리에 있던 코드를 어떻게든 어셈블리로 해석해서 만들어낸 엉뚱한 코드인 것이다. 만약 우연히 그 자리에 다른 크리티컬한 함수가 있었을 경우 더 큰 문제가 생길 수 있다. 

<br/>

# **3. 함수의 return**

## **1) return을 하지 않았을 경우**

기본적으로 return 값은 eax를 통해 전달된다. 
```c++
int Test1
{
	int flag = 0;
	if (flag == 1)
	{
		printf("sss");
		return 1;
	}
	printf("fff");
}


int main
{
	int x = Test();
	if (x == 0)
	{
		printf("main");
	}
}
```

위와 같이 실수로 return 하지 않는 함수를 만들 경우, 그냥 eax에 남아있던 값이 반환되게 된다. 즉 쓰레기 값이 나올 수도 있는 것이다. 저 상황에서는 1이 나올 확률이 높다. printf도 일종의 함수인데, return 할 때 eax에 1을 넣기 때문이다. (참고로 내가 실행했을 때는 4가 나왔다)

## **2) return 과정에서 생기는 일**

구조체를 통으로 return 하는 것은 옳지 못한 방법이다. 구조체 반환이 필요하다면 call by reference, 레퍼런스로 받아서 값을 되돌려주는 방식으로 해야한다. 그 이유는, 거대한 구조체나 클래스를 반환할 경우 mov를 멤버 변수 개수만큼 반복하며 하나하나 값 복사를 발생시키기 때문이다. 

```
lea eax, ebp - 388h
push eax
call Test()
```

위처럼 파라미터가 없어도 컴파일러가 자동으로 파라미터를 만들어서 push 하는 것을 볼 수 있다. ebp + 8은 파라미터로 들어온 주소로, 이 값을 복사한다. stack frame 특성상 +가 나오면 프레임 바깥이며 이 상황에서는 파라미터라고 해석할 수 있다. 그리고 또 여기서 결과 값을 복사하여 반환한다. 그리고 함수 밖에서 또 반환한 값에 대한 복사가 일어난다. 요약하자면 함수가 시작할 때 한 번, 끝날 때 두 번 값 복사가 일어나는 것이다. 물론 최적화 컴파일러를 하면 사라지긴 하지만 되도록 이런 방법은 사용하지 않는 것이 좋다. 

<br/>

# **QnA**

### **Q. 함수 반환 후 ip 주소에 넣을 값은 항상 ebp + 4에 저장되나요?**

32bit Windows에서는 ebp + 4 지점에 eip 를 위한 값이 있을 가능성이 높다. 하지만 이건 호출 규약일 뿐, 호출 규약에 따라, 컴파일러 설정에 따라 다를 수 있다. 참고로 64bit의 경우 속도를 높이기 위해 레지스터를 직접 활용하는 방식을 쓰기 때문에 위와 다를 수 있다. 이러한 방식은 고정된 것이 아니니 어셈블리어를 직접 해독해보는 것이 좋다.  

### **Q. 왜 함수 끝나는 영역 뒤쪽에 int 3이 있나요?**

그냥 남는 공간을 밀어준 것. nop로 밀어 두는 경우도 있다.

### **Q. 전역변수를 동적 할당 했을 때는 어떻게 추적할 수 있나요?**

런타임 시에 바뀐 것이기 때문에 메모리 덤프만으로는 찾기 어렵고 추적할 수 있는 코드를 추가해야된다. delete 자체를 오버로딩 해서 할당한 포인터를 하나하나 조회한다던가… 성능은 떨어지겠지만 이렇게 해서 특징과 크기를 비교한다면 상대적으로 빨리 발견할 수 있다. 
