---
title: Procademy, Q2, 32) Network - 채팅 서버
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 기본 설명**

닉네임 입력, 채팅방 생성, 방 별 채팅 및 인원 확인 기능이 있는 select 모델의 채팅 서버. 싱글 스레드로 64명 이상 처리할 수 있도록 설계한다. 방 생성과 입장은 분리되어 있으며 마지막 사용자까지 방에서 나가야 방이 삭제된다. 따라서 누군가 들어갔다가 나가지 않는 이상 비어있는 방 목록이 남아있다. 

<br/>

# **2. 요청 - 응답 구조**

**방법 1**

```
CS 로그인 요청 (닉네임)
SC 로그인 요청에 대한 결과 (중복, 길이 초과 등에 대한 결과 송신)
SC 방 목록 요청에 대한 결과 
```

**방법 2**

```
CS 로그인 요청 (닉네임)
SC 로그인 요청에 대한 결과 (중복, 길이 초과 등에 대한 결과 송신)
CS 방 목록 요청
SC 방 목록 요청에 대한 결과 
```

클라가 접속하자마자 서버가 필요한 데이터를 보내는 방법과 클라가 요청했을 때 서버가 데이터를 보내는 방법 두 가지가 있다. 송신되는 메시지의 수는 전자가 더 적지만 실제로는 후자가 더 일반적이다. 후자 방식의 경우 새로고침에도 적용할 수 있기 때문이다. 함수를 만들 때 독립적 활용을 고려해서 최대한 종속을 끊어내는 것과 동일한 맥락이다. 방 생성 요청에 대한 결과는 성공한 경우 모든 유저에게, 실패한 경우 요청자에게 응답을 보낸다. 
 
이떄 모든 요청에 검증하는 코드가 다 들어가야 한다. 중복 닉네임 같은 컨텐츠를 위한 안전 장치 뿐 아니라, 해당 플레이어의 상태를 파악하여 이미 연결된 세션인지 아닌지, 채팅과 퇴장의 경우 해당 방에 속한 게 맞는지 등을 부가적으로 검증해야 한다. 이런 검증에서 걸린다면 조작된 메시지이므로 해당 유저의 연결 자체를 끊어야 한다. 

<br/>

# **3. 참여자 관리**

채팅방 참여자를 관리할 때는 유저 고유 번호 리스트를 들고 있다가 검색하는 방법과 아예 클라이언트 포인터를 들고 있는 방법이 있다. 번호로 관리할 경우 send 할 때마다 검색이 들어가기에 다소 느리지만 더 안전하게 사용할 수 있고, 포인터를 드는 경우 성능에는 좋지만 실수로 클라이언트를 건드릴 가능성이 있다. 빈 방일 경우 방 번호로 ffffffff, 0, -1 같이 나올 수 없는 수를 들거나, 방 자체를 포인터로 들고 nullptr을 쓰는 등으로 처리할 수 있다. 

유저 관리에는 보통 unordered map을 많이 사용한다. 서버에서는 정렬 기능이 많이 사용되지 않고, 현재 stl이 제공하는 자료구조 중 탐색, 삽입이 가장 빠르기 때문이다. 이 경우 key를 어떤 것으로 할 지는 어떤 소켓 모델을 쓰는지, 어떤 로직을 갖고 있는지 등을 고려하여 결정해야 한다. 예를 들어 AsyncSelect를 쓴다면 네트워크 메시지로 반응이 왔을 때 소켓 하나가 주어지기 때문에 key를 소켓으로 하는 게 유리할 수 있다. 반면 select는 순회를 하면서 CLIENT ptr에 접근한 상태로 작업이 이루어지므로 굳이 소켓으로 검색할 필요가 없다.

로직이 없고 네트워크 송수신만 있는 경우 select에 무한 대기를 거는 게 오히려 낫지만, 이 경우 싱글 스레드로 64명 이상 처리하는 것을 목표로 하기 때문에 대기 없이 계속 loop를 돌려야 한다. FD_SET을 할 때마다 소켓의 개수를 세다가 64 이상이 되면 select를 호출한다. 이때 만약 접속자가 6400명이라면 select를 100번 호출해야 되는데 그 과정 사이에 listen socket을 또 호출할 수도 있다. accept가 많이 느려지면 backlog Queue가 차면서 connect 실패를 할 수 있기에 이에 대비하는 것이다. 

send에서 would block이 뜬다면 바로 Disconnect 해도 괜찮다. 서버에서 송신측 송신버퍼가 다 찬 상황까지 굳이 확인하지 않아도 된다. recv 시 패킷 코드가 다르거나, 체크섬이 안 맞는 경우에도 잘못된 패킷으로 보고 Disconnect 해야 한다. 또, MMO에서 Broadcast로 송신할 경우 send를 호출하는 대신 직렬화 버퍼에 넣더라도 목적지가 많기 때문에 프레임이 떨어질 수 있다. 따라서 보내야할 유저를 스냅샷처럼 저장했다가 보내거나, 처음부터 이걸 고려한 자료구조를 사용하는 등의 방법으로 여러 프레임에 분산하여 전송해야 한다. 

<br/>

# **4. 스트레스 테스트**

이 채팅 서버는 에코를 통해 스트레스 테스트를 진행할 것이다. 에코 테스트의 경우 에코 한번 보내고 그에 대한 에코 응답이 오면 다음 에코를 보낸다. 에코 응답의 경우 받은 내용을 그대로 직렬화 버퍼에 넣어서 전송한다. 클라 측에서는 보냈을 때와 동일한 응답이 왔는지 체크하여 확인한다. 이를 통해 초당 처리되는 메시지 수와 Latency 등을 파악할 수 있다. Connect Try, Connect Fail, Connect Success, Latency, Recv Count, Error Count 등을 기록하는 것이 좋다. Success가 Try에 비해 낮게 나온다면 Accept가 느린 것으로 볼 수 있다. Error Count는 메시지가 잘못되었다는 뜻이므로 뜨면 안된다. 

보통 개발 초기에는 콘솔 창을 메시지가 제대로 송수신 되는지 확인하는데 사용하고, 안정된 이후에는 주기적으로 접속 수, 초당 처리되는 메시지 수 등 서버의 상태를 확인하는데 사용한다. 일반적으로는 pps (packet per sec), tps (transaction per sec), accept per sec 등을 기록하지만 콘텐츠에 따라 생성된 방의 개수와 로비에 몇명이 있는지 등을 추가로 출력할 수도 있다. 보통 초당 전송량은 회선 계약 때 참고하기 위해 측정하는데 L7에서 측정할 수 밖에 없다보니 L3, L4 헤더까지 반영할 수 없다는 한계가 있다. 반면 이더넷 측정은 모니터링 서버 등 다른 데이터가 섞여서 부정확하다는 한계가 생긴다. 따라서 프로그램과 이더넷 두 군데에서 다 측정한 후 각각의 특징을 고려하여 추정한다. 


