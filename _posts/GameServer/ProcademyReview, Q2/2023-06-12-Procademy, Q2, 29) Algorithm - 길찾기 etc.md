---
title: Procademy, Q2, 29) Algorithm - 길찾기 etc
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 길찾기 설정값**

최적해를 구할 때 깊이 우선 탐색은 일단 선택된 방향으로 쭉 가는 것을, 너비 우선 탐색은 길을 넓히면서 가는 것을 의미한다. g, h의 가중치를 0으로 두고 처음 OpenList에 넣은 노드를 처음 탐색하는 걸로 설정한다면 너비 우선 탐색이 되므로 최적의 길이 나온다. 반면 마지막에 넣은 노드를 처음 탐색하는 걸로 한다면 깊이 우선 탐색이 되므로 언젠가 길은 나오지만 최적의 길이 아닌 결과가 나온다. 보통 그래프와 같이 경로가 제한적일 때 깊이 우선 탐색을 쓰기도 하는데, 길찾기는 경로 경우의 수가 워낙 많다보니 매우 비효율적인 결과가 나온다. 같은 이유로 큐 방식을 사용하면 자연스레 주변부터 탐색이 되므로 너비 우선, 스택 방식은 최근에 넣은 것들이 탐색되므로 깊이 우선이 된다. 

g, h 둘 다 유클리드로 설정하면 길 탐색이 방사형으로 점차 확대된다. 반면 g를 유클리드, h를 맨하탄으로 하면 대각선으로 갈 때 h가 -2씩 줄어들기 때문에 대각선 방향으로 먼저 탐색하게 된다. 따라서 g에서는 유클리드를 쓰고, h를 맨하탄으로 쓰는 게 일반적이다. 물론 둘 다 유클리드로 설정하여 방사형으로 탐색하더라도, 탐색에 걸리는 시간이 늘어나는 것 뿐이지 최종 경로는 최단 거리로 유사하게 출력이 된다. 둘 다 유클리드를 쓰되 h에 가중치를 더 줘서 대각선을 우선 탐색하는 방법도 있다. 그러나 이 경우 깊이 우선 탐색이 되기 때문에 노드 생성은 줄어들겠지만 최적의 길을 찾지 못할 수 있다. 

<br/>

# **2. 길 보정**

3D 게임은 길찾기 노드로 폴리곤 메쉬를 많이 사용하는데, 이 경우 면의 중심을 기준으로 이동하게 되면 경로가 이상해진다. 따라서 길을 찾은 이후에 추가적인 보정이 필요하다. 이 경우 특정 노드 없이 직선을 그었을 때 장애물과의 충돌이 없는지 파악하여 없애도 되는 노드를 없애는 방식을 택할 수 있다. 이를 반복하면 최단 거리 보정을 할 수 있게 된다. 시작점부터 혹은 도착점부터 점점 확대할지, 시작점 - 도착점을 그어서 하나씩 좁힐지에 따라 조금 다른 결과가 나올 순 있지만 최적의 길을 찾기 위함이 아니라 자연스러운 이동을 위한 것이므로 어느쪽이든 크게 상관은 없다.

이때 장애물과의 충돌 체크를 하려면 선 상 좌표들의 속성을 파악해야 한다. 이런 용도로 쓸 수 있는 대표적인 알고리즘으로 브레즌햄 알고리즘이 있다. 이때 브레즌햄으로 구현한 선과 Line To로 그은 선이 달라서 Line To 기준으로는 충돌하지만 브레즌햄 기준으로는 충돌하지 않을 수도 있다. 이는 둘의 해상도가 달라서 생기는 상황이지 문제 상황은 아니다. 실제 3d 게임이라고 한다면, 클라가 독자적으로 충돌 처리를 하기보다는 벽을 뚫고서라도 이동해야 한다. 서버와 클라, 클라와 타 클라는 완벽하게 동기화가 될 수 없기 때문에 클라에서 독자적으로 충돌 처리를 할 경우 클라이언트 별로 다른 결과가 뜰 수 있다. 그러니 서버로부터 온 위치 데이터는 충돌 처리 없이 따라야 한다. 

<br/>

# **3. 결과물 전달 방법**

Line(StartPos, DestPos) 와 같은 함수가 있을 때, 결과물을 여러가지 방법으로 전달받을 수 있다. 클래스 내부에 결과 배열을 저장하고 GetResult 등으로 그 배열의 시작 주소를 가져올 수도 있고, 포인터와 개수를 매개변수로 전달해서 가져올 수 있도록 할 수도 있다. 혹은 내부에서 동적할당을 하고 외부에는 iterator만 주는 방식도 있다. 이때 길찾기 결과의 경우 캐릭터 객체 안에 있는지, map 객체 안에 있는지, 스레드 단위로 있는지 등에 따라  달라질 수 있으니 상황에 맞게 설계해야 한다. 

<br/>

# **4. 알고리즘과 Map의 연계**

길찾기 알고리즘 클래스를 독립적으로 만들어서 다용도로 쓸 수 있게 하려면, Map의 속성은 알고리즘 클래스의 관리 대상으로 두어서는 안된다. Map은 컨텐츠 요소이므로 계속 바뀔 수 있기 때문이다. 성능을 위해서는 알고리즘 클래스가 Map을 들고 있는 게 좋지만 이 경우 런타임에서의 즉각적인 교체가 힘들어진다. 이렇게 되면 맵 별로 알고리즘 클래스가 나올 수 밖에 없다. Map과 알고리즘 클래스를 연계할 땐 함수 포인터로, Interface 클래스 등을 사용해야 한다. Interface 클래스를 쓸 경우 성능 저하가 생기며 inline도 쓸 수 없게 된다는 단점이 있다. 또, CheckObstacle 함수에서 template을 사용하는 방법도 있다. 이 경우 디버깅은 다소 어려워지지만 compile시에 데이터가 정해지므로 런타임에서 느려지지지 않는다. 
