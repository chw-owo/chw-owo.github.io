---
title: Procademy, Review 03) C++ 기초 (1)
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---
## **0. Intro**

**-** 23.01.13 ~ 수업 정리

**-** C++을 단순히 복습하기 보다는, 어셈블리어로 분석하면서 내부적으로 어떻게 동작하는지 알아보는 시간

<br/>

## **1. 자료형**

![image](https://user-images.githubusercontent.com/96677719/212548759-e9c24582-2dd0-4672-a7cc-84f886fffbd1.png)

**1) 기억 클래스**

**auto**

여기서 auto는 C++11에서 도입된 auto가 아니라 C언어에서부터 있었던 auto이다. 변수의 메모리 위치를 컴파일러에게 알아서 지정하라고 맡기는 것을 의미한다. 위험성이 있기에 사실상 사용하지 않는다. 

<br/>

**register**

해당 변수를 register에 올릴 수 있다면 올리라는 것을 의미한다. 최적화 컴파일을 켜면 해주기도, 안해주기도 하며 최적화 컴파일을 끌 경우 아예 작동하지 않는다. 위험성이 있기에 사실상 사용하지 않는다. 

<br/>

**static**

.data 영역에 변수를 올려서 해당 함수가 끝나도 값이 유지되도록 하는 것을 의미한다. 지역 static의 경우 선언된 함수에서만 사용 가능하고, 전역 static의 경우 선언된 소스 파일 안에서만 사용 가능하다. 외부 함수, 외부 소스 파일에서 접근할 수는 없다. C++은 클래스 단위로 코드를 구성하지만 C언어의 경우 파일 단위로 구성하는 경우가 많아서 static의 역할이 더욱 강조된다. 

<br/>

**extern**

static과 달리 외부 소스 파일에서도 접근할 수 있는 것을 의미한다. 여러 소스 파일에서 접근 가능한 변수를 선언할 때 사용한다. 

<br/>

**2) 속성 수식자**

**const**

constant의 약자로, 상수처럼 쓰이는 변수를 의미한다. #define으로 선언한 상수와 달리 데이터 타입을 가지며, 일반 변수와 달리 초기값 이외의 값으로 변경될 수 없다. 전역 상수로 정의될 경우 .data에, 지역 상수로 정의될 경우 stack에 저장된다. const는 완벽한 상수가 아니므로 컴파일 시에 값을 읽을 수 없어서 배열의 크기 값으로 사용할 수 없다. 

**volatile**

volatile은 휘발성을 갖는다는 의미로, 쉽게 변할 수 있어서 확인이 필요한 변수를 의미한다. 최적화 컴파일 과정을 거치게 되면, 변수 중 상당수를 확인할 수 없게 된다. 값이 예측하기 어렵게 변해서 디버깅 시에 확인이 반드시 필요한 변수도 날릴 수 있는 것이다. 이에 대비하여 "이 변수를 최적화 하지 말아라", "없애지 말고 이 변수에 대한 연산을 다 살려라"라는 목적으로 volatile 수식자를 쓰게 된다. 만약 최적화 컴파일을 끄고 작업한다면 굳이 붙일 의미가 없는 수식자이다. 

인터넷에 검색을 하다보면 "volatile을 쓰면 cache를 쓰지 않고 실제 메모리에 접근한다. 따라서 동기화 문제를 해결하기 위해 volatile을 써야 한다"는 얘기를 접할 수 있다. cache라고 하면 cpu 옆에 붙어있는 cache 메모리로 이해하기 쉬운데, 여기에서 cache는 그 cache가 아니다. 여기서 cache는 컴파일러의 cache를 사용하지 않는다, caching된 데이터(최적화된 데이터)를 사용하지 않는다는 이야기이다. cache 메모리와 volatile은 전혀 관련이 없다. 코드로 예시를 들어보자

```c++
int a;
a = 10;
a++;
int b = a
```
이를 어셈블리로 하면
``` 
…
mov eax, [a]
add eax, 1
mov [a], eax

mov eax, [a]
mov [b], eax
```
이렇게 되는데 이걸 최적화 하면 아래와 같이 표현할 수 있다. 
``` 
…
mov eax, [a]
add eax, 1
mov [a], eax

; mov 	eax, [a] 	생략 가능
mov [b], eax
```

이 상황에서 eax는 컴파일러 관점에서 cache된 데이터가 되는데 여기서 cache는 이것을 의미하는 것이다. cache 메모리를 통하지 않고 메모리를 물리적으로 직접 접근한다는 의미가 아니니 헷갈리지 않게 유의해야 한다. 또 다른 예시를 들어보자.

```c++
void test
{
int a = 0;
if(a == 0) printf(“aa”);
}

int main()
{
test();
return 0;
}

```

최적화 컴파일러를 켜고 위 코드를 실행하게 되면, a도 if도 사라지고 printf(“aa”);가 인라인 처리된다. 이때 a를 volatile로 선언하면 최적화 컴파일러가 켜져있음에도 a, if 둘 다 남아있게 된다. 그래도 인라인 처리는 그대로 유지될 가능성이 높다. 그건 volatile이 영향을 주지 않는다.

<br/>

**volatile은 어떤 상황에서 주로 사용되나요?**

최적화 컴파일을 켜면 필요 없는 변수가 사라지기 때문에 그 변수에 어떤 값이 들어있었는지 확인할 수가 없다. 그러면 서버에서 문제가 생겼을 때 의심되는 변수들을 volatile로 바꿔놓으면, 다음번에 같은 문제가 또 터졌을 때 확인할 수 있게 된다. 최적화 컴파일을 꼭 써야되는데 디버깅이 필요하다면, 일부러 volatile 변수를 확인용으로 심어서 어셈블리로 확인할 수 있다.

특히, 멀티스레드 작업 시에는 volatile을 잘 활용하는 것이 필요하다. 최적화 컴파일러는 여러가지 기능이 동시에 돌아갈 것을 고려하지 않고, 함수 하나하나만 바라보면서 자신이 효율적이라 생각하는 방향으로 코드의 순서를 뒤집는다. 멀티스레드로 작동하게 되면 이러한 최적화가 코드에 영향을 크게 끼칠 수 있기 때문에 volatile을 붙이는 것이 좋다.

<br/>

**3) 부호 수식자**

**signed**

맨 앞 bit를 부호 bit로 사용하는 변수를 의미한다. 

<br/>

**unsigned**

맨 앞 bit를 부호 bit가 아닌, 값 bit로 사용하는 사용하는 변수를 의미한다. 

<br/>

**4) 크기 수식자**

크기 수식자에 대한 설명은 LLP64/IL32P64, Windows를 기준으로 한다.

**short**

4 byte int 앞에 붙어서 2 byte int를 나타낸다. int는 생략 가능하기 때문에 short만 단독으로 선언되기도 한다. 

<br/>

**long**

4 byte int 앞에 붙어서  4 byte int를 나타낸다. int는 생략 가능하기 때문에 long만 단독으로 선언되기도 한다. long의 경우 LLP64/IL32P64 데이터 모델에서는 값이 변하지 않지만 다른 데이터모델에서는 크기가 늘어나기도 한다.

<br/>

**long long**

4 byte int 앞에 붙어서  8 byte int를 나타낸다. int는 생략 가능하기 때문에 long long만 단독으로 선언되기도 한다. 

<br/>

**4) 기본 자료형**

**자료형 별 크기**

자료형에 대한 기본적인 설명은 [C++, 자료형 1) 기본 자료형](https://chw-owo.github.io/cpp/C++,-%EC%9E%90%EB%A3%8C%ED%98%95-1\)\-%EA%B8%B0%EB%B3%B8-%EC%9E%90%EB%A3%8C%ED%98%95/) 포스트 참조. 이에 더해 운영체제, 데이터 모델 별 자료형 크기에 대해서도 숙지하고 있는 것이 좋다. 

|자료형|32bit|64bit, Window(LLP64)|64bit, Unix(LP64)|64bit, ILP64|
|-----|-----|--------------------|-----------------|-------------|
|char|1 byte|1 byte|1 byte|1 byte|
|short|2 byte|2 byte|2 byte|2 byte| 
|int|4 byte|4 byte|4 byte|8 byte|
|long|4 byte|4 byte|8 byte|8 byte|
|long long|8 byte|8 byte|8 byte|8 byte|
|float|4 byte|4 byte|4 byte|4 byte|
|double|8 byte|8 byte|8 byte|8 byte|
|pointer|4 byte|8 byte|8 byte|8 byte|

데이터 모델 이름의 경우, 64bit에 해당하는 자료형의 약자이다. 보통 Unix계열은 LP64를, Window 계열은 LLP64를 채택하고 있으며 ILP, SIILP는 잘 사용하지 않는다. 운영체제에 따라, 데이터 모델에 따라 자료형의 크기가 달라지는 경우가 있으므로 네트워크 관련 프로그램을 만들 때는 long 대신 byte 단위로 만들어주는 것이 좋다. 또, Unity, Unreal과 같이 특정 엔진을 사용할 때도 플랫폼 상관없이 다 사용될 수 있도록 고려하여 만들어주어야 한다. 이러한 문제를 해결하기 위해 일부 회사에서는 아래와 같이 typedef를 사용하기도 한다. 

```c++
typedef int SI32;
```
int, long 같은 자료형을 쓰는 대신, 모든 type에 대해 unsigned/signed, byte 수 등에 대해 명시를 하여 문제를 막는 것이다.

돈이나 경험치, 조회수 같은 건 오래 운영하면 초과할 수 있기 때문에 64bit로 하는 것이 좋다. Youtube에서 강남스타일 조회수가 음수가 되었던 사건 역시 그 정도 조회수가 나올 것이라 예상하지 못해서 overflow 문제가 발생했던 것으로 추정된다. 

<br/>

**음수 표현**

컴퓨터에서는 음수를 2의 보수로 표현한다. 이때 보수란 보충해서 채워지는 수를 의미한다. 예를 들어 3에 대해서 10의 보수는 7이며, 2진수 1에 대해서 2의 보수는 1일 것이다. 양수일 때의 숫자를 반전한 후, 그에 1을 더하는 방식으로 음수를 표현한다. 이를 응용하여 문제 하나를 풀어보자

```c++
signed char a = 0xA6;
```
이 값을 10진수로 출력하면 얼마가 나올까?

```
0xA6 = 0b 1010 0110
```
우선 0xA6을 2진수로 적으면 1010 0110이 된다. signed char이기 때문에 이 수는 음수이다. 음수라고 가정하고 값을 알기 위해서는 2의 보수를 취했을 때와 반대 과정을 진행하면 된다. 이를 위해 역으로 -1을 뺀다. 
```
1010 0101
```
그리고 역을 취하고 10진수로 얼마인지 구한다. 
```
0101 1010
```
이 수는 양수로 90이기 때문에, 반대로 1010 0110은 -90이 된다.

16진수와 2진수의 변환 정도는 눈에 익어야 이후 수월하게 작업을 할 수 있다. 

<br/>

**문자열**

C++에서 문자열은 < 문자의 배열 + \0(null) > 으로 표시된다. 그러나 이러한 null terminate string은 다소 무식한 방법이다 .기존의 C++은 문자열을 따로 저장할 방법이 없었고, 포인터로 문자를 가르켰기 때문에 이런 방식을 채택하게 되었다. 길이를 따로 저장해서 그만큼만 불러오는 방법도 사용할 수 있다. 네트워크 작업을 하게 되면 접하게 되겠지만, 문자열을 직접 처리할 일이 생긴다면 null terminate를 쓰는 것보다 문자열의 길이를 아는 것이 더 빠르게 처리할 수 있다. 대신 문자열의 길이만큼 메모리를 조금 더 낭비하게 될 순 있다. 실제로 서버 작업을 하다보면 네트워크 회선비를 줄이는 것이 중요한 관건이 되기 때문에 여러가지 요소를 고려하여 상황에 맞는 선택이 필요하다.

<br/>

## **2. 연산자와 수식**

**1) 증감 연산자**
```c++
int main()
{
	int a = 0;
	++a;
	a++;

	return 0;
}
```
대입을 하지 않고 증감만 한다면 전위와 후위 중 무엇이 더 좋을까? 보통 인터넷에 검색하면 전위가 더 빠르다고 나오는 경우가 많다. [클래스에서 연산자 오버로딩](https://chw-owo.github.io/cpp/C++,-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-2\)\-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98-%ED%8A%B9%EC%A7%95%EA%B3%BC-Class-%EC%8B%AC%ED%99%94/) 했던 것을 돌이켜보면 쉽게 이해할 수 있는 답변이다. 후위 연산자의 경우 증감 연산 전의 값을 저장했다가 반환해야 하기 때문에 그 값을 저장하는 과정에서 전위 연산자보다 한단계 과정을 더 거치게 된다. 

그러나 오버로딩한 연산자가 아니라, 일반적인 경우엔 정작 어셈블리어를 까보면 둘이 동일하게 동작하는 것을 알 수 있다. 백업이 필요 없는 상황이기 때문에 컴파일러가 해당 과정을 알아서 제거해주는 것이다. 최적화 컴파일을 해제해도 동일하다. 컴파일러가 순서를 맞출 거기 때문에 추가적인 백업을 위한 공간이 소모되지 않아서 결국 동일한 결과가 나온다. 

오히려 대입하는 상황에서, 값에 대한 결과를 따지지 않는다면 후위 연산자가 더 빠를 수 있다. (물론 이 둘은 다른 기능을 하기 때문에 이렇게 비교하는 것은 조금 이상한 경우이다) 이는 Out of Ordering 때문이다. Cpu는 명령어를 순서대로 처리하지 않는다. 미리 명령어 다 읽은 뒤에 먼저 할 수 있는 게 있다면 먼저 처리하고, 최종적인 반영에 있어서만 순서를 고려한다. 

어셈블리어를 한번 살펴보면, ++a를 보면 add eax, 1이 완료되어야지만 mov dword ptr [b], eax가 이루어질 수 있다. 반면 a++은 논리적으로 보았을 때 그 둘이 별개로 이루어져도 상관이 없다. 따라서 대기 시간이 조금 더 줄어들 수 있는 것이다. 물론 큰 차이는 아니며, 대입 없이 a++, ++a 만 사용할 때는 아예 차이가 없다. 

그러나 차이가 없다는 답변도 컴파일러 따라 달라질 여지는 있다. 그러므로 인터넷에서 찾아보고 의존하기 보다는 되도록 직접 확인해보는 습관을 들이는 것이 좋다. 환경에 따라 다른 답이 나올 수도 있기 때문에, 어셈블리어 독해 능력을 키워야 하는 것이다.

<br/>

**2) 논리 연산자**

**AND** 	

비트 마스킹 할 때, 해당 속성이 있는지 확인하기 위해 주로 사용한다

<br/>

**OR** 	

서로 다른 비트를 합칠 때 주로 사용한다. 

<br/>

**XOR**	

값을 0으로 만들고 싶을 때 주로 사용한다. 복사 연산보다 비트 연산이 더 빠르기 때문에, mov eax 0 보다 xor eax eax를 사용하는 것이 더 성능이 좋다. Toggle이나 Swap할 때나 대소문자 변환을 할 때도 사용할 수 있다. 대소문자가 32bit 만큼 차이 나기 때문이다. 

Toggle/Swap이 가능한 원리는 아래와 같다. 
```
a = 1110 1011
b = 1000 1100

c = xor (a, b)  // = 0110 0111
xor (c, b)      // = 1110 1011 
```
a, b를 xor한 값에 다시 b를 xor하면 다시 a로 돌아오는 것을 확인할 수 있다. xor에는 교환법칙이 성립하기 때문에 반대로 a를 xor 할 경우 b로 돌아온다. 실제로 암호화, 그래픽에서 많이 사용된다. xor을 사용하면 일부만 움직인 상황에서 화면 전체를 렌더링 할 필요 없이 xor 연산만 해주면 되기 때문에 더 효율적으로 렌더링할 수 있다. 

<br/>

**Shift**

<<은 *2, >>은 /2의 효과가 있다. 90년대에는 빠른 연산을 위해 shift로 곱하기, 나누기 연산을 하기도 했으나 요즘은 가독성이 중시되는 시대라 이런 경우는 없다. 곧 죽어도 그렇게 하고 싶다면 주석이라도 다는 것이 좋다. 참고로 최적화 컴파일을 켜면 이것까지 해주는 경우도 있다고 한다. 

주의할 건 signed 변수에 논리 연산을 하는 경우이다. R shift를 할 때 부호 비트가 0이면 0으로, 1이면 1로 채워주기 때문에 비트 플래그로 쓰는 게 목적이라면 unsigned로 선언해주어야 한다. 

<br/>

**3) 삼항 연산자**

가독성이 좋아서 삼항 연산자를 선호한다면 어쩔 수 없지만, 사실 성능을 고려하면 좋지 못한 방법이다. 
```c++
int main()
{
int a= 20;
int b = a > 10 ? 1: 2;
}	
```
위 코드를 어셈블리로 열어보면 아래의 코드와 동일하게 동작한다. 

```c++
int main()
{
int a= 20;
if (a>10)
	int t = 1;
else
	int t = 2;
b = t;
}	
```
b에 바로 값을 넣는 게 아니라 임의의 어딘가에 변수를 넣고, 거기에 값을 넣어서, 그 값을 다시 b에 넣는 과정을 거치는 것을 볼 수 있다. 이로 인해 삼항 연산자가 있으면 stack에서 해당 함수를 호출할 때 더 큰 공간을 잡게 될 가능성이 높다.

<br/>


## **3. 그 외**

**1) 헝가리안 표기**

과거에는 헝가리안 표기를 많이 했는데 요즘은 거의 하지 않는다. 최근에는 컴파일러가 경고도 잘 해주고 마우스 커서만 올려도 확인할 수 있기 때문에 어설프게 쓸거면 안쓰는게 낫다고 하셨다. 이전에 외주했던 곳에서 사용했던 기억이 있어서 많이 쓰는 건 줄 알았는데 꼭 그런 건 아닌가보다.

<br/>

**2) 다중 대입문**

지금처럼 그래픽이 발전하지 않았던 시대에는, 한 화면에 최대한 많은 코드가 보여지게 하는 것이 중요했기에 다중 대입문이 많이 사용되었다. 그러나 요즘은 가독성이 중시되는 시대이기에 굳이 성능상 이점도 없는 다중 대입문을 쓸 이유가 없다. 난해하고 읽기 힘든 코드는 지양하는 것이 좋다. 

<br/>

**3) 반복문**

i, j, k와 같이 의미없는 변수를 쓰기보다는 반복문을 도는 이유를 명시하는 것이 더 좋다.

<br/>

## **Question**

**Q. shift 연산자에 음수를 넣으면 어떻게 되나요?**

shift 연산자 우항에 오는 건 자동으로 unsigned 취급한다. 만약 -3의 의미로 1000 0011이 들어있다면, 이를 양수인 131로 해석하여 그만큼 밀어버린다.

<br/>

**Q. 크기를 초과하는 변수를 넣으면요?**

변수를 쓴다 해도 하위 1byte만 인식하고, 그대로 밀어버린다.  

<br/>
