---
title: Procademy, Q1, 07) C++ - 배열, 구조체 패딩
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 다차원 배열**

## **1) 게임에서의 다차원 배열**

게임에서 충돌 및 위치 탐지를 할 때 매번 수많은 오브젝트들의 좌표를 비교하는 것은 비효율적이다. 따라서 일반적으로 타일 방식, 그리드 방식을 이용하여 충돌을 구현하는데 이때 2차원 배열이 많이 사용된다. 오브젝트가 자신의 정보를 격자 공간에 넣도록 하여 맵 자체에 캐릭터의 정보를 등록하는 것이다. 그리드는 오브젝트 포인터의 2차원 배열 일수도 있고, 링크드 리스트로 구현되어 있을 수도 있다. 이렇게 구현할 경우 맵 안에서 등록된 정보만 탐지하면 되기 때문에 보다 쉽게 충돌을 구현할 수 있다. 물론 이렇게 구현할 경우 폭발 등에서 완벽한 원으로 영향을 끼칠 수 없겠지만, 그리드의 크기를 잘 조절하고 이펙트를 잘 넣어줄 경우 플레이어 입장에서 크게 문제가 되지 않는다. 

거대한 맵 전체를 만드는 것은 리소스 낭비가 심한 반면 이걸 이용할 경우 타일을 반복적으로 배치함으로써 적은 패턴으로 거대한 맵을 구현할 수 있게 된다. RPG는 기본적으로 모든 맵의 기반을 이 방식으로 구현하는데, 대부분의 3D 게임도 이러한 2차원 배열로 구현하게 된다. 3차원 배열을 사용할 수도 있으나 그럴 경우 용량이 너무 커지기 때문에, 점프 등의 3차원 이동은 컨텐츠적으로 영향을 끼치지 않는 선에서 2차원 배열로 구현하는 경우가 많다. 

연산량 과다로 런타임에서 느리게 동작할 때, 베이킹을 많이 사용한다. 예를 들어, 그래픽스 영역에서 빛이나 그림자 표현 등은 실시간이 아니라 컴파일 단계에서 계산하여 텍스쳐로 붙이는 경우가 많은데, 원래는 이러한 작업을 두고 베이킹이라 부른다. 이를 확대하여 연산에 시간이 많이 드는 작업은 미리 결과값을 테이블로 만들어놓고 값을 불러오기만 하는 것 또한 베이킹이라고 한다. 베이킹을 활용하면 메모리 낭비는 생기겠지만 그만큼 연산 속도를 빠르게 할 수 있다. 

# **2. 구조체**

## **1) 지역 변수와 구조체**

```c++
int main()
{
	stDATA data;

	data.a = 0;
	data.b = 10;
}
````

위처럼 지역 변수로서 구조체를 사용하게 되면, 컴파일러는 이를 구조체로 해석하는 게 아니라 구조체 내부 데이터의 요소가 함수 안에 널려있다 라고 이해한다. 

```c++
int main()
{
	stDATA data;
	stDATA* p = &data;

	p->a = 0;
	p->b = 10;
	//
}
```
따라서 구조체를 구조체스럽게 사용하기 위해서는 위 예제처럼 Pointer를 이용하여 넘기는 것이 좋다. 이렇게 될 경우 stack을 확인해보면 p가 가진 주소값을 불러오고 거기에 +1, +2, +4 를 더하는 방식으로 접근한다. 고로 어떤 메모리에서든 항상 동일하게, 구조체처럼 동작하게 된다. 

이와 더불어, 위와 같은 접근 방식 때문에 가장 첫번째 멤버가 가장 접근 속도가 빠르고, 그 이후는 + 가 붙기 때문에 다 동일하게 연산이 한차례 더 들어간다. 고로 활성화 여부 확인 등과 같이 가장 빈번하게 사용하는 멤버는 첫번째 요소로 넣는 것이 좋다.

## **2) 구조체 패딩**

```c++
struct stDATA
{
	char a;
	short b;
	int c;
	short d;
	int e;
	__int64 f;
	char g;
	__int64 h;
	short i;
};
```
위 구조체에서는 총 32byte가 쓰이지만, 실제 구조체 변수의 크기는 이보다 크게 계산된다. 구조체의 경우 사이사이에 Padding이 들어가기 때문이다. 이때, 각 자료형이 자기 크기의 배수에 해당하는 주소에 서게 된다. 예를 들어, 1byte 자료형의 경우 어디에서 시작하든 상관 없는 반면, 2byte의 경우 2로 나누어 떨어지는 위치에 서야한다. 또 4byte의 경우 4로 나누어 떨어지는 위치에, 8byte의 경우 8로 나누어 떨어지는 위치에 서야한다. 그리고 전체 멤버를 다 채운 다음에는, 가장 큰 구조체의 byte 수로 나누어 떨어져야 한다. 이걸 위해 추가적으로 패딩을 붙인다. 이는 구조체 배열을 선언했을 때를 대비한 작업이다. 이 과정을 나열해보자면 위 구조체는 아래와 같이 구성될 것이다. 이때 x는 패딩을 위한 의미 없는 값을 의미한다. 

```
a x b b | c c c c | d d x x | e e e e | f f f f | f f f f |
g x x x | x x x x | h h h h | h h h h | i i x x | x x x x |
```
위 구조체 변수의 크기는 총 48 byte 가 되는 것을 확인할 수 있다.

이건 구조체에서뿐만 아니라 어디에서나 따르는 규칙이다. 그러나  지역변수는 컴파일 과정에서 순서가 바뀌기도 하므로 이러한 규칙이 크게 중요시 되지 않은 반면 구조체는 내가 정의한 순서를 보장하기 때문에 중요하게 여겨진다. 클래스도 마찬가지로 이와 같은 패딩 규칙을 따른다. 따라서 어떤 순서로 선언했느냐에 따라 구조체 패딩, 구조체 크기가 달라지기도 한다. 예를 들어 아래와 같이 멤버의 순서를 바꿔주면 동일한 멤버를 포함하고 있음에도 32byte 크기로 줄어든다.

```c++
struct stDATA
{
	char a;
    char g;
	short b;
	int c;
	short d;
    short i;
	int e;
	__int64 f;	
	__int64 h;
};
```
```
a g b b | c c c c | d d i i | e e e e | 
f f f f | f f f f | h h h h | h h h h |
```

구조체가 이러한 패딩 규칙을 따르는데는 두가지 이유가 있다.

첫째로, 모든 CPU에서 메모리에 접근할 때는 캐시 메모리를 거쳐서 가게 된다. 이때 캐시 메모리를 어떤 단위로 읽어오는지가 중요하다. 캐시 메모리에서 값을 가져올 때는, 1byte를 가져오려고 해도 딱 1byte만 긁어오는 게 아니라 그 변수가 속한 64byte의 캐시 라인을 캐시 메모리에서 긁어와 적재한다. 근데 캐시 라인이 데이터의 중간 경계에 서게 된다면 고작 4byte를 위해 캐시 라인 2줄을 긁어와야 돼서 비효율적으로 동작하게 된다. 또, 이게 멀티 스레드 환경이 될 경우 더 문제가 생긴다. 한쪽에서는 a =0x00 을 넣고 한쪽은 a = 0xff을 넣는다면 0x0f가 들어가는 사태가 생길 수 있는 것이다. 

두번째로, CPU는 데이터를 가져올 때 bit (2의 n승) 단위로 연산하여 접근한다. 이때 만약 4byte를 얻고자 하는데 그 주소가 2의 경계에 서있다면 한번에 4칸을 가져올 수가 없게 된다. 즉 앞쪽 절반, 뒤쪽 절반 두번 계산해서 불러오거나 2칸을 더 가야와야 하는 상황이 된다. 이러한 비효율적인 동작을 막기 위해 패딩을 주게 된다. 

## **3) 지역 변수와 패딩**

만약 구조체의 시작 주소가 0이라면 위와 같은 패딩이 효과적으로 동작할 것이다. 그러나 실제 지역 변수로 쓰일 때는, 이 구조체 변수의 시작 주소가 구조체 멤버의 최대 크기 단위 메모리 주소일 것이라고 보장할 수 없다. 그러므로 위와 같이 접근을 잘 하기 위해서는 시작 주소를 잘 맞춰주어야 한다.

참고로 2023년 기준, 전역 변수를 사용할 때, 스택에서 구조체를 선언할 때, 64bit 기준 malloc을 사용할 때 등의 경우에는 컴파일러가 자동으로 시작 주소를 맞춰준다고 한다. 하지만 포인터로 주소를 지정해줄 때는 여전히 경계가 잘못 세워지는 것을 주의해야 한다. 이럴 때는 aligned malloc과 같이 경계를 맞추기 위한 문법을 사용할 수 있다. 하지만 32bit를 사용할 경우 원래 64bit 짜리 데이터도 32bit로 두번 나누어 접근하기 때문에 여전히 4byte의 경계에 세우는 것을 확인할 수 있다. 

## **4) 네트워크 프로토콜과 패딩**

네트워크 프로토콜에 사용할 구조체에 한해서는 이러한 패딩을 없애야 한다. 패딩이 붙으면 불필요하게 네트워크 트래픽이 늘어날 뿐 아니라, 컴파일러 옵션에 따라 패딩을 붙이는 방식이 서로 다른 경우 큰 문제가 생긴다. 따라서 네트워크에 사용하는 구조체의 경우 패딩을 사용하지 않는 것이 일반적이다. 이런 경우 #pragma pack  (number) 전처리기를 사용할 수 있다. 구조체 앞에  #pragma pack (number) 전처리기를 붙일 경우 number에 해당하는 바이트 경계로 바꾼다. 자료형에 상관 없이 패딩을 없애고 싶다면 아래와 같이 사용하면 된다.

```c++
#pragma pack (1)
struct stDATA 
{
	//
};
#pragma pack ()
``` 
이때 #pragma pack ()을 이용해서 반드시 해제해주어야 한다. 안 그러면 이후에 선언되는 모든 값에 #pragma pack (1)이 적용된다. 

일반적으로 게임 회사에서 제일 비용이 많이 나가는게 인건비와 네트워크 트래픽이기 때문에, 작업을 하다보면 네트워크 트래픽을 줄이기 위해 적극적으로 고민하게 된다. 따라서 프로토콜은 크기 단위로 선언하지 자료형 단위로 선언하지 않는다. 이 경우만큼은 네트워크 프로토콜에 우선순위를 두고 이로 인한 Cache 접근에서의 성능 저하는 감수하는 것이 일반적이다.

설정에서 아예 패딩을 못하게 할 수도 있다. 구조체에서 이러한 패딩을 없애고 싶을 경우, 속성 페이지 - C/C++ - 구조체 멤버 맞춤을 1바이트 경계로 바꾼다면 자료형에 상관없이 모든 자료형을 1의 경계에 세우게 된다. 하지만 이 설정은 건드리지 않는 것을 권장한다. 헷갈릴 수 있으니 추가로 언급하자면, 만약 16바이트 경계로 바꾼다고 해도 모두 16바이트 경계에 선다는 얘기가 아니다. 어차피 16byte보다 작은 것을은 16바이트 안에 꾸겨지게 된다. 이게 기본 설정과 비교해서 차이를 보이려면 16바이트보다 큰 데이터가 있어야 한다.
