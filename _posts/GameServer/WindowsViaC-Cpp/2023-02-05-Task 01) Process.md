---
title: Task 01) Process
categories: WindowsViaC-Cpp
tags: 
toc: true
toc_sticky: true
---

이 포스트는 <제프리 리처의 Windows via C/C++ (한빛미디어)> 내용을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 프로세스**

## **1) 프로세스란?**

프로세스는 일반적으로 수행 중인 프로그램의 인스턴스라고 정의하며 두개의 컴포넌트로 구성된다. 하나는 프로세스를 관리하는 목적으로 운영체제가 사용하는 커널 오브젝트이다. 시스템은 프로세스에 대한 각종 통계 정보를 프로세스 커널 오브젝트에 저장하기도 한다. 또 하나는 실행 모듈, DDL의 코드, 데이터 등을 수용하는 주소 공간이다. 이러한 주소 공간은 스레드 스택, 힙 할당과 같은 동적 메모리 할당에 사용되는 공간도 포함한다. 

## **2) 프로세스와 스레드**

프로세스는 자력으로 수행될 수 없으며, 프로세스가 무언가를 수행하기 위해서는 반드시 프로세스 컨텍스트 내에서 수행되는 스레드가 있어야 한다. 따라서 프로세스는 최소 한 개의 스레드를 가져야 하며, 프로세스가 생성되면 시스템이 자동으로 주 스레드라 부르는 첫번째 스레드를 생성해준다. 만약 모든 스레드가 종료된다면 시스템은 자동으로 프로세스와 프로세스의 주소 공간을 파괴한다. 

하나의 프로세스는 다수의 스레드를 가질 수 있으며, 스레드는 동시에 코드를 수행한다. 이를 위해 각 스레드는 자신만의 CPU 레지스터 집합과 스택을 가져야 한다. 또, 동시 수행을 위해 운영체제는 CPU 시간을 각 스레드에 조금씩 나누어주어야 한다. 각 스레드는 라운드 로빈 방식으로 주어지는 단위 시간 만큼 수행되며, 다수의 CPU를 가진 머신에서 스레드에 CPU 시간을 나눠주는 알고리즘은 상당히 복잡하다. 이에 대해 이해하고 어플리케이션의 알고리즘을 적절히 변경하는 것은 이러한 머신의 장점을 최대한 살리기 위해 유효한 방법이다. 

<br/>

# **2.윈도우 어플리케이션 작성**

## **1) GUI vs CUI**

윈도우는 두가지 형태의 어플리케이션을 지원하는데 하나는 그래픽 유저 인터페이스(GUI) 기반의 어플리케이션이며 하나는 콘솔 유저 인터페이스(CUI) 기반의 어플리케이션이다. 윈도우와 함께 배포되는 메모장, 계산기, 워드 패드 등의 보조 프로그램은 대부분 GUI 어플에 해당한다. CUI 어플은 텍스트를 기반으로 하며 명령프롬프트가 전형적인 CUI 어플에 해당한다. 

Visual Studio를 사용하면 프로젝트 속성 - 링크에서 링커 스위치를 설정할 수 있는데 "/SUBSYSTEM:CONSOLE"을 설정하면 CUI 기반으로 "/SUBSYSTEM:WINDOWS"를 설정하면 GUI 기반으로 서브시스템 값을 가져온다. 

## **2) 진입점 함수**

윈도우 어플리케이션은 수행을 시작할 진입점 함수를 반드시 가져야 한다. C/C++ 환경에서는 두가지 형태의 진입점 함수를 사용할 수 있으며, 어떤 함수를 사용할지는 유니코드 문자열의 사용 여부에 달려있다. 

```c++
int WINAPI _tWinMain(
    HINSTANCE hInstanceExe,
    HINSTANCE, 
    PTSTR pszCmdLine,
    int nCmdShow
);
```
```c++
int _tmain(
    int argc,
    TCHAR *argv[],
    TCHAR *envp[]
);
```
운영체제는 우리가 만든 진입점 함수를 직접 호출하는 대신 C/C++ 런타임에 의해 구현된 C/C++ 런타임 시작 함수를 호출한다. 이는 링크 시 -entry: command-line option을 통해 설정된다. 런타임 시작 함수는 런타임 라이브러리에 대한 초기화 및 전역, 정적 오브젝트를 생성하는 역할을 수행한 후 진입점 함수를 호출한다. 

각 진입점 함수 별 런타임 시작 함수는 아래와 같다. 

|어플리케이션|진입점 함수|런타임 시작 함수|
|-----------|----------|---------------|
|ANSI, GUI| _tWinMain(WinMain)|WinMainCRTStartup|
|UNICODE, GUI| _tWinMain(wWinMain)|wWinMainCRTStartup|
|ANSI, CUI| _tmain(main)|mainCRTStartup|
|UNICODE, CUI|  _tmain(wmain)|wmainCRTStartup|

"/SUBSYSTEM:WINDOWS"가 설정되어 있다면 Winmain, wWinMain을 찾게 되고 이 진입점 함수가 존재하지 않을 경우 unresolvec external symbol 에러를 반환한다. 반대의 경우도 동일하게 동작한다. 만약 "/SUBSYSTEM" 링커 스위치를 제거한 경우 진입점 함수를 바탕으로 어플리케이션에 적합한 설정 값을 찾아내 실행한다. 

## **3) Process Instance Handle**

모든 실행 파일과 DLL 파일은 프로세스의 메모리 공간 상에 로드될 때 고유의 인스턴스 핸들을 할당 받는다. 이러한 인스턴스 핸들은 WinMain의 첫번째 매개변수 hInstanceExe를 통해 전달되어 리소스를 로드할 때 주로 사용된다. 예를 들어 LoadIcon 함수를 보면 첫번째 인자로 hInstance를 받는데 여기서 이 인스턴스 핸들이 사용된다. 

플랫폼 SDK 문서를 살펴보면 간혹 HMODULE 형 인자를 요구하는 함수들이 있다. 16bit 윈도우에서는 HMODULE, HINSTANCE가 구분되는 자료형이었으나 현재는 혼용해서 사용되는 완전히 동일한 자료형이므로 hInstance와 동일하게 사용하면 된다. 예를 들어 GetModuleFileName 함수를 보면 첫번째 인자로 hInstModule을 받는데 여기에서도 이 인스턴스 핸들을 사용한다.

## **4) GetModuleHandle**

hInstanceExe은 시스템이 프로세스의 메모리 주소 공간 상에 실행 파일을 로드할 시작 메모리 주소룰 가리킨다. 이 시작 주소는 링커에 의해 결정되며, 서로 다른 링커는 서로 다른 기본 시작 주소를 가질 수 있다. GetModuleHandle 함수를 사용하면 실행 파일이나 DLL 파일이 프로세스의 메모리 공간 상 어디에 로드되어 있는지 가리키는 핸들/시작 주소를 반환한다. 

```c++
HMODULE GetModuleHandle(PCTSTR pszModule);
```

인자로 프로세스에 로드되어 있는 실행 파일 혹은 DLL 파일의 이름을 '\0'으로 끝나는 문자열로 전달하면, 해당 파일이 로드된 시작 주소를 반환한다. 만약 시스템이 해당 파일을 찾을 수 없다면 NULL을 반환한다. 이때 매개변수로 NULL을 전달할 경우 현재 수행 중인 실행 파일의 시작 주소를 반환한다. 

이 함수가 DLL 내에서 호출되면 어떤 모듈에 포함되어 수행 중인지 알아내기 위해 두가지 방법을 사용할 수 있다. 첫째는 링커에 의해 정의되는 가상변수 __ImageBase가 현재 수행 중인 모듈의 시작 주소를 가리키고 있다는 사실을 활용하는 것이다. 두번째는 GetModuleHandleEx 함수를 호출하는 것이다. 첫번째 매개변수로 GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS를, 두번째 매개변수로 현재 수행 중인 함수의 주소를, 마지막 매개변수로 반환 받을 변수를 지정하면 된다. 

GetModuleHandle에는 중요한 두 가지 특성이 있다. 첫째로, 이 함수는 자신을 호출한 프로세스의 주소 공간만을 확인하며 다른 프로세스의 주소 공간에 로드된 것은 확인하지 못한다. 둘째로, NULL 값을 전달하게 되면 프로세스 주소 공간에 로드 된 실행 파일 시작 주소를 반환한다. 이는 GetModuleHandle를 DLL내에서 호출한 경우에도 마찬가지이다. 

## **5) Prev Instance Handle**

C/C++ 런타임 시작 코드는 항상 hPrevInstance 매개변수로 NULL을 전달한다. 이 매개변수는 16bit 윈도우에서 사용되었으며 포팅 편의를 위해 wWinMain에 남아있을 뿐 참조할 필요가 없기 때문이다. 

## **6) Process Command line**

새로운 프로세스가 생성되면 프로세스에 command line, 명령행이 전달된다. 명령행은 비어있는 경우가 거의 없는데, 새 프로세스를 생성하기 위해서는 최소한 명령행의 첫번째 토큰으로 실행파일의 이름을 전달하기 때문이다. 하지만 '\0'으로만 이루어지니 빈 문자열을 명령행으로 전달 받는 경우도 간옥 있다. 

C 런타임 시작 코드가 GUI 어플을 수행하는 경우 먼저 GetCommandLine 윈도우 함수를 이용하여 프로세스의 명령행 전체를 가져오며, 이 중 실행 파일명을 제외한 나머지 부분을 WinMain 함수의 pszCmdLine 매개변수로 전달한다. 이 매개변수가 가리키는 메모리 버퍼에 값을 쓸 수도 있지만 오버플로우의 위험이 있으므로 되도록 이 영역은 읽기 전용으로 냅두고, 값을 수정할 때는 해당 버퍼를 새 버퍼에 복사한 후 복사된 버퍼를 변경하는 것이 권장된다. 

GetCommandLine 함수를 호출하면 프로세스 명령행 전체를 가리키는 포인터를 획득할 수 있따. 이 함수는 실행파일의 전체 경로명을 포함하는 전체 명령행의 내용을 담고 있는 버퍼의 포인터를 반환하며, 여러번 호출하여도 항상 동일한 버퍼의 주소를 반환한다. 만일 이 내용을 변경하면 최초 전달되었던 명령행 정보를 알 수 없게 되므로 읽기 전용으로 다루어야 한다. 

## **7) Process Environment Variable**

모든 프로세스는 자신과 연관된 환경 블록을 갖는다. 환경 블록은 프로세스의 주소 공간에 할당된 메모리 블록을 의미하며 이 공간은 일련의 문자열을 포함한다. 

<br/>

# **3. CreateProcess 함수**

<br/>

# **4. 프로세스의 종료**

<br/>

# **5. Child Process**

<br/>

# **6. 관리자가 표준 사용자로 수행되는 경우**

<br/>

