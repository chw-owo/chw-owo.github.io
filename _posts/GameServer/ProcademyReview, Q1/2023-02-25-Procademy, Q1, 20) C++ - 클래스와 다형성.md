---
title: Procademy, Q1, 20) C++ - 클래스와 다형성
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. class**

## **1) 상속**

상속관계가 되면 디폴트 생성자, 디폴트 소멸자가 만들어진다. 이때 상속에도 보호 단계를 지정할 수 있다. 

public: 부모 멤버의 보호 단계를 그대로 상속한다. 

protected: public을 protected로 상속 받는다

private: public protected를 private으로 상속받는다

protected, private 상속은 잘 사용되지 않는다.

<br/>

## **2) 다형성, 가상함수**

```c++
A* ptrA = new B();
```

A를 상속받은 B가 있을때, 위와 같이 자식 클래스의 데이터를 부모 클래스의 포인터로 받을 수 있다. 

```c++
ptrA -> Bfunction();
```

그러나 위와 같은 상황은 컴파일 에러가 난다. 
실제 ptrA은 B 객체를 가리키고 있지만 저 문장은 call A::Bfunction()으로 실행되기 때문이다.

```c++
B* ptrB = ptrA;
```
ptrA는 B 객체를 가리키고 있음에도 위 상황 역시 컴파일 에러가 난다.

```c++
class A
{
	Afunction()
}
class B: A
{
	Afunction()
}

ptrA->Afunction()
```

위와 같이 오버라이딩 한 상황에서 ptrA->Afunction()을 할 경우 B 객체를 갖고 있음에도 당연히 A::Afunction()이 호출된다. 이때 ptrA가 B::Afunction()을 호출하도록 하고 싶다면 Afunction() 앞에 virtual을 붙여서 가상함수로 만들면 된다. 

가상함수를 호출할 경우 가상 함수 테이블을 호출하게 된다. 상속 관계에서 가상함수가 하나라도 존재하면 컴파일 순간에 각 클래스마다 가상 함수 테이블이 만들어진다. 내가 코드를 적은 순서 그대로 테이블에 해당 함수의 코드 주소값이 들어간다. 

|A|B:A|C:B|
|--|---|---|
|F1|F1|F1|
|F2|F2|-|
|F3|-|-|

이런 상황일 때 아래와 같은 테이블이 생기는 것이다. 

|A table|B table|C table|
|-------|-------|-------|
|A::F1|B::F1|C::F1|
|A::F2|B::F2|B::F2|
|A::F3|A::F3|A::F3| 

각 객체의 메모리 최상단에 자신의 가상함수 테이블을 가리키는 포인터를 갖게 되고, 당연히 크기만큼 객체의 크기가 늘어나게 된다. 여기에서도 구조체 배웠을 때와 마찬가지로 패딩이 들어간다. 만약 64bit 체제에서 A가 int 1개를 가진 class라면, 가상함수 포인터가 맨 앞에 오기 때문에 8byte(pointer) + 4byte(int) + 4byte(padding) 총 16byte가 될 것이다. 또 맨 앞에 있는 포인터로 가서, 포인터가 가리키는 테이블 위치에 가서 call을 하기 때문에 약간의 성능 저하가 생긴다. 

이런 접근 방식은 포인터로 접근할 때만 동작하며 b.F1() 과 같이 사용할 때는 멤버로 접근하는 것이기 때문에 가상함수로 만들었어도 일반적인 방식으로 동작한다. 
 
```c++
pA -> F3();
```
디스어셈블리로 확인해보면 위 코드의 경우 아래처럼 동작한다.

```
mov edx, ptr [pA]
mov eax ptr [edx]
mov ecx ptr [pA]
mov edx ptr [eax+8]
call edx
```

이렇게 pA 맨 앞 주소 (가상 테이블 주소)의 값을 edx로 가져오고, 그 테이블 맨 앞에 있는 값을 eax로 가져온다. 그리고 세번째 함수였기 떄문에 eax+8로 함수 주소를 찾아와서 call 하게 된다. 

```c++
pA = nullptr;
pA -> F3();
```
이렇게 되면 참조할 가상함수 테이블이 없기 때문에 그 위치에서 crash가 나게 된다. 가상 함수는 객체 맨 앞에 들어있는데 pA는 nullptr이므로 null을 찔렀다는 예외가 나게 된다. 

실수로 가상함수 테이블을 가리키는 주소가 깨지는 상황도 있다. 흔한 경우는 아니지만 만약 우연히 실행 가능한 속성의 메모리 주소로 바뀌었다면 의도한 함수 대신 엉뚱한 함수가 호출될 수 있다. 따라서 가상함수가 이상하게 호출된다면 조사식이랑 메모리 열어서 객체가 올바른 가상함수 테이블을 가리키고 있는지 확인하고, 만약 엉뚱한 주소가 들어있다면 누가 그 주소를 건드렸는지 확인해야 한다. 만약 객체가 연속적인 형태로 존재한다면 앞에 붙어있는 객체가 밀진 않았는지 먼저 확인해보길 권장한다. 

실제로 선생님이 일하셨던 곳에서 이전 플레이어가 특정 스킬을 쓰면 다음 플레이어의 가상함수 테이블이 깨져서 crash가 생기는 경우가 있었다고 한다... 그런 상황이면 서로 연관된 코드가 아니기 때문에 문제를 찾기 어려워진다. 따라서 플레이어 행동의 로그를 찍어뒀다가 해당 객체와 관련된 유저의 행동을 똑같이 재현하거나, 그래도 안된다면 라이브 서비스 데이터베이스를 풀 백업해서 재현하며 문제를 찾아야 한다.

<br/>

# **2. template**

## **1) 사용법**

템플릿으로 함수를 만들면 컴파일 시점에 컴파일러가 해당 타입을 넣어서 함수를 만들어준다. 컴파일러가 알아서 해주는 오버로딩인 셈이다. 만약 특정 자료형이 들어갈 때만 다른 작업을 수행하고 싶다면 특수화를 이용할 수도 있다.

```c++
template<Typename T>
T Max(T a, T b)
{ … }

template<>
char* Max(char* a, char* b)
{ … }
```

## **2) 헤더에 써야하는 이유**

template은 함수가 아니며 컴파일 순간에 실제 함수를 만들게 된다. 그리고 컴파일 순간에 함수를 만들기 위해서는 그때 풀 소스가 필요하다. 따라서 함수의 정의가 포함되어야 한다.  

<br/>

# **3. 질의응답**

Q. hpp가 많이 사용되나요?

A. 잘 사용하지는 않는다. cpp를 include 하기도 하는데 일반적으로는 그냥 header에서 정의까지 마친다.

참고로 h, hpp를 비롯하여 기본적으로 c/cpp가 아니면 다 컴파일 대상이 아니다. 따라서 확장자를 없애도 되고 txt 가 되어도 된다. 다 동일하게 동작하는데 그냥 가독성을 위해 hpp라고 적는 것 뿐이다. 
