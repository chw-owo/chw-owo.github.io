---
title: Procademy, Q2, 20) Network - Serialize Buffer
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 구조체로 가변인자 처리하기**

구조체로 만들 경우 프로토콜에 대한 명세가 패킷 구조체를 선언한 헤더가 되며 이를 클라와 서버가 공유하여 사용해야 되는데, 이때 서로 다른 언어를 쓴다면 패킷에 대한 문서를 만들고 문서를 바탕으로 각 언어에 맞게 각자 만들어야 하는 상황이 된다. 또 구조체가 너무 많이 필요하다는 것 또한 단점이 될 수 있다. 무엇보다도 가변 인자를 사용하기가 어렵다. 구조체를 일반적으로 사용하되 가변인자를 쓰려면, 낭비가 생기는 걸 감안하고 char len, char msg [128]와 같은 식으로 보내야 한다. 

이때 길이 0 배열을 사용하여 어느정도 해결할 수 있다. char len, char msg[0] 과 같이 구조체를 만들 경우 메모리 상에서 해당 구조체는 len 만큼의 공간만 할당받는다. 대신 msg를 포인터처럼 사용해서 해당 구조체 바로 뒤의 공간에 접근할 수 있게 된다. 이를 사용하면 구조체 끄트머리에 딱 하나의 가변인자를 사용할 수 있다. 구조체 멤버로 포인터를 둘 경우 포인트만큼의 공간을 차지하며 그 주소를 타고 가야 한다면 이 방법은 용량은 차지하지 않으면서도 이후 공간을 사용할 수 있다. 

혹은 메시지를 분리할 수도 있다. 가변 데이터 크기를 먼저 보낸 뒤 이후에 가변 데이터를 보낼 수도 있고, 끝나는 메시지를 지정하여 도착할 때까지 받을 수도 있다. 이 경우 여러 개의 메시지가 하나의 트랜잭션이 된다. 또, 메시지에 번호를 지정해서 따로 따로 보낼 수도 있다. 예를 들어 캐릭터를 만든다고 하면 몸 생성, 머리 장식 생성, 몸 장식 생성 등을 각각 보내는 것이다. 그러나 이 방법은 받는 쪽에서 여러 개의 메시지가 종속관계가 되어 처리가 복잡해지므로 클라와의 합의가 필요하다. 

<br/>

# **2. 직렬화 버퍼의 장단점**

구조체는 내가 정의한 순서대로 컴파일러가 연속된 메모리 공간을 잡아준다. 이 작업을 코드를 통해 런타임으로 하는 것이 직렬화 버퍼이다. 따라서 구조체가 필요하지 않으며, 보다 간편하게 가변 인자를 처리할 수 있다. 타입별로 <<를 오버로딩 해서 해당 크기에 맞게 차곡차곡 쌓는 방식으로 구현한다. 직렬화 버퍼는 메시지 별로 일회용으로 사용하기 때문에 원형 큐 방식으로 구현하지 않아도 되므로 링버퍼보다 구현이 쉽다. 이때 return 값을 this reference로 하면 일렬로 사용할 수 있다. 

대신 가독성이 안좋아서 실수할 가능성이 높아지며, 불필요한 복사가 한번 더 일어난다는 단점이 있다. 링버퍼는 포인터를 전달해서 바로 읽고 쓸 수 있었으며, buffer를 구조체로 캐스팅했기 때문에 불필요한 복사가 생기지 않았다. 반면 이 경우 직렬화 패킷 안의 객체에 직접 접근할 방법이 없기 때문에 뽑아낼 공간을 확보해놓고 이를 복사해서 사용해야 된다. 즉, 지역으로 dequeue를 반복하는 것과 동일한 상황이다. 또 데이터를 넣고 뺄 때마다 매번 함수를 호출하기 때문에 성능 손해가 생긴다.

구조체로 모두 처리할 수 있는 콘텐츠면 성능면에서 구조체를 쓰는 게 낫지만, 현업에서는 보통 오픈 소스로 제공되는 직렬화 버퍼를 사용한다. 

<br/>

# **3. 직렬화 버퍼의 구현**

오버로딩 대신 Template을 사용하는 것은 위험하다. 이는 넣어서는 안되는 자료형까지도 받아주기 때문이다. 이때 직렬화 버퍼는 네트워크 라이브러리의 요소이므로 콘텐츠와 네트워크를 분리할 것이라면 콘텐츠 단의 정보를 필요로 하지 않아야 한다. 즉, Player, Item, Monster 등을 인자로 받는 >> <<를 직렬화 버퍼 멤버로 넣는 것은 잘못된 것이다. 따라서 이 경우 전역 오버로딩을 사용한다. 이를 활용하면 PlayerList, ItemList 등을 한번에 보내는 것도 가능하다. 

