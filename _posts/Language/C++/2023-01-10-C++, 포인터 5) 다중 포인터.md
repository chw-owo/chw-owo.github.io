---
title: C++, 포인터 5) 다중 포인터
categories: C++
tags: 
toc: true
toc_sticky: true
---
## **1. 다중 포인터란?**

함수에서 매개변수로 포인터를 전달하여 값을 바꾸는 함수는 기본적으로 아래와 같다.
```c++
void SetInt(const char** a)
{
   *a = 1;
}

int main()
{
    int a = 0;
    SetInt(a);
    cout << a << endl;

    return 0;
}
```

그러나 바꾸는 대상이 문자열이 되면 조금 달라진다. 값이 주소에 직접 담겨있는 일반적인 자료형과 달리, 문자열은 값을 다르게 저장한다. 메모리의 .rodata (read-only data) 영역에 문자열을 저장한 뒤, 해당 문자열의 첫주소를 문자열 변수에 저장하는 방식이다. "Hello"라는 문자열로 예시를 들어보자

```c++
const char* msg = "Hello";
```
```c++
const char[] msg = "Hello";
```
char이라는 변수는 문자 하나만 담는 변수이므로 "Hello"라는 문자열을 저장할 수 없다. 문자열을 저장하기 위해서는 위처럼 배열 혹은 포인터를 사용해야 한다. 위와 같은 코드가 있을 때, "Hello"라는 값은 실제로 .rodata 영역에 존재하고, msg가 그 주소를 가리키고 있는 것이다. 따라서 이 값을 변경하려면 int, float 형을 바꿀 때와는 다른 방법을 사용해야 한다. 

```c++
const char* msg = "Hello";
const char** pp = &msg;
*pp = "Bye" 
```

msg 라는 포인터의 주소 (포인터에 담긴 주소 x, 포인터 변수 그 자체의 주소)를 받아온 뒤, 주소값을 .rodata의 "Bye"라는 문자열을 가리키도록 바꿔준다. 그리고 msg의 값을 확인해보면 "Bye"로 바뀐 것을 확인할 수 있다. 위 코드처럼 문자열을 넣어주는 것은 문자열의 첫 주소를 넣어주는 것과 같다는 것을 잊지 말자. 

이를 함수로 표현하면 아래와 같다.

```c++
void SetChar(const char** a)
{
    *a = "Bye";
}

int main()
{
    const char* msg = "Hello";
    SetMsg(&msg);
    cout << msg << endl;

    return 0;
}
```

이처럼 포인터를 다중으로 쓰는 것을 다중포인터라고 한다. 
 
참고로 포인터와 참조는 내부적으로 동일하게 작동하기 때문에 아래와 같이 적을 수도 있다.

```c++
void SetChar(const char*& a)
{
    a = "Bye";
}

int main()
{
    const char* msg = "Hello";
    SetMsg(msg);
    cout << msg << endl;

    return 0;
}
```

<br/>

## **출처**

[C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈] Part1: C++ 프로그래밍 입문, Rookiss
