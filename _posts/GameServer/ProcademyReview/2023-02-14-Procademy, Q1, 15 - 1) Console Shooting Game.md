---
title: Procademy, Q1, 15 - 1) Console Shooting Game
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 렌더링**

## **1) 더블 버퍼링**

일반적으로 게임은 맵과 그 위의 오브젝트들로 구성된다. 따라서 화면 클리어, 맵 출력, 오브젝트 출력 세 과정을 끊임없이 반복할 것이다. 그러나 이런 방식으로 진행되면 계속해서 깜빡임이 생기게 된다. 이를 막기 위해 그래픽을 쓰는 모든 분야에서는 더블 버퍼링을 사용한다. 화면 클리어, 맵 출력, 오브젝트 출력의 세 과정은 임시 버퍼에서 처리한 뒤, 실제 화면단에는 그 결과물만 덮어 씌우는 것이다. 이를 코드로 간단하게 구현해볼 것인데 우리는 일단 렌더링 과정과 출력 과정을 분리해서 구현할 것이다. 

참고로 실제 그래픽 카드에서는 스왑 체인 방식을 이용하여 이를 처리한다. 이는 내부에서 버퍼를 두개 만드는 것으로, 버퍼 1에 렌더링을 해서 다음 프레임을 준비한 뒤 시간이 되었을 때 flip을 통해 버퍼 1을 주사한다. 그리고 그 시간 동안 버퍼 2에 렌더링을 한 뒤 시간이 되었을 때 flip을 통해 버퍼 2를 주사한다. 이 방식의 경우 더 효율적으로 처리할 수 있는 반면 티어링, 계단 현상이 생길 수 있다. 화면이 주사 되는 중간에 flip이 발생해서 화면이 분리되는 것이다. 횡스크롤 액션 게임에서 이러한 문제가 특히 많이 생겼다. direct X에서 flip과 화면 주사의 동기화를 위한 함수가 제공되지만, 이 경우 프레임 수에 제약이 생길 수 있어서 보통은 동기화를 진행하지 않는다. 



# **2. 게임 구현**

## **1) 게임의 구조**

클라이언트를 만들 때는 input - logic - render의 과정을 반복하고, 서버를 만들 때는 networkIO - logic을 반복하는 것이 일반적이다. 이 

## **2) 콘솔 처리 함수**

줄바꿈을 이용하면 화면이 밀릴 수 있으니 대신 커서 좌표를 이동시켜서 화면을 채운다. 이때 printf()는 IO 작업이라서 처리하는데 시간이 오래 걸리므로 최소화 하고 차라리 FillConsoleOutputCharacter를 대신 사용하는 것이 좋다. 

## **3) Key Input**

윈도우 환경에서 키를 확인할 때는 주로 GetAsyncKeyState 함수를 사용한다. 

```c++
if( GetAsyncKeyState(VK_LEFT) & 0x8001 )
{
	player.x -= 1;
}
```

이때 하위비트와 상위비트의 역할이 조금 다르다.  & 0x0001 를 할 경우 “지금 이 순간에 키가 눌렸다”를 의미한다. 즉, 다른 로직을 처리하고 있던 도중에 키가 눌릴 경우 체크가 되지 않는다. 반대로 & 0x8000 를 하면 지금 호출 시점과 이전 호출 시점 사이에 눌린 적이 있다면 체크가되는 반면 지금 이 순간이 키가 눌린 것은 체크되지 않는다.

```c++
if( GetAsyncKeyState(VK_LEFT) )
{
	player.x -= 1;
}
```

0이 아니면 다 참이기 때문에 위와 같이 사용해도 동일하게 동작한다.

## **4) 객체 지향 vs 절차 지향**

게임 서버는 긴 시간에 걸쳐서 많은 인원이 오가기 때문에 유지보수가 용이해야 한다. 이러한 방면에서 있어서는 절차 지향이 객체 지향보다 장점이 가질 수도 있다. 패키지 게임과 달리 온라인 게임은 출시 이후에도 기획이 계속 바뀌기 때문이다.

# **3. 가변적인 값 - 적군, 총알**

## **1) 적군**

클라이언트라면 적군을 구현할 때 공간 낭비를 줄이기 위해 일반적으로는 linked list를 이용해 구현할 것이다. 하지만 순회가 필요한 상황에서는 배열을 사용하는 것이 linked list -next를 사용하는 것보다 훨씬 빠를 것이다. 무엇보다도, 서버의 경우 사용자가 많을 때나 적을 때나 일관성 있는 속도를 유지하는 것이 중요하다. 서버의 목표는 최대 동접자의 상황에서도 빠르게 동작하는 프로그램을 만드는 것이다. 이 때문에 과거에는 동적 할당을 최소화 하고 메모리를 시작할 때 모두 세팅할 수 있는 프로그램을 지향했다. 따라서 서버 공부를 하는 지금은 일단 적군을 배열로 구현해보기를 권장한다. 

## **2) 총알**

```c++
typedef struct bullet { x, y, flag }; 
bullet[50];
```
총알 역시 객체 최대 개수를 정해둔 뒤 발사할 때마다 총알 객체를 생성한다. 일정 개수가 차면 오래된 순으로 사라지고 새로운 총알 객체가 된다. 

후에 network 라이브러리를 만들게 될 때도 이와 같이 배열을 사용하기를 권장한다. 물론 최근에는 메모리 값도 저렴해지고 stl 성능도 많이 좋아진 관계로 동적할당도 많이 사용하는 추세이긴 하다.

# **4. 그 외**

## **1) 데이터 파일**

코드에서 Stage 별로 정보를 지정하는 것은 나중에 번거로워지므로 외부 데이터로 수정할 수 있도록 해야한다. 맵, 스테이지 개수, 공격 방법, 이펙트, 사운드 타이밍, 적의 배치와 이동, 적의 타입과 타입별 특징 등 종료를 제외하고는 어떤 스테이지니 무엇을 한다는 내용은 코드에 포함되지 않는 것이 좋다. 

## **2) exit 사용 금지**

프로세스를 강제 종료하는 함수로, 서버 개발을 한다면 쓰지 않아야 된다. 전역 변수를 건드리는 스레드가 있는 상황에서 exit을 쓰면 데이터가 오염될 수도 있다. 따라서 함수를 많이 타고 들어간 경우 번거로운 작업이 되더라도 반드시 main에서 return이 이루어질 수 있도록 설계해야 한다. 


## **3) 무한 반복 X**

게임은 타 어플리케이션과 달리 사용자 input을 기다리는 동안 block이 걸리면 안된다. 매 frame마다 렌더링이 새롭게 되어야 하기 때문이다. 그러므로 아래와 같은 구조는 사용해서는 안된다. 만약 반복되는 애니메이션 처리가 필요하다면 시간을 측정해서 이용해야 한다. 

```c++
while(1)
{
	case GAME:
		while(1)
		{ ~~~ }
	...
}
```
case 별로 분기가 되어있다고 해도 각 분기 안에 특정 씬만을 위한 while(1)은 쓰지 말아야 한다. 이는 특정한 동작을 위해 프로그램이 멈춰버리는 것과 같다. 지금 당장은 그렇게 해도 동작하지만 이런 처리가 습관이 되면 나중에 곤란해질 수 있다. 

## **4) 파일을 보낼 때**

**1.** 솔루션 및 프로젝트를 같은 디렉토리에 배치 해제

**2.** 프로젝트 폴더 안의 Debug/Release 지우기. 

**3.** .vs  (자동 완성 용 db 파일) 삭제하기

**4.** 솔루션 폴더의 Debug/Release, 실행파일 지우기. 

(실행파일, obj 파일이 있으면 스팸처리되어 반송 될 수 있다.)

**5.** sln 파일 + 프로젝트 폴더만 있는 채로 압축해서 보내기
