---
title: Procademy, Q2, 33) Network - Fighting Game MMO Server 
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. MMO**

MO일 때는 모두가 프레임을 동일하게 맞추고 좌표가 많이 틀어질 경우 연결을 끊는다. 이는 서버는 느려질 일이 없으며, 좌표가 다르다면 클라기 문제일 것이라 가정하는 처리 방법이다. 반면 MMO는 서버도 느려질 수 있다고 보기 때문에 끊어내는 대신 동기화 처리를 해야 한다. 서버에서 계산한 좌표대로 클라가 움직이도록 워프시키는 것이다. 목적지를 공유하는 방식을 쓰더라도 서버가 느려지면 이러한 동기화가 필요하다. 이때 서버 프레임은 되도록 떨어지지 말아야 하므로 구현은 하되 되도록 쓰이지 않는 것이 좋다. 테스트 시에도 Sync 메시지 수를 서버가 느려졌음을 판단하는 기준으로 사용할 것이다. 

예제의 경우 캐릭터 구조체가 세션 포인터를 들고 있는데 이는 네트워크 코드와 콘텐츠 코드를 분리하지 않은 구조이다. 라이브러리로 만들 경우 세션은 네트워크를 위해 있는 것이므로 이렇게 직접 노출되면 안되며, 콘텐츠 코드는 윈도우의 핸들처럼 세션을 구분자로서만 알 수 있어야 한다. 당연히 이렇게 되면 매번 검색을 해야 되므로 성능은 저하된다. 참고로 IOCP를 쓸 때 가장 대중적으로 쓰는 구조는 tcp 세션 class를 유저가 상속 받고, tcp의 자식인 유저를 네트워크 본체(IOCP)에 등록하여 메시지가 유저로 오도록 만드는 구조이다. 여러 방법으로 분리를 시도할 수 있는데, 실제로는 장시간 운영되다 보면 콘텐츠와 하나가 되는 경우가 많다고 한다. 

<br/>

# **2. 섹터**

MMO에서는 좌표 체계를 하나 더 두어서 시야 처리에 이용한다. 한 공간에 몇 백명만 몰아놔도 어마어마하게 프레임이 떨어지고 예상하지 못한 에러들이 생기기 때문이다. 이 예제는 자기 주변 9개 섹터를 자신의 영향권으로 본다. 4칸이면 어떤 섹터들을 비출지 계산해야 하므로 9칸이 더 구현이 간단하다. 트리 형태로 만들 수도, 배열을 사용할 수도 있다. 런타임에서 섹터 크기를 조절하고 싶다면 실제 섹터 크기를 늘리는 방법의 경우 맵 전체 대상의 재 계산이 포함되므로 성능 저하가 심하고, 애초에 트리 형태로 설계하여 섹터들을 합치는 방법으로 가야한다.

지금은 섹터 안에 플레이어만 있고, 네트워크 전송 반경을 정하는 용도로만 사용하고 있다. 콘텐츠에 따라서 NPC, 충돌 처리 등에 사용하기도 한다. 충돌 처리도 섹터 내에서만 처리하고자 한다면 섹터가 몬스터, 장애물 클래스도 들 수 있게끔 수정해야 된다. 이때 삭제 처리가 제대로 안되면 유령 캐릭터가 남을 수 있으므로 유의해야 한다. 이 문제는 시야 밖에서 이루어지기 때문에 클라로만 테스트해서는 확인하기 어렵다. 따라서 테스트 시 섹터를 작게 설정해서 확인하고 추가적으로 삭제 패킷 로그까지 남겨서 확인하는 것이 좋다. 

섹터 비율은 직사각형이어도 무관하며, 크기의 경우 직접 플레이 해봤을 때 어색하지 않게 생성되게끔 하는 것이 기본이다. 캐릭터 크기, 움직임 속도, 생성과 삭제 시의 부하 등에 따라서 달라지기 때문에 단정지어 말하기는 어렵다. 세로뷰 모바일이라면 직사각형이 낫다. 한 섹터의 경계에 서서 시야를 반대로 하는 경우 조금 움직였을 때 섹터가 바뀌면서 유저들이 한번에 생성된다. 이런 느낌을 줄이고 싶다면 섹터를 작게 만들고 대신 영역의 개수를 늘려야 한다. 연산 단위가 촘촘해지므로 연산량은 늘어나지만 더 자연스럽게 보인다. 

이때 Damage 메시지는 hp 동기화를 위해 피해자 위치를 기준으로 뿌린다. 범위 공격이 있는 경우, 이때 3개 섹터에서 Damage가 나온 경우 Damage 패킷을 총 15개의 섹터에 뿌리면서 다소 부하가 걸린다. 따라서 3개 섹터 기준으로 9개씩 따로 뿌리는 대신, 뿌릴 대상을 선별해서 한번에 15섹터에 모두 뿌리는 방식으로 대체해야 한다. 

만약 섹터로 인한 부담이 크다면, 계산을 최대한 미리 처리하여 런타임에서의 성능 부담을 줄일 수 있다. 섹터가 어느 방향으로 이동하는지 case 별로 분리해서 로직을 짜둘 수도 있고, 방향 별로 추가되는 섹터를 미리 저장해두었다가 불러올 수도 있다. 또, 모든 섹터가 주변 섹터에 대한 섹터 좌표를 들고 있는 방식을 쓸 수도 있다. 당연히 메모리 낭비는 다소 생기지만 속도는 나아질 것이다. 

<br/>

# **3. 콘솔창**

완제품 서버는 당연히 콘솔 창으로 켜지 않는다. 작업 관리자-서비스에 들어가면 백그라운드에서 도는 프로그램들을 확인할 수 있는데 완제품 서버는 여기에서 볼 수 있다. 이 경우 계정 로그인을 안해도 전원만 켜지면 자동으로 실행되며, 노출되어 있는 게 아니다보니 실수로 꺼질 위험이 없다. 콘솔 프로그램을 서비스로 변경하는 거야 어렵지 않지만 이 경우 단독 실행이 안되고 서비스 컨트롤 매니저를 통해서만 실행할 수 있게 된다. 프로세스 가동이 안되기 때문에 더블 클릭으로도 못 켜고 Ctrl + F5로도 디버깅할 수 없다. 온라인 게임은 특성상 완성된 서버가 존재할 수 없기 때문에 그냥 콘솔창으로 켜는 경우가 많다. 이때 X를 눌러서 실수로 꺼지지 않게 하기 위해 X만 비활성화 할 수 있다. 