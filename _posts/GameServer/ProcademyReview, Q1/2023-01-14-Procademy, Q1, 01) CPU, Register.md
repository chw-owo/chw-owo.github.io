---
title: Procademy, Q1, 01) CPU와 Register
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 


## **0. Intro**

**-** 23.01.09 ~ 23.01.11 수업 정리

**-** 첫 달은 C++ 소스코드를 시행했을 때 register와 memory가 어떻게 변화하는지 뜯어보고, 해당 소스코드의 어셈블리어 버전을 해독하는 훈련을 거칠 예정

**-** 어셈블리어로 프로그래밍 할 일은 거의 없지만, 몇 에러들은 어셈블리어를 뜯어봤을 때 원인을 더 빠르게 파악할 수 있기 때문에 내가 짠 소스 코드의 어셈블리어를 해독할 줄 알아야 한다. 

<br/>

## **1. CPU**

**1) CPU란?**

![image](https://user-images.githubusercontent.com/96677719/212538797-762e6a97-cca6-44bf-b5e5-4c1a6910b647.png)
(사진 출처: 컴퓨터 구조와 원리, 신종홍 저, 한빛미디어, 2011)

CPU는 간단한 명령어들의 기계어 코드를 처리하는 디지털 회로이다. 위 이미지는 고전적인 CPU 구조에 해당한다. 최근에는 CPU의 발전으로 제품별로 구조가 다양하게 변화하고 있다. CPU를 비롯하여 컴퓨터 기본 구조에 대한 간단한 설명은 이 [포스트](https://chw-owo.github.io/computerstructure/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%EC%A1%B0/)에서 확인할 수 있다. 

일반적으로 소프트웨어 개발은 고급 프로그래밍 언어 (ex C, C++, Java..)를 사용하며, CPU는 기계어로 번역된 명령어를 처리한다. CPU 기계어로 대응되는 수백가지의 간단한 명령어만 처리가 가능하다. 그와 1:1로 대응되는 프로그래밍 언어가 기계어와 가장 근접한 저급 언어인 어셈블리 언어이다. C, C++ 등으로 프로그래밍 한 뒤에 컴파일 과정을 거치면 컴파일러가 소스코드를 CPU가 인식할 수 있는 기계어로 변환해준다. 

<br/>

## **2. 메모리**

**1) 메모리 계층 구조**

**왜 연산은 RAM이 아니라 레지스터에서 모두 이루어질까요?**

메모리보다 레지스터를 이용하는 것이 더 빠르기 때문도 맞지만, 더 원론적인 이유는 RAM에서는 연산이 불가능하기 때문이다. 2023년 현재, 우리가 사용하는 일반적인 컴퓨터에서는 연산은 CPU만 할 수 있다. 그러나 최근 연구되고 있는 PIM 메모리의 경우엔 메모리에서도 연산을 할 수 있기 때문에 만약 이 기술이 상용화가 된다면 답변이 바뀔 수도 있다.    

메모리는 4GB-16GB 등 큰 용량으로 사용할 수 있지만, CPU 입장에서 이는 보조메모리일 뿐 메모리의 값을 바로 계산에 사용할 순 없다. CPU가 연산에 처리할 수 있는값은 모두 레지스터에 저장되어야 한다. DMA(Direct Memory Access)라는 Bus를 통해 RAM과 CPU 사이의 데이터 송수신이 이루어진다. 그러나 레지스터는 용량이 작아서 충분히 많은 값을 저장할 수 없고, 메모리에서 매번 값을 가져오기에는 메모리 접근에 시간이 많이 소요된다. 이를 보완하기 위해 Cache를 사용한다. L1, L2, L3 Cache를 포함하는 메모리 계층 구조는 아래와 같다. 

![image](https://user-images.githubusercontent.com/96677719/212539582-4cbb4f18-4e56-4e7f-a3a3-7db1d3905897.png)

아래로 내려갈 수록 용량이 큰 대신 접근에 시간이 더 많이 소요되고, 위로 올라갈 수록 용량이 작은 대신 빠르게 접근할 수 있다. Register는 CPU 내부에 들어있다. Register에 값이 없을 경우 L1 Cache에 먼저 접근한다. L1 Cache에 없을 경우 L2 Cache에, L2에 없을 경우 L3에, 거기에도 없을 경우 메모리에 순차적으로 접근하게 된다. 

<br/>

**2) 메모리의 사용, Stack**

![image](https://user-images.githubusercontent.com/96677719/210036928-5d669bf0-c1ea-47e2-971c-bc217f0d72a0.png)

정적 변수, 전역 변수는 초기화 여부에 따라 data, bss에 저장이 된다. 전역으로 선언하는 것은 메모리에 번지를 꽂겠다, 즉 절대 좌표를 사용하겠다는 것을 의미한다. 따라서 컴파일 시에 주소가 정해진다. 그 외에 동적으로 할당되는 변수는 heap에 저장이 되고 지역 변수는 stack에 저장이 된다. 이들은 함수가 실행될 때 주소가 결정되기 때문에 런타임 시에 주소를 알 수 있다. 

![image](https://user-images.githubusercontent.com/96677719/210686541-e51b8b72-7986-4a04-8ac7-dcb2b3002d64.png)

stack이란 함수의 지역 변수가 저장되는 공간으로, 별도의 설정을 해주지 않는 이상 기본으로 1MB로 고정된다. 동적 할당과의 차이점은, 동적 할당은 데이터 공간을 새롭게 할당하는 것이라면, stack에 데이터를 넣는 것은 이미 고정된 1MB 공간의 특정 부분을 지역 변수로 사용하는 것이다. 변수를 선언하여 사용할 때 변수 메모리가 할당되는 개념은 단순히 스택의 일부 영역을 비워두고 그 공간을 사용하는 개념이다. 즉, 이미 1MB가 고정되어 있고, 어디를 사용할지 런타임 중에 결정하는 것뿐이다. 따라서 일반적인 경우에는 지역 변수를 적게 쓴다고 성능이 더 빨라지진 않는다. 단, 디버그 모드일 경우 지역 변수가 성능에 영향을 주기도 하는데, 이 케이스는 뒤에서 확인할 것이다.

stack은 아래에서 위로, 높은 주소에서 낮은 주소로 쌓이는 특징이 있다. stack의 시작점은 OS가 랜덤으로 지정해주는데, 항상 고정된 위치에 잡힐 경우 해킹의 우려가 있기 때문이다. 컴파일 시 각 지역 변수의 총 크기가 적용되며, 각 함수 별 진입부에 지역 변수의 합산된 크기를 계산, 그만큼 esp를 조정하는 코드를 포함하게 된다. (+ 이러한 계산을 용이하게 하기 위해 고전 C의 경우 변수를 무조건 함수 최상단에 몰아넣게 되어있기도 했다. 지금은 컴파일러가 알아서 계산해주기 때문에 그러지 않아도 된다.) 그 후 ebp 혹은 esp를 기준으로 지역 변수의 상대 좌표를 계산하여 연산에 사용한다. 재귀함수를 호출하는 경우에도, 일반 함수의 호출과 마찬가지로 함수가 재호출 될 때마다 ebp, esp가 그 재호출 된 함수에 맞게 재설정되며, 지역 변수 역시 새로운 stack frame 내부에 새롭게 쌓이게 된다. 

코드를 실행하게 되는 main() 역시 일종의 함수이므로 main()안에서 작성하는 지역 변수도 모두 main() 함수의 stack frame에 저장이 된다. 기본적으로 모든 프로그램의 처리가 스택 메모리에서 저장되는 셈이다. stack에 함수가 어떤 순서로 쌓였는지, 즉 어떤 함수가 어떤 경로로 호출되었는지 확인하고 싶다면 visual studio에서 호출 스택을 확인하면 된다. 외부 코드 표시를 활성화하면 내가 작성한 소스코드 외부의 함수도 함께 띄워주는데, 이를 확인해보면 mainCRTStart~~가 C++에서 처음으로 호출되는 것임을 알 수 있다. 새로운 함수를 호출할 때마다 새로운 stack frame이 잡히기 때문에, stack이 어떻게 동작하는지 이해해야 어셈블리어를 제대로 이해할 수 있다. 

<br/>

## **3. Register**

32bit에서는 eax, ebp, esp 등이, 64bit에서는 rax, rbp, rsp 등이 기본 단위로 쓰인다. 요즘 컴퓨터에서는 확인할 수 없지만 16bit 체제에서는 ax, bp, sp가 기본 단위였다고 한다. 32bit, 64bit에서도 여전히 ax, bp, sp 등의 이름으로 해당 레지스터의 하위 16bit를 가리킬 수 있다. 이 포스트는 32bit를 기준으로 작성되었다. 이 포스트보다 더 자세한 설명은 [레지스터 구조 포스트](https://chw-owo.github.io/os/%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0-%EA%B5%AC%EC%A1%B0/)에서 확인할 수 있다. 

**1) Stack Pointer: esp, ebp** 

ebp는 현재 들어있는 함수의 스택 프레임 시작 주소, esp는 현재 스택의 top 주소를 담는다. 따라서 ebp ~ esp가 현재 호출한 함수의 스택, 즉 지역 공간이 된다. ebp 혹은 esp를 기준으로 지역 변수의 위치를 계산하게 된다. 

<br/>

**2) General Purpose Register: eax, ebx, ecx, edx** 

대충의 용도는 정해져있지만 범용적으로 사용할 수 있는 레지스터이다. 피연산자로 사용하기 위해, 메모리에서 값을 불러와 여기에 저장한다. 

<br/>

**3) Index Register: esi, edi**

메모리 복사 기능이 있는 명령어. 값이 아니라 포인터, 즉 주소를 저장하는 용도로 사용된다. 데이터를 조작하거나 복사할 때 기존 주소값과 목적지에 해당하는 주소값을 저장한다. 문자열 관련 작업을 수행할 때 원본 문자열과 목적지 문자열의 인덱스로 사용되기도 한다. 

<br/>
