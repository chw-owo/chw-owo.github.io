---
title: Task 01) Process
categories: WindowsViaC-Cpp
tags: 
toc: true
toc_sticky: true
---

이 포스트는 <제프리 리처의 Windows via C/C++ (한빛미디어)> 내용을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 프로세스**

## **01) 프로세스란?**

프로세스는 일반적으로 수행 중인 프로그램의 인스턴스라고 정의하며 두개의 컴포넌트로 구성된다. 하나는 프로세스를 관리하는 목적으로 운영체제가 사용하는 커널 오브젝트이다. 시스템은 프로세스에 대한 각종 통계 정보를 프로세스 커널 오브젝트에 저장하기도 한다. 또 하나는 실행 모듈, DDL의 코드, 데이터 등을 수용하는 주소 공간이다. 이러한 주소 공간은 스레드 스택, 힙 할당과 같은 동적 메모리 할당에 사용되는 공간도 포함한다. 
                                                              
## **02) 프로세스와 스레드**

프로세스는 자력으로 수행될 수 없으며, 프로세스가 무언가를 수행하기 위해서는 반드시 프로세스 컨텍스트 내에서 수행되는 스레드가 있어야 한다. 따라서 프로세스는 최소 한 개의 스레드를 가져야 하며, 프로세스가 생성되면 시스템이 자동으로 주 스레드라 부르는 첫번째 스레드를 생성해준다. 만약 모든 스레드가 종료된다면 시스템은 자동으로 프로세스와 프로세스의 주소 공간을 파괴한다. 

하나의 프로세스는 다수의 스레드를 가질 수 있으며, 스레드는 동시에 코드를 수행한다. 이를 위해 각 스레드는 자신만의 CPU 레지스터 집합과 스택을 가져야 한다. 또, 동시 수행을 위해 운영체제는 CPU 시간을 각 스레드에 조금씩 나누어주어야 한다. 각 스레드는 라운드 로빈 방식으로 주어지는 단위 시간 만큼 수행되며, 다수의 CPU를 가진 머신에서 스레드에 CPU 시간을 나눠주는 알고리즘은 상당히 복잡하다. 이에 대해 이해하고 어플리케이션의 알고리즘을 적절히 변경하는 것은 이러한 머신의 장점을 최대한 살리기 위해 유효한 방법이다. 

<br/>

# **2.윈도우 어플리케이션 작성**

## **01) GUI vs CUI**

윈도우는 두가지 형태의 어플리케이션을 지원하는데 하나는 그래픽 유저 인터페이스(GUI) 기반의 어플리케이션이며 하나는 콘솔 유저 인터페이스(CUI) 기반의 어플리케이션이다. 윈도우와 함께 배포되는 메모장, 계산기, 워드 패드 등의 보조 프로그램은 대부분 GUI 어플에 해당한다. CUI 어플은 텍스트를 기반으로 하며 명령프롬프트가 전형적인 CUI 어플에 해당한다. 

Visual Studio를 사용하면 프로젝트 속성 - 링크에서 링커 스위치를 설정할 수 있는데 "/SUBSYSTEM:CONSOLE"을 설정하면 CUI 기반으로 "/SUBSYSTEM:WINDOWS"를 설정하면 GUI 기반으로 서브시스템 값을 가져온다. 

## **02) 진입점 함수**

윈도우 어플리케이션은 수행을 시작할 진입점 함수를 반드시 가져야 한다. C/C++ 환경에서는 두가지 형태의 진입점 함수를 사용할 수 있으며, 어떤 함수를 사용할지는 유니코드 문자열의 사용 여부에 달려있다. 

```c++
int WINAPI _tWinMain(
    HINSTANCE hInstanceExe,
    HINSTANCE, 
    PTSTR pszCmdLine,
    int nCmdShow
);
```
```c++
int _tmain(
    int argc,
    TCHAR *argv[],
    TCHAR *envp[]
);
```
운영체제는 우리가 만든 진입점 함수를 직접 호출하는 대신 C/C++ 런타임에 의해 구현된 C/C++ 런타임 시작 함수를 호출한다. 이는 링크 시 -entry: command-line option을 통해 설정된다. 런타임 시작 함수는 런타임 라이브러리에 대한 초기화 및 전역, 정적 오브젝트를 생성하는 역할을 수행한 후 진입점 함수를 호출한다. 

각 진입점 함수 별 런타임 시작 함수는 아래와 같다. 

|어플리케이션|진입점 함수|런타임 시작 함수|
|-----------|----------|---------------|
|ANSI, GUI| _tWinMain(WinMain)|WinMainCRTStartup|
|UNICODE, GUI| _tWinMain(wWinMain)|wWinMainCRTStartup|
|ANSI, CUI| _tmain(main)|mainCRTStartup|
|UNICODE, CUI|  _tmain(wmain)|wmainCRTStartup|

"/SUBSYSTEM:WINDOWS"가 설정되어 있다면 Winmain, wWinMain을 찾게 되고 이 진입점 함수가 존재하지 않을 경우 unresolvec external symbol 에러를 반환한다. 반대의 경우도 동일하게 동작한다. 만약 "/SUBSYSTEM" 링커 스위치를 제거한 경우 진입점 함수를 바탕으로 어플리케이션에 적합한 설정 값을 찾아내 실행한다. 

## **03) Process Instance Handle**

모든 실행 파일과 DLL 파일은 프로세스의 메모리 공간 상에 로드될 때 고유의 인스턴스 핸들을 할당 받는다. 이러한 인스턴스 핸들은 WinMain의 첫번째 매개변수 hInstanceExe를 통해 전달되어 리소스를 로드할 때 주로 사용된다. 예를 들어 LoadIcon 함수를 보면 첫번째 인자로 hInstance를 받는데 여기서 이 인스턴스 핸들이 사용된다. 

플랫폼 SDK 문서를 살펴보면 간혹 HMODULE 형 인자를 요구하는 함수들이 있다. 16bit 윈도우에서는 HMODULE, HINSTANCE가 구분되는 자료형이었으나 현재는 혼용해서 사용되는 완전히 동일한 자료형이므로 hInstance와 동일하게 사용하면 된다. 예를 들어 GetModuleFileName 함수를 보면 첫번째 인자로 hInstModule을 받는데 여기에서도 이 인스턴스 핸들을 사용한다.

## **04) GetModuleHandle**

hInstanceExe은 시스템이 프로세스의 메모리 주소 공간 상에 실행 파일을 로드할 시작 메모리 주소룰 가리킨다. 이 시작 주소는 링커에 의해 결정되며, 서로 다른 링커는 서로 다른 기본 시작 주소를 가질 수 있다. GetModuleHandle 함수를 사용하면 실행 파일이나 DLL 파일이 프로세스의 메모리 공간 상 어디에 로드되어 있는지 가리키는 핸들/시작 주소를 반환한다. 

```c++
HMODULE GetModuleHandle(PCTSTR pszModule);
```

인자로 프로세스에 로드되어 있는 실행 파일 혹은 DLL 파일의 이름을 '\0'으로 끝나는 문자열로 전달하면, 해당 파일이 로드된 시작 주소를 반환한다. 만약 시스템이 해당 파일을 찾을 수 없다면 NULL을 반환한다. 이때 매개변수로 NULL을 전달할 경우 현재 수행 중인 실행 파일의 시작 주소를 반환한다. 

이 함수가 DLL 내에서 호출되면 어떤 모듈에 포함되어 수행 중인지 알아내기 위해 두가지 방법을 사용할 수 있다. 첫째는 링커에 의해 정의되는 가상변수 __ImageBase가 현재 수행 중인 모듈의 시작 주소를 가리키고 있다는 사실을 활용하는 것이다. 두번째는 GetModuleHandleEx 함수를 호출하는 것이다. 첫번째 매개변수로 GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS를, 두번째 매개변수로 현재 수행 중인 함수의 주소를, 마지막 매개변수로 반환 받을 변수를 지정하면 된다. 

GetModuleHandle에는 중요한 두 가지 특성이 있다. 첫째로, 이 함수는 자신을 호출한 프로세스의 주소 공간만을 확인하며 다른 프로세스의 주소 공간에 로드된 것은 확인하지 못한다. 둘째로, NULL 값을 전달하게 되면 프로세스 주소 공간에 로드 된 실행 파일 시작 주소를 반환한다. 이는 GetModuleHandle를 DLL내에서 호출한 경우에도 마찬가지이다. 

## **05) Prev Instance Handle**

C/C++ 런타임 시작 코드는 항상 hPrevInstance 매개변수로 NULL을 전달한다. 이 매개변수는 16bit 윈도우에서 사용되었으며 포팅 편의를 위해 wWinMain에 남아있을 뿐 참조할 필요가 없기 때문이다. 

## **06) Process Command line**

새로운 프로세스가 생성되면 프로세스에 command line, 명령행이 전달된다. 명령행은 비어있는 경우가 거의 없는데, 새 프로세스를 생성하기 위해서는 최소한 명령행의 첫번째 토큰으로 실행파일의 이름을 전달하기 때문이다. 하지만 '\0'으로만 이루어지니 빈 문자열을 명령행으로 전달 받는 경우도 간옥 있다. 

C 런타임 시작 코드가 GUI 어플을 수행하는 경우 먼저 GetCommandLine 윈도우 함수를 이용하여 프로세스의 명령행 전체를 가져오며, 이 중 실행 파일명을 제외한 나머지 부분을 WinMain 함수의 pszCmdLine 매개변수로 전달한다. 이 매개변수가 가리키는 메모리 버퍼에 값을 쓸 수도 있지만 오버플로우의 위험이 있으므로 되도록 이 영역은 읽기 전용으로 냅두고, 값을 수정할 때는 해당 버퍼를 새 버퍼에 복사한 후 복사된 버퍼를 변경하는 것이 권장된다. 

GetCommandLine 함수를 호출하면 프로세스 명령행 전체를 가리키는 포인터를 획득할 수 있따. 이 함수는 실행파일의 전체 경로명을 포함하는 전체 명령행의 내용을 담고 있는 버퍼의 포인터를 반환하며, 여러번 호출하여도 항상 동일한 버퍼의 주소를 반환한다. 만일 이 내용을 변경하면 최초 전달되었던 명령행 정보를 알 수 없게 되므로 읽기 전용으로 다루어야 한다. 

## **07) Process Environment Variable**

모든 프로세스는 자신과 연관된 환경 블록을 갖는다. 환경 블록은 프로세스의 주소 공간에 할당된 메모리 블록을 의미하며 이 공간은 다음과 같은 형태의 일련의 문자열을 포함한다. 

```
=::=:\ ...
VarName1 = VarValue1\0
VarName2 = VarValue2\0
VarName3 = VarValue3\0 
...
VarNameX = VarValueX\0
\0
```

환경 블록에 접근하는 방법은 두가지가 있다. 첫번째는, 전체 환경 블록을 얻기 위해 GetEnvironmentStrings 함수를 호출한 뒤 "="를 기준으로 파싱하는 것이다. 반환된 메모리 블록을 더 이상 사용하지 않을 것이라면 FreeEnvironmentStrings를 호출해주어야 한다. 

두번째 방법은 CUI 어플리케이션에서만 활용 가능한 방법으로 _tmain 진입점 함수의 매개변수로 전달되는 TCHAR *env[]를 사용하는 것이다. env는 문자열을 가리키는 포인터의 배열로 구성되어 있으며, 각각의 포인터가 "이름=값" 형태의 문자열을 가리킨다. 그리고 마지막 문자열 다음에는 NULL 포인터가 나타난다. env를 통해 환경 변수들이 전달되기 이전에 =로 시작하는 문자열들이 제거되기 때문에 따로 처리해줄 필요가 없다. 

일반적으로 자식 프로세스는 부모 프로세스의 환경 변수 집합을 상속한다. 또, 부모 프로세스에서 어떤 환경 변수를 자식에게 상속할지 제어할 수도 있다. 상속으로 환경 변수가 전달될 경우, 이는 환경 블록을 공유하는 방식이 아니라 새롭게 값을 복사, 전달하는 방식으로 이루어진다. 따라서 이후 자식 프로세스가 환경 블록을 수정하여도 부모 프로세스의 환경 블록에는 영향이 가지 않는다. 

사용자는 제어판의 시스템을 통해 환경 변수를 추가, 삭제, 변경할 수 있다. 환경변수를 설정할 때는 "="가 이름과 값의 구분자 역할을 하므로 환경변수의 이름 혹은 값에 "="가 포함되면 안된다. 또, "=" 전후의 공백 문자열도 유의미한 값으로 비교의 대상이 되기 때문에 주의해야 한다. 

환경변수를 이용하는 어플리케이션에서 사용할 수 있는 유용한 함수들이 몇가지 있다. 첫번째는 GetEnvironmentVariable 함수이다. 인자로 알고 싶은 환경 변수의 이름과, 값을 저장할 버퍼 포인터를 전달하면 해당 환경변수의 값을 알 수 있다. 두번째는 ExpandEnvironmentStrings 함수이다. GetEnvironmentVariable에서와 동일하게 값을 전달하면 대체 가능 문자열을 변경하여 반환해준다. 마지막으로 SetEnvironmentVariable 함수를 이용해 환경 변수를 추가, 삭제, 변경할 수 있다. 

## **08) Process Error Mode**

각 프로세스는 심각한 에러가 발생했을 때, SetErrorMode 함수를 호출하여 시스템이 이러한 에러들을 어떻게 처리하면 좋을지 알려줄 수 있다. 해당 함수의 플래그는 아래와 같다. 

|플래그|설명|
|------|---|
|SEM_FAILCRITICALERRORS| 시스템이 크리티컬 에러 처리기 메시지 박스를 출력하지 않도록 하고, 발생한 에러를 호출한 프로세스에 전달한다.|
|SEM_NOGPFAULTERRORBOX| 시스템이 일반 보호 실패 메시지 박스를 출력하지 않도록 한다. 이 플래그는 디버깅 어플리케이션이 일반 보호 실패 자체에 대한 예외 처리기를 가지고 있는 경우에 한해 사용하는 것이 권장된다. |
|SEM_NOOPENFILEERRORBOX| 시스템이 파일 관련 실패 메시지 박스를 출력하지 않도록 한다.|
|SEM_NOALIGNMENTFAULTEXCEPT|시스템이 자동으로 메모리 정렬 실패를 수정하고, 어플리케이션에게는 실패 사실을 알리지 않는다. x86, x64 프로세서에서는 영향을 주지 않는 플래그이다. |

기본적으로 자식 프로세스는 부모 프로세스의 에러 모드 플래그를 상속한다. 그러나 자식 프로세스는 이와 같이 설정되었다는 것을 전달받지 못하기 때문에 의도하지 않게 메시지를 전달받지 못하고 종료될 수도 있다. 이를 막기 위해 CreateProcess 호출 시 CREATE_DEFAULT_ERROR_MODE 플래그를 지정하여 자식 프로세스의 에러 모드를 기본값으로 설정할 수 있다. 

## **09) Current Drive & Directory**

파일의 전체 경로가 제공되지 않을 경우 많은 윈도우 함수들은 파일과 디렉토리를 현재 드라이브의 현재 디렉토리에서 찾는다. 시스템은 내부적으로 프로세스의 현재 드라이브와 디렉터리를 저장해두며, 이러한 정보가 프로세스 단위로 유지되기 때문이다. 이 특성 때문에 특정 스레드가 현재 드라이브, 디렉토리를 바꾸게 되면 동일 프로세스 내 모든 스레드에게 영향을 끼치게 된다. 

시스템은 프로세스의 현재 드라이브와 디렉토리는 저장해두지만, 모든 드라이브의 현재 디렉토리를 저장하지는 않는다. 그러나 운영체제는 다수의 드라이브에 대해 현재 디렉토리를 처리할 수 있는 기능을 제공하며, 이를 위해 프로세스의 환경 변수가 사용된다. 예를 들어 프로세스는 아래와 같은 두개의 환경 변수 값을 가질 수 있다. 

```
=C:=C:\Utility\Bin
=D:=D:\Program Files
```

프로세스의 현재 드라이브와 디렉토리를 얻을때는 GetCurrentDirectory 함수를 호출하며, 설정할 때는 SetCurrentDirectory 함수를 호출한다. 

함수 호출 시 현재 드라이브가 아닌 드라이브 문자를 전달하게 되면, 시스템은 프로세스의 환경 변수 블록에서 지정된 문자를 찾는다. 만약 이러한 변수가 존재하면 시스템은 이 값을 지정된 드라이브의 현재 디렉토리로 간주하며, 없을 경우 지정된 드라이브의 루트 디렉토리를 현재 디렉토리로 선택한다. 

부모 프로세스가 현재 디렉토리 정보를 자식 프로세스에게 전달하기 위해 환경 블록을 생성하여도, 자식 프로세스의 환경 블록에 디렉토리 정보가 자동으로 상속되지는 않는다. 자식 프로세스는 모든 드라이브의 루트 디렉토리를 현재 디렉토리로 간주한다. 만약 자식에게 현재 디렉토리 정보를 전달하고 싶다면, 드라이브 문자를 이름으로 하는 환경 변수를 생성하여 환경 블록에 추가해야 한다. 이때, 현재 디렉토리 정보를 얻기 위해 GetFullPathName 함수를 호출할 수 있다. 

## **10) System version**

Window API의 GetVersion 함수를 이용하면 사용하는 윈도우 버전을 확인할 수 있다. 그러나 이 함수의 경우, 버전 정보가 뒤집혀서 반환이 되는 특징이 있어 권장되지 않는다. 

GetVersionEx 를 사용하면 OSVERSIONONFOEX 구조체를 통해 보다 읽기 쉽게 버전 정보를 가져올 수 있다. MSDN의 시스템 버전 획득 문서에서 해당 구조체의 각 멤버를 어떻게 사용해야 하는지에 대해 예제 코드를 제공하고 있다. 

윈도우 비스타부터는 VerifyVersionInfo 함수를 이용할 수 있다. 이를 이용하면 현재 수행 중인 시스템 버전과 어플리케이션이 요구하는 버전을 손쉽게 비교할 수 있다. 여기서도 OSVERSIONONFOEX 구조체가 사용되며 OSVERSIONONFOEX 구조체를 세팅한 뒤 해당 함수의 인자로 전달하면 일치할 경우 TRUE를, 일치하지 않을 경우 FALSE를 반환한다.

<br/>

# **3. CreateProcess 함수**

## **01) 개요**

```c++
BOOL CreateProcess (
    PCTSTR               pszApplicationName,
    PTSTR                pszCommandLine,
    PSECURITY_ATTRIBUTES psaProcess,
    PSECURITY_ATTRIBUTES psaThread,
    BOOL                 bInheritHandles,
    DWORD                fdwCreate,
    PVOID                pvEnvironment,
    PCTSTR               pszCurDir,
    PSTARTUPINFO         psiStartInfo,
    PPROCESS_INFORMATION ppiProcInfo
);
```

스레드가 CreateProcess를 호출하면 시스템은 Usage Count가 1인 프로세스 커널 오브젝트를 생성한다. 프로세스 커널 오브젝트가 프로세스 자체를 의미하는 것은 아니며, 운영체제가 프로세스를 관리하기 위한 데이터 구조체를 의미한다. 

프로세스 커널 오브젝트가 생성되고 나면, 시스템은 새로운 프로세스를 위한 가상 주소 공간을 생성하고 실행 파일의 코드, 데이터, DLL 파일들을 해당 주소 공간에 로드한다. 그 후 새로 생성된 프로세스의 주 스레드를 위한 스레드 커널 오브젝트 (Usage Count 1)를 생성한다. 그러면 주 스레드는 링커에 의해 진입점으로 지정된 C/C++ 런타임 시작 코드를 실행하고, 이 시작 코드는 main 함수를 호출하게 된다. 

이때, CreateProcess가 TRUE를 반환하는 시점은 시스템이 성공적으로 프로세스와 주 스레들르 생성한 직후이다. 따라서 새로 생성된 프로세스가 초기화에 성공했는지, 필요한 DLL을 제대로 로드 했는지 등에 대해 부모 프로세스는 알 수 없다. 

## **02) **pszApplicationName**

pszApplicationName는 대체로 NULL로 지정하나 간혹 pszApplicationName로 실행 파일명을 전달할 수 있다. pszApplicationName로 파일명을 지정하는 경우 파일명의 확장자를 .exe로 가정하지 않기 때문에 반드시 확장자를 포함해야 한다. 또, 이 경우에 파일이 현재 디렉토리에 존재하지 않으면 별도의 검색을 거치지 않고 실패를 반환한다. 이는 윈도우의 POSIX 서브 시스템을 지원하도록 하기 위해 포함된 매개변수로, 대부분의 경우 pszCommandLine의 첫번째 인자로 실행파일 명을 전달한다. 

## **03) pszCommandLine**

pszCommandLine를 이용하면 CreateProcess가 새로운 프로세스를 생성하기 위해 필요한 추가 정보를 제공할 수 있다. 이때 전달되는 문자열의 첫 토큰은 실행하려는 프로그램의 파일명으로 간주되며 확장자가 없을 경우 .exe라 가정한다. 이때 pszCommandLine는 PTSTR, 즉 CreateProcess 함수 내에서 변경될 수 있는 형태로 전달되어야 한다. CreateProcess는 내부적으로 해당 명령행 문자열에 변경 작업을 수행한 뒤, 반환 직전에 원래 값으로 돌려놓는다. 

+) 재밌는 것은, 비스타에서 ANSI 버전의 CreateProcess를 호출할 경우 예외가 발생하지 않는데 이는 유니코드로의 변경을 위해 문자열 복사가 내부적으로 이루어지기 때문이다. 

생성할 프로세스의 파일명이 전체 경로를 포함하는 경우 전체경로를 이용하나, 그게 아닐 경우 실행 파일을 찾기 위해 다음과 같이 순차적으로 검색한다. 

**1.** 생성할 프로세스의 실행 파일명에 포함된 디렉토리

**2.** 생성할 프로세스의 현재 디렉토리

**3.** 윈도우 시스템 디렉토리. 즉 GetSystemDirectory가 반환하는 System32 서브폴더

**4.** 윈도우 디렉토리

**5.** PATH 환경 변수에 포함된 디렉토리들

간혹 pszApplicationName로 파일명을 지정하고 또 pszCommandLine를 통해 새로운 프로세스를 위한 명령행 문자열을 전달할 수도 있다. 

## **04) psaProcess, psaThread, bInheritHandle**

새로운 프로세스를 생성하기 위해서 시스템은 프로세스 커널 오브젝트와 스레드 커널 오브젝트를 생성한다. 이들은 모두 커널 오브젝트이므로 부모 프로세스에서 각각에 대해 보안 특성을 지정해주어야 한다. 만약 기본 Security descriptor를 사용하고 싶다면 각 매개변수를 NULL로 지정하면 된다. 그렇지 않다면 SECURITY_ATTRIBUTES 구조체를 통해 보안 권한을 설정할 수 있다. 

bInheritHandle에 TRUE를 전달하면 부모 프로세스가 접근 가능한 커널 오브젝트를 자식 프로세스에서도 사용가능하도록 설정할 수 있다. SECURITY_ATTRIBUTES로 상속 가능하게 설정해도 이 매개변수기 FALSE라면 상속이 불가능하다.  

## **05) fdwCreate**

fdwCreate 매개변수는 새로운 프로세스를 어떻게 생성할지를 결정하게 된다. 

<br/>

# **4. 프로세스의 종료**

<br/>

# **5. Child Process**

<br/>

# **6. 관리자가 표준 사용자로 수행되는 경우**

<br/>

