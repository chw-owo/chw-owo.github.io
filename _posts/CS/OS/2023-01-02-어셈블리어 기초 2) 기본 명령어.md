---
title: 어셈블리어 기초 2) 기본 명령어
categories: OS
tags: 
toc: true
toc_sticky: true
---

## **1. 사칙 연산**

**1) add, 더하기 연산**
```
add a, b
```
$a$에 $a+b$ 값을 넣어주는 연산. 

이때, 조건이 몇가지 있다.

- a는 레지스터 혹은 메모리여야 한다. 

- b는 레지스터 혹은 메모리 혹은 상수여야 한다.

- 단, a, b 모두 메모리면 안된다. 

- b에는 a보다 큰 크기(byte)의 값이 올 수 없다.

<br/>

메모리에 상수를 더하는 예시는 아래와 같다. mov로 메모리에 상수를 넣었을 때와 마찬가지로 상수의 크기를 표시해주어야 한다.

```
section .text
global CMAIN

CMAIN:
    add [a], byte 1 
    ...

section .bss
    a resb 1
    
```

**2) sub, 빼기 연산**
```
sub a, b
```
$a$에 $a-b$ 값을 넣어주는 연산. 사용하는 방식 및 유의사항은 add와 동일하다. 

<br/>

**+) 왜 add memory, memory 연산은 안될까?**

[참고1](https://www.quora.com/Why-is-it-not-possible-to-add-the-contents-of-two-memory-locations-variables-in-8086-assembly-language),  [참고2](https://myfreechild.tistory.com/entry/Assembly-%EC%97%B0%EC%82%B0%EC%97%90%EC%84%9C-Memory-To-Memory-%EC%97%B0%EC%82%B0%EC%9D%B4-%EB%B6%88%EA%B0%80%EB%8A%A5%ED%95%9C-%EC%9D%B4%EC%9C%A0)

프로세서 제조사의 공식 입장은 찾지 못했고, 비효율적이기 때문에 설계 과정에서 배제되었을 것이라는 추측이 주도적이었다. 어셈블리어는 가능한 간단하게 설계되는 것을 지향하는데 한 명령어에서 두 메모리 접근을 가능하게 하려면 처리해야 되는 비용이 늘어난다는 것, 그리고 그렇게 했을 때 별다른 이점이 없다는 것이 이유이다. 

이런 추측에 대해 자세히 이해하려면 명령어 사이클에 대해 이해해야 한다. [명령어 사이클](www.naver.com)

한 명령어에서 두개의 메모리에 접근한다는 것은, 한 명령어로 두개의 cache miss (cache에 해당 데이터가 없어서 메인 메모리까지 접근해야 되는 상황)가 발생할 수 있다는 의미이다. 이럴 경우 한 




## **2. 시프트 연산**
## **3. 논리 연산**
## **4. 분기문과 반복문**
## **5. 배열**
## **6. 함수**

## **출처**

[C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈] Part1: C++ 프로그래밍 입문, Rookiss

https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=hjyang0&logNo=152390859
