---
title: Procademy, Q1, 29 - 1) Window API - Memory
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 윈도우 메모리 구조**

윈도우의 메모리는 주소 0부터 보호영역, 유저 영역, 또 다른 보호 영역 그리고 커널 영역으로 이루어져있다. 사용자가 메모리를 아무리 많이 써도 2^64 메모리 영역을 다 쓸 일은 없고, 만약 그걸 다 쓸 수 있다고 해도 그에 맞춰 페이징을 설계하면 낭비가 심해지기 때문에 윈도우에서는 일부 영역을 아예 접근 금지 영역으로 만들어둔 것이다. nullptr(0)이나 0x8123과 같은 값들이 접근 금지 영역에 포함되며 시스템적으로 크래쉬를 낼 때 사용하기도 한다. 

포인터 주소 체계에서 사용되지 않는 구간이 존재한다. 유저영역의 최대값이 43bit이므로 64bit 체제에서는 상위 13개 bit가 사용되지 않는 bit가 된다. 일반적인 사용은 아니지만 이를 주소로 마스킹하여 포인터에서 접근하지 못하는 bit 영역을 임의로 사용할 수도 있다. 포인터는 재사용이 되므로 이전에 할당-해제한 포인터를 다시 할당받게 되기도 하는데, 이 개념을 활용하면 이걸 막을 수 있다. 이런 사용의 경우 업데이트로 유저 영역이 늘어나면 당연히 문제가 생긴다. 

<br/>

# **2. NonPaged Pool**

커널 메모리는 Paged pool, NonPaged pool로 나뉜다. Paged pool은 Page out 할 수 있는, 즉 물리 메모리에서 디스크로 뺄 수 있는 영역이고 NonPaged pool은 절대 Page out 할 수 없는, 무조건 물리 메모리에 상주해야 하는 메모리를 의미한다. NonPaged pool이 한계치를 초과하면 예상하지 못한 예외, 심한 경우 시스템 다운까지 발생할 수 있으므로 유의해야 한다. NonPaged pool 에러는 Interrupt 기반, 즉 하드웨어 신호를 기반으로 동작하는 코드에서 발생할 수 있다. 

NonPaged pool 에러가 생기는 상황은 다음과 같다. Page fault가 발생하면 CPU는 그 원인을 파악하여, Page out이 된 거라면 알아서 처리하고 아니라면 예외를 던진다. 그러나 소프트웨어 인터럽트는 하드웨어 인터럽트보다 우선순위가 낮아서, 인터럽트 처리를 위해 드라이브 코드가 작동 됐는데 그 안에서 Page fault가 발생한다면 예외를 던지고 메모리에 대해 Page In 하는 과정을 처리할 수 없게 된다. 

이와 같은 이유로 네트워크 관련 데이터는 NonPaged Pool을 사용해 처리한다. 메모리 버퍼가 대표적인 예시인데, 만약 수신 처리를 제대로 하지 못하면 메모리 버퍼를 위한 공간이 커지면서 NonPage Pool 사용량이 같이 늘어난다. Interrupt 기반 코드는 Interrupt가 발생한 즉시 처리되어야 하는데, 그게 처리되기 전에 Page out이 일어나면 NonPaged pool 관련 에러가 생긴다. 

<br/>

# **3. 가상 메모리**

CR3에 현 프로세스의 가상 메모리 테이블과 매칭되는 물리 메모리 주소를 담고 이를 바탕으로 변환한다. TLB에서 miss가 나면 실제 테이블로 가고 hit가 되면 TLB에서 빠르게 가져오며 이런 역할을 하는 것들을 통틀어 MMU라고 부른다. 가상 메모리에선 선형적으로 존재하는 데이터도 물리메모리에서는 뒤죽박죽일 수 있지만, Page 단위로 묶여서 존재하기 때문에 Cache Hit에는 영향을 주지 않는다. 이를 통해 프로세스 간 메모리 단편화를 막을 수 있다.

커널 메모리도 가상 메모리 구조로 존재하는데 대신 이들은 프로세스끼리 공유할 수 있다. 
