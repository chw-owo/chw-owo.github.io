---
title: 레지스터 구조
categories: OS
tags: 
toc: true
toc_sticky: true
---

### **레지스터란?**

![ComputerStructure](https://user-images.githubusercontent.com/96677719/210035972-c2e8341c-7f91-4949-a0c7-dd7c5f83b5c5.png)

CPU 내부에 존재하는 다목적 저장공간, CPU가 명령을 수행하는데 필요한 데이터 및 데이터의 주소 등을 임시로 저장하는데 사용된다. 

레지스터는 목적과 저장 대상에 따라 분류되는데 큰 구조는 아래와 같다. 

32bit 운영체제의 경우 

![image](https://user-images.githubusercontent.com/96677719/210202017-44144409-d7c0-4686-b8ba-9114e5c5443a.png) 

64bit 운영체제의 경우 

![image](https://user-images.githubusercontent.com/96677719/210202310-5818e34e-25f3-4c33-b502-ea86ff47ce91.png)

OS 개발 시에는 범용레지스터, 레스먼트 레지스터, 컨트롤 레지스터를 주로 많이 사용하게 된다. 

<br/>

+) 레지스터의 호환

x86-64 아키텍처는 IA-32의 64비트 확장 아키텍처라 호환이 가능하다. 따라서 x86-64에서 IA-32의 레지스터를 그대로 사용할 수 있다. 
x86(32bit 운영체제)의 레지스터인 eax는 x64(64bit 운영체제)의 레지스터인 rax의 하위 32비트를 의미하게 된다. 


<br/>

### **프로그램 실행 관련 레지스터** 

**📌 General Purpose Registers, 범용 레지스터**

프로그래머가 임의로 조작할 수 있게 허용된 8개의 레지스터로 논리 연산,수리 연산에 사용되는 피연산자, 주소 계산에 사용되는 피연산자 그리고 메모리 포인터 등이 저장된다. 운영체제 모드 별로 갯수와 크기가 달라지는데 64bit가 되면 크기와 갯수가 늘어나면서 명령 수행 속도가 빨라진다. 

![image](https://user-images.githubusercontent.com/96677719/210197187-a07880a9-7b0e-46a8-9230-7edf097e2791.png)

AX, BX, CX, DX의 경우 원래는 16bit를 사용하던 시절에 기본 단위로 정해졌으며 각각 16bit의 용량을 갖고 있다. 이 중 앞의 8bit를 High라는 접미사를 붙여서 AH, 뒤의 8bit를 Low라는 접미사를 붙여서 AL이라 칭한다. 

이들 레지스터가 32bit로 확장된 32bit 운영체제가 등장하며, 접두사 Extend를 붙인 EAX, EBX, ECX, EDX가 기본 단위가 되었다. 32bit 운영체제가 아니더라도 보호모드 등 32bit 모드를 사용할 때는 E 접두사가 붙는 레지스터를 사용한다.

또, 이들을 64bit로 더 확장한 64bit 운영체제의 경우 RAX, RBX, RDX, RDX 를 기본 단위로 사용한다. AMD 공식 문서에 따르면 이때 접두사 R은 Register Extension 의 약자라고 한다. 

아래에서 설명할 레지스터 명칭의 경우, 64bit 환경에서는 R을, 32bit 환경에서는 E를 붙인 것이 기본 단위로 사용된다고 보면 된다. 

<br/>

**1.**

**1)AX, Accumulator Register**

RAX, EAX, AX, AH, AL

산술 연산 시 상수, 변수의 값을 저장하거나 함수의 반환 값을 저장하는 것에 사용된다.

**2)BX, Base Register**

RBX, EBX, BX, BH, BL

산술 연산 시 변수의 값을 저장하는 거나 배열의 인덱스 값을 저장하는 것에 사용되며, 메모리 주소를 저장하는 포인터로도 사용된다.

**3)CX, Counter Register**

RCX, ECX, CX, CH, CL

반복문의 반복 횟수와 각종 연산의 시행 횟수로 사용되는 값을 저장하는 것에 사용된다. 문자열 처리에도 사용된다. 

**4)DX, Data Register**

RDX, EDX, DX, DH, DL

AX와 합쳐져 확장된 보조 레지스터로 사용된다. 그 외 I/O Address를 지정할 때 등 범용 목적의 저장소로 사용된다. 

<br/>

**+)**

R8~R15: x64 프로세스에 추가된 범용 레지스터로 범용 목적으로 사용된다. IA-32e 모드에서만 접근 가능하며 운영 모드에 따라 일정한 규칙을 갖고 사용된다. 

<br/>

**2. 인덱스 레지스터**

**1)SI, Source Index**

RSI, ESI, EI

데이터를 조작하거나 복사할 때 데이터의 기존 주소값을 저장한다. 예를 들어 문자열 관련 작업을 수행할 때 원본 문자열의 인덱스로 사용된다. 

**2)DI, Destination index**

RDI, EDI, DI

데이터를 조작하거나 복사할 때 데이터의 목적지에 해당하는 주소값을 저장한다. 예를 들어 문자열 관련 작업을 수행할 때 목적지 문자열의 인덱스로 사용된다. 

<br/>

**3. 포인터 레지스터**

**1)SP, Stack Pointer**

RSP, ESP, SP
 
스택 프레임의 가장 윗 주소를 가르키는 포인터로 사용된다. 따라서 스택에 값이 쌓이면 SP 역시 증가한다.

**2)BP, Stack Base Pointer**

RBP, EBP, BP

스택 프레임의 시작(Base) 주소를 가리키는 포인터로 사용된다. BP가 가리키는 주소에는 return 값이 들어있다. 

<br/>

**📌 Segment Register, 세그먼트 레지스터**

목적에 따라 주소 공간을 구분하기 위해 특정 세그먼트의 시작 위치를 가리키는 역할을 수행한다. 이때 segment는 프로그램의 구성 단위를 의미하며 코드, 데이터, 스택 등을 포함한다. 운영체제에서는 가상 메모리를 이용하여 효율적으로 메모리를 사용하는데, 가상 메모리를 물리 메모리로 변환하는 과정에서 세그먼트 레지스터를 사용한다. 

각 레지스터의 크기는 운영체제가 16bit든 32bit든 64bit든 모두 16bit로 같은 크기를 갖지만 역할에는 조금 차이가 있다. 과거에는 시작 메모리 주소를 가리키는 것에만 사용되었으나, 보호모드와 IA-32e 모드에서는 단순하게 시작 주소를 가리키는 것을 넘어 접근 권환, segment 시작 주소, 크기 등을 지정하는 데에도 사용된다. 이런 기능들은 응용 프로그램으로부터 커널 영역을 보호하는 기능을 쉽게 구현하도록 만들었다. 

![image](https://user-images.githubusercontent.com/96677719/210203020-073e295d-5b0b-4801-b12e-b12e87db557c.png)

이러한 역할을 가진 세그먼트 레지스터는 위와 같은 구조를 가진다. 

위에서 언급된 시스템 관련 레지스터 내부에는 Global Descriptor Table, GDT가 존재하는데 이 안에는 Segment Descriptor Table SDT이 있다. 이러한 SDT는 세그먼트 레지스터의 역할이 바뀌면서 사용되기 시작했으며, 세그먼트 레지스터는 이 SDT의 인덱스 값을 가지고 각 세그먼트의 위치를 나타낸다. 

**Index**: 13bit로 SDT에 대한 index를 나타낸다

**TI**: Table Indicator, Descriptor Table이 Global이면 0, Local이면 1이 된다

**RPL**: 요구 특권 레벨 값을 나타낸다. Kernel이면 00, User면 11이 된다. 

**1) CS, code segment**

코드 영역의 시작 주소를 가리키는 포인터로 사용된다. 데이터 이동 명령으로 값을 변경할 수 없으며, 점프 명령, 인터럽트 관련 명령어로는 변경이 가능하다.

**2) DS, data segment**

데이터 영역의 시작 주소를 가리키는  포인터로 사용된다. 데이터 영역에 접근할 때 사용되며 데이터 이동 명령으로 값을 변경할 수 있다. 

**3) SS, data segment**

스택 영역의 시작 주소를 가리키는 포인터로 사용된다. 데이터 이동 명령으로 값 변경이 가능하며, 스택 관련 레지스터를 통해 접근할 때 사용된다. 

**4) ES, extra segment**

데이터 관련 확장 세그먼트로, 메모리 주소 지정을 다루는 문자열 관련 작업을 처리할 때 사용된다.

**5) FS/GS, general purpose segment**

데이터 관련 확장 세그먼트로, 운영체제별로 용도를 결정할 수 있는 범용적 용도로 사용된다. 

<br/>

**📌 Intruction Pointer Register, 명령어 포인터 레지스터 ( = Program Counter Register)**

RIP, EIP, IP

CPU가 이 다음에 어떤 명령어를 실행할지 가리키는 포인터로 사용된다. CPU는 IP가 가리키는 명령어를 한 뒤, 현재 수행하는 명령어 크기 만큼 크기를 증가 시켜 다음 실행할 명령어 주소를 찾는다. 32bit 운영체제에서는 EIP라 부르며 32bit를 가지고, 64bit 운영체제에서는 RIP라 표현하고 64bit를 가진다. 

<br/>

### **시스템 관련 레지스터**

**📌 Control Register, 컨트롤 레지스터**

운영체제의 운영 모드를 변경하거나 현재 운영 중인 모드의 기능을 제어하는 레지스터이다. 

![image](https://user-images.githubusercontent.com/96677719/210203903-96015f57-ef79-41a4-beca-481eb07474c5.png)


**1) CR0**

운영 모드를 제어하며 리얼 모드와 보호모드의 전환 역할을 한다. Cache, Paging, FPU(실수 연산 장치) 등과 관련된 영역을 포함하여, 해당 기능을 활성화/비활성화 한다.

**2) CR1**

프로세스에 의해 예약된 레지스터

**3) CR2**

페이지 폴트 발생 시 페이지 폴트 발생한 선형 주소가 저장되는 레지스터이며, 페이지 활성화 후에는 페이지 폴트 발생 시에만 유효한 값을 가진다.

**4) CR3**
 
페이지 디렉토리의 물리 주소와 페이지 캐시에 관련된 기능을 설정한다. 

**5) CR4**

프로세스에서 지원하는 각종 확장 기능을 제어하는 레지스터이며, 페이지 크기 확장이나 메모리 영역 확장 등의 기능을 활성화한다.

**6) CR8**

task 우선순위 레지스터의 값을 제어하며, 프로세스 외부에서 발생하는 인터럽트를 걸어주는 필터의 역할을 한다. IA-32e 모드에서만 접근 가능하다. 

IA-32e 64bit 확장 시 CR0, CR4, CR8 레지스터 64bit 중 상위 32bit, CR3의 40-51bit를 0으로 설정해주어야 한다. CR2의 경우 64bit 모두 사용 가능하다.

<br/>

**📌 Flag Register, 플래그 레지스터**

EFLAGS, RFLAGS

프로그램의 현재 상태를 검사하는데 사용되는 플래그들이 있는 레지스터. 상태 플래그, 컨트롤 플래그, 시스템 플래그들이 모여있다. 

 32bit 운영체제에서는 EFLAGS라 불리는 32bit 크기의 플래그 레지스터가, 64bit 운영체제에서는 RFLAGS라 불리는 64bit 크기의 플래그 레지스터가 존재한다. 64bit일 경우 최대 64개의 플래그를 저장할 수 있지만 실제로는 20여개의 bit만을 사용한다. 
 
 <br/>

**📌 그 외**

그 외에도 시스템 관련 레지스터에 포함되는 영역으로서, GDT 레지스터, IDT 레지스터, LDT 레지스터, T 레지스터, MS(모델 명세) 레지스터 등이 존재한다. 또, 이와 분리되는 영역으로 실수 연산 및 SIMD 관련 레지스터가 존재한다. (상단 그림 참조)

<br/>

 
### **출처**

Modern Operating Systems (4th Edition), Andrew S. Tanenbaum and Herbert Bos, Pearson

[C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈] Part1: C++ 프로그래밍 입문, Rookiss

https://velog.io/@1unaram/OS-Register

https://y0ubat.tistory.com/225

https://itguava.tistory.com/11

https://plummmm.tistory.com/113