---
title: 멀티스레드 1) 컴퓨터 구조 (3)
categories: WindowsSystem
tags: 
toc: true
toc_sticky: true
---

이 포스트는 윤성우님의 <뇌를 자극하는 윈도우즈 시스템 프로그래밍 (한빛미디어)> 내용을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 함수 호출과 스택**

## **1) 스택 프레임의 동작 원리**

함수 내에 선언되는 지역 변수는 스택에 할당된다. 이때 함수 호출 과정에서 할당되는 메모리 블록을 가리켜 스택 프레임이라 부른다. 함수 호출이 완료되고 나면 해당 함수에 할당되었던 메모리가 반환되면서, 일반적인 방법으로는 기존에 선언되었던 지역 변수에 접근할 수 없게 된다. 지역 변수를 위한 메모리 공간을 Stack이라 부르는 이유는 자료구조 Stack과 마찬가지로 LIFO의 구조적 특성을 갖기 때문이다. 스택프레임은 가장 먼저 할당된 것이 가장 나중에 반환된다. 이렇게 스택에 데이터를 쌓고 반환하기 위해서는 어느 위치까지 데이터를 저장했는지, 즉 현재 스택 위치를 기억해야 한다. CPU 에서는 이러한 스택 위치의 값을 Stack Pointer, sp라는 레지스터에 저장하고 사용하게 된다. 

sp 레지스터 값은 변수가 하나씩 할당될 때마다 데이터의 크기만큼 증가하면서 다음 변수가 할당될 메모리 위치를 가리키게 된다. 이러한 구조 덕분에 sp 위치를 아래로 이동시키는 것만으로도 이전에 선언된 변수를 반환할 수 있게 된다. 만약 호출된 함수가 종료될 경우 스택 프레임 단위로 sp 레지스터 값을 이동시켜 해당 함수 내의 모든 지역 변수를 동시에 반환하게 된다. 이때, 이전에 돌아갈 위치를 알기 위해 Frame Pointer, fp 라는 레지스터를 사용한다. 함수를 호출할 때마다 fp 에 돌아가야 하는 위치를 넣고 이를 Stack에 저장한 뒤 새로운 값으로 fp 레지스터를 덮어쓴다. 이러한 방식을 통해 함수가 반환될 때마다 어느 위치로 돌아가야 하는지 알 수 있다.  

이러한 스택 프레임의 동작 원리는 절차적 함수 호출을 지원하는 CPU에서 공통 분모처럼 사용된다. 

## **2) 함수 호출 인자의 전달 방식**

함수 호출 시 전달되는 인자를 Stack에 저장할지, 레지스터에 저장할지는 CPU의 종류에 따라 달라진다. 어셈블리를 확인해보면 ARM 코어, 64bit Intel 코어의 경우 레지스터를 적극 활용하는 반면 32bit Intel 코어는 Stack에 저장하는 것을 볼 수 있다. 이때 Stack을 활용하게 된다면 해당 인자값을 push를 이용해 전달하고, 함수가 반환될 때 pop을 이용해서 이 값들도 함께 반환해주어야 할 것이다. 스택에 인자값을 쌓을 때는 전달되는 순서대로 왼쪽 인자부터 시작하여 스택에 쌓는 구조와, 전달되는 순서의 역순으로 오른쪽 인자부터 스택에 쌓는 구조 두가지가 존재한다. 

<br/>

# **2. 함수 호출과 실행 위치 이동**

## **1) 메모리 구조와 PC**

![image](https://user-images.githubusercontent.com/96677719/214241564-be404632-c33f-40e3-a1a1-efa7bd9a589f.png)

프로세스의 메모리 구조는 위와 같다. 이 중 코드 영역의 경우, 프로그램이 동작하기 위한 프로그램 코드, 명령어들이 올라가는 위치이다.  Fetch - Decode _ Execution 단계가 진행될 때, 명령어를 Fetch 하는 위치가 바로 프로그램 코드가 존재하는 코드 영역이다. 이때, 어느 위치에 있는 명령어를 가져와야 하는지 가리키는 레지스터를 Program Counter, pc 레지스터라고 한다. 이러한 pc 값은 Fetch 연산이 일어날 때 자동으로 증가하여 다음 위치를 가리키기 때문에, 프로그래머가 직접 pc 값을 수정하지 않아도 자동으로 순차적 실행이 이루어진다. 간혹 프로그래머가 pc 값을 직접 조절해야 하는 상황이 생기기도 하는데 이는 추후에 다루고자 한다. 

## **2) 함수 호출과 함수 종료**

현재 명령어 직후에 함수가 호출될 예정이라면 pc가 호출될 함수를 가리키게 된다. pc에 함수 호출로 인해 이동해야 할 주소값을 저장해두면 자연스럽게 실행 위치가 이동한다. 그런데 이 전에 현재 pc 값을 백업해야, 함수가 반환된 이후 기존 함수로 돌아올 수 있다. 따라서 함수를 호출할 때 stack에 현재 pc 값, 즉 호출한 함수의 명령어 주소값을 push 한 후, 함수가 반환될 때 이를 참조하여 돌아오게 된다. 

<br/>

# **3. 함수 호출 규약**

## **1) 함수 호출 규약이란?**

함수를 반환할 때 할당된 스택 프레임을 반환하는 방법에는 크게 두가지, Hybrid 방법까지 포함할 경우 크게 세가지가 존재한다. 하나는 스택 프레임을 정리하는 명령어들을 호출한 함수의 스택 프레임에 쌓는 것이고, 또 하나는 호출된 함수의 스택 프레임에 쌓는 것이다. 이처럼 스택 프레임 반환 방법 등 함수의 호출, 반환과 관련된 정보들을 정해놓은 것을 가리켜 함수 호출 규약이라고 부른다. 위에서 언급했던 함수 호출 시 인자 전달 방법 역시 함수 호출 규약에 의해 정해진다.

## **2) 호출 규약 종류와 의미**

**32bit**

|Calling Convention|Parameters in Register|Parameter order on stack|Stack Cleanup By|
|---|---|---|---|
|__cdecl| |C|Caller|
|__stdcall| |C|Function|
|__fastcall|ecx,edx|C|Function|
|__thiscall|ecx|C|Function|

대표적으로 많이 비교되는 것은 __cdecl과 __stdcall 이다. 이 둘의 차이점은 스택 프레임을 반환하는 주체에 있다. __cdecl의 경우 호출한 함수 내에서, __stdcall의 경우 호출된 함수 내에서 스택 프레임을 반환한다. __fastcall의 경우 말그대로 함수 호출을 빠르게 처리하기 위한 호출 규약으로, 첫번째 인자와 두번째 인자를 ecx, edx에 저장한다. 이처럼 레지스터를 활용할 경우 접근 속도가 빠르기 때문에 함수 호출이 빨라질 수 있다. 이때, 두개를 넘어서는 인자에 대해서는 Stack을 사용한다. 

```c++
int __stdcall STDCallFunction(int a, int b, int c);
```

함수 호출 규약은 위와 같이 함수를 선언할 때 함께 명시한다. 호출 규약을 명시적으로 선언하지 않을 경우 프로젝트 속성창에서 확인할 수 있는 디폴트 선언을 따르게 된다. 참고로 Windows 시스템 함수의 CALLBACK, WINAPI은 __stdcall로 정의되어있는 매크로이므로, Windows 시스템 함수를 사용할 때는 이를 알고 있는 것이 좋다. 

**64bit**

|Calling Convention|Parameters in Register|Parameter order on stack|Stack Cleanup By|
|---|---|---|---|
|Windows|rcx/xmm0, rdx/xmm1, r8/xmm2, r9/xmm3|C|Caller|
|Linux, BSD|rdi, rsi, rdx, rcxm, r8, r9, xmm0-7|C|Caller|

64bit 기반의 운영체제에서는 함수 호출 규약이 운영체제에 따라 나뉜다. Windows 기반에서는 총 8개의 레지스터를 활용하여 전달 인자를 저장할 수 있는데, 이는 /를 기준으로 택 1이기 때문에 실제로 저장 가능한 전달 인자의 개수는 4개이다. 반면 Linux 혹은 BSD 계열 시스템에서는 최대 14개 인자까지 레지스터를 통해 처리한다. 

<br/>

# **출처**

뇌를 자극하는 윈도우즈 시스템 프로그래밍, 윤성우, 한빛미디어
