---
title: Procademy, Q2, 22) Network - Object Pool
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 객체 별 Object Pool**

Object Pool에서는 재사용을 위해 해제한 요소들을 List로 관리하는 게 일반적이다. 객체에 대한 포인터를 일렬로 갖다가, 해제하면 소멸자 호출 후 맨 위에 push 하고 요청 받으면 pop 해서 가져온 뒤 replacement new로 생성자를 호출하여 반환한다. 이때 FILO의 Stack 구조로 구현하면 최근에 사용했던 메모리이므로, 직렬화 버퍼처럼 자주 쓰는 객체면 Cache hit를 기대할 수 있다. 

이때 stack을 일반적인 방법으로 구현하거나 stl stack을 쓸 경우 Node를 생성하는 과정에서 내부적으로 new를 호출하기 때문에 오히려 성능 저하를 유발한다. 따라서 데이터를 그대로 List에 넣되, 애초부터 조금 크게 할당받아서 앞 뒤에 다음 노드에 대한 정보 및 오류 검증 값을 넣으면 이 문제를 해결할 수 있다. 

자료구조 List와 Object Pool를 비교했을 때, Pool은 new처럼 사용하므로 객체의 포인터를 반환한다. 반면 자료구조는 포인터를 반환하는 대신 값 복사를 통해 값을 돌려준다. Pool처럼 주소로 반환한다는 건 그 메모리의 앞 뒤까지 관리할 수 있는 권한을 주는 것이기 때문이다. 이런 차이 때문에 stl에서도 List, Stack 등의 자료구조는 data - next pointer 구조가 아닌 data pointer - next pointer 형태로 구현된다.  

생성자는 placement new를 통해 호출한다. 경우에 따라 생성자 소멸자 호출을 원하지 않을 수도 있는데, 이 경우 MemoryPool 할당 시 인자로 bool 값을 넣어서 구분하는 것이 좋다. 만약 매번 생성자, 소멸자 호출을 필요로 하지 않는 객체라면 맨 처음 할당, 마지막 반환 시에만 호출하고 이후의 해제 - 재할당 시에는 호출하지 않는다. 디폴트 생성자 외의 생성자도 사용하고 싶다면 가변인자 템플릿을 활용해야 한다. 

비정상적인 상황을 방지하기 위해 Pool의 MAX를 설정해두고 초과하면 nullptr을 반환하도록 할 수 있다. 이때, 정상적인 상황에서는 불가능한 수치로 설정하는 것이 좋다. 64bit와 달리 32bit에서는 유저 메모리를 다 써서 실패하는 상황이 실제로 생기는데, 이 경우 시스템이 아예 죽어서 롤백이 발생할 수 있다. nullptr을 반환하고 정상 종료 되게끔 유도하는 것이 훨씬 안전하다. Object Pool 별로 MAX를 다르게 정하고 다른 객체가 모니터링 하도록 만들 수도 있다. 

<br/>

# **2. 안전 장치**

힙의 경우 앞 뒤에 fdfd를 넣어서 침범을 확인하는데 이를 활용하여 앞뒤에 안전 장치를 넣을 수 있다. 할당, 반환하는 데이터를 기준으로 앞뒤에 특정 코드를 심어두고 그 코드가 없는 게 감지되면 예외를 내는 것이다. 이렇게 할 경우 MemoryPool.Free()에 엉뚱한 포인터를 넣으면 엉뚱한 소멸자가 호출되는 대신 예외가 날 것이다. 또, underflow, overflow 역시 동시에 체크할 수 있다. 

식별 코드로는 고정된 상수, type별 enum, 정해진 규칙에 의한 값 등 다 좋지만 Object Pool에 대한 정보와 인스턴스에 대한 정보를 담아서 다른 Pool, 다른 Instance끼리 구분이 되면 더 좋다. 이때 체크할 게 많을 수록 성능이 느려지기 때문에 #define으로 DEBUG모드랑 RELEASE 모드를 나눠서 만드는 것이 좋다. 

이때, template type의 크기에 따라 구조체 패딩이 달라지기 때문에 앞에 넣는 코드에 접근하려면 (int)(&(((A*)nullptr)->c)); 와 같은 방식을 활용해야 한다. nullptr을 구조체로 캐스팅 하면 시작점이 0이 되므로, 저렇게 접근한 후 int로 캐스팅 하면 offset을 구할 수 있다. 이 방법을 이용하면 런타임에서도 구조체 별 멤버의 정확한 위치를 알 수 있다. 



