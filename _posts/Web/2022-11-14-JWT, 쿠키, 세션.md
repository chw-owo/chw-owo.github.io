---
title: JWT,_쿠키,_세션
categories: Web
tags: 서버인증
toc: true
toc_sticky: true
---

## **0. http**

####  **📌HTTP의 특징 **

###### 1) 비연결성

서버의 자원을 절약하기 위해 클라이언트가 요청을 한 후 응답을 받으면 연결을 끊어버린다. 🔗

###### 2) 비상태성

연결이 끊어지면 더 이상 상태 정보를 유지하지 않는다. 

이러한 특징 때문에 웹은 사용자가 요청을 여러번 하여도 매번 사로운 사용자로 인식한다. 이런 특징을 보안하기 위해 사용자 정보를 유지할 수 있는 쿠키가 등장했다. 

#### **📌Cookie**

###### 1) 쿠키란?🍪

사용자가 방문한 웹사이트에서 사용자의 브라우저에 전송하는 작은 텍스트 조각으로 클라이언트 측에서 관리한다. 📃 유효시간을 명시하여서 브라우저를 끄더라도 유효시간 동안 상태가 유지되나 브라우저마다 저장되는 쿠키가 다르기 때문에 서버에서는 브라우저가 다르면 다른 사용자로 인식한다. 

###### 2) 쿠키 구성 요소🍪 

쿠키는 key-value 형태로 구성되고 String 형태로 이루어져있다. 서버에서 Set-Cookie 헤더를 이용해 쿠키 값을 세팅하여 이를 클라이언트로 보내면 해당 사이트에 접근했을 때 클라이언트가 세팅된 값을 쿠키 헤더에 세팅한다. 클라이언트가 이러한 reqeust 메세지를 다시 전달하면 서버가 이를 통해 상태 관리를 하게 된다. 

```
Set-Cookie 헤더 구조
Set-Cookie: name=value [; expires=date] [; path=path] [; domain=domain] [; secure]

Cookie 헤더 구조
Cookie: name1=value1 [; name2=value2] [; name3=value3]
```

name: 각 쿠키를 구별하는데 사용되는 이름

value: 쿠키가 갖고 있는 값

expires: 쿠키의 유효시간, ex) expires="Wdy, DD−Mon−YYYY HH:MM:SS GMT", Max-Age를 통해 지정된 만료일이 되면 디스크에서 쿠키가 제거된다. 

domain: 쿠키가 사용되는 도메인, ex) domain=nesoy.github.io
이 값이 현재 탐색 중인 도메인과 일치하지 않을 경우, “타사 쿠키”로 간주하여 브라우저에서 거부한다.

Path: 쿠키를 반환을 요청할 경로 ex) path=/, 도메인의 루트 경로로 이동할 경우 쿠키가 전송된다

secure: 보안 연결 설정

httpOnly:Http 외에 다른 통신 사용 가능 설정

ex) 실제 google.com에 대한 쿠키 헤더

![image](https://user-images.githubusercontent.com/96677719/149923273-529cb34d-10d6-4463-bda0-fc982a52f547.png)

![image](https://user-images.githubusercontent.com/96677719/149923297-25534656-0a21-406f-bdfb-271c250bebdb.png)

###### 3) 쿠키의 종류🍪 

Session Cookie: 만료시간을 설정하고 메모리에만 저장되며 브라우저 종료시 쿠키를 삭제한다.

Persistent Cookie: 장기간 유지되는 쿠키로 (ex Max-Age 1Year) 파일로 저장되어 브라우저 종료와 관계없이 사용된다. 

Secure Cookie: Https에서만 사용되는 쿠키로 쿠키 정보가 암호화되어서 전송된다. 
 
Third-Party Cookie: 방문한 도메인과 다른 도메인의 쿠키. 보통 광고 배너 등을 관리할 때 유입 경로 추적을 위해 사용한다. 

###### 3) 동작 방식

로그인을 예시로 들어보자

![image](https://user-images.githubusercontent.com/96677719/149920980-6373c286-0aa2-43ef-be9c-5cd807e9214c.png)

id, pw 정보를 담아서 POST 방식으로 보낸다. 

![image](https://user-images.githubusercontent.com/96677719/149921033-4a80b5ae-8261-479b-91b4-7cfbd0bcae30.png)

Set 쿠키 헤더에 의해 쿠키 값이 세팅된다. 이때 붉은 글씨 부분이 쿠키에 해당한다. 

![image](https://user-images.githubusercontent.com/96677719/149921067-0fd7f9a9-4300-4610-a6e2-5c916539a456.png)

웹사이트에 다시 접근하면 브라우저에서 쿠키값을 쿠키 헤더에 세팅하고, 이것으로 서버가 사용자를 인식하게 된다. 

![image](https://user-images.githubusercontent.com/96677719/149921118-82cefbaa-c93e-49aa-b9b9-1b0e4d35a7d4.png)

로그아웃 요청이 오면 서버에서 Set 쿠키 헤더에 삭제할 값을 입력하고 쿠키 정보가 사라진다. 

간단하게 도식화된 이미지

![image](https://user-images.githubusercontent.com/96677719/149923450-5a69c0b8-9905-4ec4-81be-efbfd059aae8.png)


###### 4) 역할

세션 관리: 로그인, 닉네임, 접속 시간, 장바구니 등 서버가 알아야할 정보를 저장한다.

개인화: 사용자마다 다르게 그 사람에게 적합한 페이지를 보여줄 수 있다.

트래킹 사용자의 행동과 패턴을 분석하고 기록한다.

=> 이러한 역할을 바탕으로 사용자가 어떤 경로로 사이트에 도달했는지 등을 기억하여 다음번에 더 간편하게 사이트를 방문할 수 있도록 활용한다. 또, 사이트에서 로그인 상태를 유지하고 사이트 환경설정을 기억하며 지역 관련 콘텐츠를 제공할 수 있다.

###### 5) 장점

클라이언트 단에서 처리하기 때문에 서버 부하는 낮으며 서버의 저장공간이 절약된다. 

###### 6) 한계점

🍪 한번에 하나의 정보만 저장할 수 있으며 각 쿠키는 4Byte를 넘을 수 없다. 사이트 당 20개, 모두 합쳐 300개가 최대로 허용 용량이 작다. 

🍪 쿠키에 대한 정보를 매 헤더에 추가해서 보내기 때문에 트래픽을 발생시킬 수 있으며, 쿠키가 커지면 네트워크 부하도 커진다. 

🍪 웹 브라우저마다 지원 형태가 다르기 ㄸ문에 브라우저를 변경할 경우 다른 웹 브라우저에서 저장한 쿠키값을 사용할 수 없다. 

🍪 request시에 쿠키 값을 그대로 보낸다. 또, 클라이언트 단에서 작업이 이루어지기에 중간에서 유출될 위험이 있다. 이처럼 보안 수준이 낮기 때문에 결제 정보등을 쿠키에 저장하였을 때 쿠키가 유출되면 보안 문제가 발생할 수 있다. 

## 📌 **세션**

#### **1) 세션이란? 🎸**

쿠키를 기반으로 동작하지만 클라이언트에 저장하는 쿠키와 달리 서버에 저장한다. 그리고 클라이언트를 구별하기 위해 세션 ID를 부여하여 클라이언트가 종료될 때까지 유지한다. 따라서 보안에 있어서 쿠키보다 유리하다.

#### **2) 동작 방식**

1.서버에서는 클라이언트에게 고유한 세션ID를 부여하고 세션 저장소에 저장한 후 클라이언트에게 발급한다.

2.클라이언트는 서버에서 발급받은 세션ID를 쿠키에 저장하게 되고 요청을 보낼 때 마다 쿠키를 보낸다.

3.서버는 쿠키에 담겨있는 세션ID와 세션 저장소에 있는 정보와 대조한 후 데이터를 가져온다.

#### **3) 장단점**

사용자마다 고유한 세션 ID가 발급되기 때문에, 요청이 들어올 때마다 회원정보를 확인하지 않아도 된다

쿠키가 외부에 노출되어도 세션 ID 자체는 개인 정보를 담고 있지 않는다. 그러나 이를 이용해 클라이언트인척 위장할 수 있다는 한계가 존재한다. 

서버에서 세션 저장소를 사용하므로 요청이 많아지면 서버에 부하가 걸린다. 

## 📌 **JWT**

#### **1) JWT, 토큰이란?**

JWT는 Json Web Token의 약자이고 인증에 필요한 정보들을 암호화시킨 토큰을 말한다. 세션 방식처럼 토큰 자체를 쿠키에 담아서 보내줄 수도 있고 HTTP 헤더에 담아서 보내줄 수도 있다.

#### **2) JWT의 구성요소**


![image](https://user-images.githubusercontent.com/96677719/150911456-b1dad063-1661-4311-961c-3968f4d372a6.png)

JWT는 .을 구분자로 나누어지는 세개의 암호화된 문자열의 조합이다. 이를 디코딩 하면 아래와 같은 3가지 구성요소로 이루어진다. 

![image](https://user-images.githubusercontent.com/96677719/150911466-d144bbab-389f-49cc-a363-c4c762086ef2.png)

Header: 3가지 요소를 암호화할 알고리즘 등이 들어간다.


![image](https://user-images.githubusercontent.com/96677719/150911485-b2180680-cb82-4504-846a-849564aeb534.png)

Payload: 유저의 고유 ID 등 인증에 필요한 정보가 들어간다.


![image](https://user-images.githubusercontent.com/96677719/150911497-4d42888f-364f-4da4-ad2d-ad9a76df89b4.png)

Verify Signature: Header, Payload와 Secret Key가 더해져 암호화된다. Secret Key를 알지 못하면 VerifySignature를 복호화 할 수 없다. 따라서 토큰을 변조하더라도 VerifySignature가 Payload를 기반으로 암호화 되었기 때문에 유효하지 않은 토큰으로
검증이 가능하다.

#### **3) JWT의 동작 방식**

클라이언트가 로그인을 요청하면

서버에서 유저의 고유한 ID와 다른 인증 정보들을 Payload에 담는다.

그 후 JWT의 유효기간 설정 및 옵션을 설정하고 Secret Key를 이용해 토큰을 발급한다.

발급된 토큰은 클라이언트에 쿠키 혹은 로컬스토리지 등에 저장하여 요청을 보낼 때마다 같이 보낸다.

서버는 토큰을 Secret Key로 복호화하여 검증하는 과정을 거친다.

검증이 완료되면 대응하는 데이터를 보내준다.

#### **4) 장점**

Header와 Payload를 가지고 Signature를 생성하므로 데이터 위변조를 막을 수 있다.

인증 정보에 대한 별도의 저장소가 필요없다. 

JWT는 토큰에 정보와 시그니처를 자체적으로 지니고 있으므로 인증 정보를 저장하는 세션과 다르게 서버에서 일을 하지 않아도 된다. 

OAuth의 경우 Facebook, Google 등 소셜 계정을 이용하여 다른 웹서비스에서도 로그인을 할 수 있다.

확장성이 우수하여 웹 서비스 뿐 아니라 모바일 어플리케이션 환경에서도 잘 동작한다.

#### **5) 단점**

쿠키/세션과 다르게 JWT는 토큰의 길이가 길어, 인증 요청이 많아질수록 네트워크 부하가 심해진다.

Payload 자체는 암호화되지 않기 때문에 유저의 중요한 정보를 담을 수 없다. 

쿠키, 세션 인증은 서버쪽에서 세션을 삭제할 수 있는 반면 토큰은 한 번 발급되면 유효기간이 만료될 때 까지 계속 사용이 가능하기 때문에 탈취되면 대응 방법이 없다. 

#### **6) 극복 방법**

토큰을 만들 때 만료 기한을 짧게 설정하는 방법이 있다. 대신 사용자가 자주 로그인을 해야 한다.

글을 작성하는 도중 토큰이 만료 되면 이전에 작성한 글이 날아갈 수 있다. Sliding Session을 이용하면 글 작성을 시작할 때 새로운 토큰을 발급해줄 수 있어서 이러한 일을 막을 수 있다.

클라이언트가 로그인 요청을 보냈을 때, 서버가 Access Token 및 그보다 긴 만료 기간을 가진 Refresh Token을 발급하는 방법이 있다. 클라이언트는 Access Token이 만료되었을 때 Refresh Token을 사용하여 Access Token의 재발급을 요청하고 서버는 DB에 저장된 Refresh Token과 비교하여 유효한 경우 새로운 Access Token을 발급한다. 이 방법을 사용하면 만료 기한을 짧게 설정하면서도 자주 로그인하지 않아도 된다. 또 서버가 강제로 Refresh Token을 만료시킬 수 있다.

그러나 서버가 Refresh Token을 별도의 storage에 저장해야 하기 때문에 JWT의 장점인 빠른 인증 처리를 제대로 누릴 수 없다.

출처: 

https://policies.google.com/technologies/cookies?hl=ko

https://www.inflearn.com/course/%EC%9B%B9-%EA%B8%B0%EC%88%A0-%EA%B8%B0%EC%B4%88

https://victorydntmd.tistory.com/34

https://nesoy.github.io/articles/2017-03/Session-Cookie

https://velog.io/@jsj3282/%EC%BF%A0%ED%82%A4%EC%99%80-%EC%84%B8%EC%85%98%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90

https://velog.io/@stampid/%EC%BF%A0%ED%82%A4-%EC%84%B8%EC%85%98-%EA%B7%B8%EB%A6%AC%EA%B3%A0-JWT
