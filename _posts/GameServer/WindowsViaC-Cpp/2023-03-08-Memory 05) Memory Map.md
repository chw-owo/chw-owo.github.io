---
title: Memory 05) Memory Map
categories: WindowsViaC-Cpp
tags: 
toc: true
toc_sticky: true
---

이 포스트는 <제프리 리처의 Windows via C/C++ (한빛미디어)> 내용을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 메모리 맵**

## **1) 메모리 맵이란?**

MS는 파일 IO 작업 수행을 돕기 위해 메모리 맵 파일을 제공한다. 이것은 가상 메모리처럼 주소 공간을 예약하고 예약된 영역에 물리적 저장소를 커밋하는 기능을 제공하는데, 이때 페이징 파일을 사용하는 대신 디스크 상에 있는 파일을 물리적 저장소로 사용한다. 파일이 영역에 매핑되면 메모리에 파일 내용이 모두 로드된 것처럼 사용할 수 있다. 

## **2) 메모리 맵의 목적**

메모리 맵은 크게 세가지 목적으로 사용된다. 첫째로, 시스템은 exe, dll 파일을 읽고 수행할 때 메모리 맵 파일을 사용함으로서 페이징 파일 크기와 애플리케이션 시작 시간을 일정하게 유지한다. 둘째로, 디스크에 있는 데이터에 접근할 때 이를 사용하면 파일 IO 작업 및 버퍼링을 자동으로 수행해준다. 마지막으로, 동일한 머신에서 프로세스들 간 데이터 공유를 위해 메모리 맵 파일을 사용할 수 있다. 실제로 윈도우가 제공하는 방법 중 상당수는 내부적으로 메모리 맵 파일로 구현되어 있다. 

<br/>

# **2. exe, dll에 대한 메모리 맵**

## **1) exe, dll에 대한 메모리 맵 수행 방식**

CreateProcess를 호출하면 우선 시스템은 매개변수로 전달된 exe 파일을 찾고 프로세스 커널 오브젝트 및 전용 주소 공간을 생성한 다음 물리적 저장소로 페이징 파일 대신 exe 파일 자체를 지정한다. 그 후 exe에서 사용되는 dll 파일 목록을 가져와 이에 대해서도 exe와 유사한 작업을 반복 수행한다. 모든 파일이 매핑되고 나면 exe의 시작 코드를 수행하면서 프로세스가 수행된다.

만약 이미 수행 중인 애플리케이션을 다시 한번 수행하면 시스템은 새로운 메모리 맵 뷰에 대해 열기 작업을 수행한다. 이 메모리 맵 뷰는 앞서 수행했던 실행 파일 이미지를 가리키는 파일 매핑 오브젝트를 투영하고 있다. 이를 이용해 새로운 프로세스가 램 상에 이미 로드된 코드와 데이터를 공유할 수 있도록 한다. 

그러나 이는 특정 인스턴스가 데이터 페이지의 전역 변수를 변경하면 동일 애플리케이션 인스턴스의 메모리 내용이 모두 변경된다는 문제가 있다. 따라서 시스템은 카피 온 라이트 기능을 이용하여, 메모리 맵 파일 내용 변경을 시도할 경우 이를 감지하여 가상 메모리에 새로운 블록을 할당하고 페이지 내용을 복사하도록 하고 있다. 그럼 새롭게 할당된 메모리 블록에 변경을 수행함으로써 다른 인스턴스에 영향을 주지 않게 된다. 

## **2) exe, dll에 대한 데이터 공유**

때로는 전역 변수의 내용이 공유되어야 할 때도 있는데, 이는 섹션 기법을 이용하여 구현한다. 모든 exe, dll 파일 이미지는 .text, .bss, .data 등 섹션들의 집합으로 구성되며 이들은 READ, WRITE, EXECUTE, SHARED 등의 특성 값을 갖는다. 이때 #pragma data_seg("custom_section") 과 같은 지시어로 직접 섹션 이름을 지정하고 섹션 속성을 지정할 수 있다. 

```c++
#pragma data_seg("Shared")
LONG g_lInstanceCount = 0;
#pragma data_Seg()
#pragma comment(linker, "/SECTION:Shared,RWS")

 __declspec(allocate("Shared")) LONG g_lInstanceCountMax = 0;
```
#pragma comment(linker, "/SECTION:Shared,RWS") 이와 같은 행을 포함할 경우 링커에게 Shared 섹션은 READ, WRITE, SHARE 속성을 갖는다고 통보하게 된다. 그럼 컴파일러는 .obj 파일 안에 .drectve 라는 특수한 섹션을 생성하여 그 안에 지정된 문자열을 포함한다. 그럼 링커가 .obj를 결합할 때 이를 바탕으로 해당 문자열이 링커의 명령행 인자로 전달된 것처럼 링크를 수행하는 것이다. 

하지만 MS는 공유 섹션을 사용하지 말 것을 권고한다. 공유 메모리 사용은 잠재적으로 보안에 취약해질 가능성이 있으며, 공유 변수를 사용할 경우 특정 애플리케이션 내 에러가 다른 애플리케이션에 직접적인 영향을 줄 수 있게 되기 때문이다. 

<br/>

# **3. 메모리 맵 데이터 파일**

## **1) 메모리 맵 데이터 파일**

운영체제는 프로세스 주소 공간에 데이터 파일을 매핑할 수 있기 때문에 크기가 큰 데이터 스트림을 편리하게 다룰 수 있다. 메모리 맵 데이터 파일을 사용하지 않고 파일의 바이트를 뒤집는 작업을 수행한다고 가정해보자. 우선 버퍼를 파일 크기만큼의 할당해야 하며, 이전 파일 내용을 일정 시간 유지해두기 위한 메모리 공간이 또 필요할 것이다. 하지만 메모리 맵 데이터 파일을 사용하면 이런 공간을 절약할 수 있다. 

메모리 맵 파일을 이용하면 우선 가상 주소 공간에 영역을 예약한 뒤 파일의 첫번째 바이트와 예약된 영역의 첫번째 위치를 매핑한다. 그럼 가상 메모리 주소에 접근하는 것만으로도 파일에 접근하는 것과 동일하게 사용할 수 있으며, 파일에 대한 캐싱 작업도 시스템이 직접 수행해준다. 메모리 할당과 해제, 읽고 쓰는 작업을 사용자가 직접 수행하지 않아도 되는 것이다. 단 갑자기 전원이 차단될 경우 데이터 소실의 위험이 있다.

## **2) 메모리 맵 파일 생성하기**

메모리 맵 파일을 위와 같이 사용하려면 우선 CreateFile로 파일 오브젝트를 생성해야 한다. 이후 그 핸들로 CreateFileMapping 함수를 호출하면 파일 매핑 커널 오브젝트를 생성하게 된다. 이때 생성에 실패하면 CreateFile이 INVALID_HANDLE_VALUE(-1)을 반환하는 것과 달리 CreaetFileMapping은 NULL을 반환한다. 

CreateFileMapping 함수는 fdwProtect 매개변수로 보호 특성을 지정하는데, 이 값은 PAGE_READONLY, PAGE_READWRIT, PAGE_WRITECOPY, PAGE_EXECUTE_READ, PAGE_EXECUTE_READWRITE 중에서 설정할 수 있다. 동시에 섹션 특성을 OR로 전달할 수 있으며 섹션 특성으로는 SEC_NOCACHE, SEC_IMAGE, SEC_RESERVE, SEC_COMMIT, SER_LARGE_PAGES 가 있다. 

SEC_NOCACHE는 매핑 파일에 대해 캐시를 수행하지 못하도록 하며, 이를 설정하면 더 자주 파일 갱신 작업을 수행하게 된다. 이는 PAGE_NOCACHE와 마찬가지로 디바이스 드라이버 개발에서 주로 사용되며 일반 애플리케이션 개발에서는 거의 사용되지 않는다. 

SEC_IMAGE는 매핑 파일이 PE, Portable Executable 파일 이미지임을 알려준다. PE 파일의 코드 섹션은 일반적으로 PAGE_EXECUTE_READ로, 데이터 섹션은 PAGE_READWRITE 특성으로 매핑되는데, SEC_IMAGE를 전달하면 시스템이 파일 이미지를 매핑하고 적절한 페이지 보호 특성을 결정할 수 있게 된다.  

SEC_RESERVE, SEC_COMMIT는 상호 배타적으로 사용되어야 하는 특성으로, 메모리 맵 데이터 파일을 사용할 경우에는 사용할 수 없다. 이는 스파스 메모리 맵 파일을 배운 후 다시 설명할 것이며, 파일 맵 데이터 파일을 생성하는 경우에는 이 플래그를 지정해도 CreateFileMapping이 이를 무시한다. 

SER_LARGE_PAGES는 매핑할 이미지에 대해 램 상에 큰 페이지를 사용할 것을 지정한다. 이는 PE 이미지 파일이나 메모리에서만 사용되는 맵 파일에 대해서만 의미를 가지며, VirtualAlloc으로 큰 페이지 할당 기능을 사용했을 때와 동일한 조건이 충족되어야만 사용 가능하다. 메모리 맵 데이터 파일을 매핑하는 상황에서는 이 플래그를 사용할 수 없다.

## **3) 메모리 맵 매핑하기**

메모리 맵 생성 절차는 커밋하는 과정과 매우 유사하며 저장소가 페이징 파일이 아니라 디스크 상 파일에 있다는 점에서만 차이가 있다. 따라서 매핑 오브젝트를 생성한다고 바로 영역을 예약, 매핑하지는 않으며 매핑 오브젝트 핸들로 MapViewOfFile 함수를 호출해야 한다. 이때 할당 단위 크기 배수로 파일 위치를 지정해야 한다.

이때 MapViewOfFile는 파일 전체를 매핑하는 대신 일정 부분만 분리하여 매핑하는데, 이렇게 매핑된 일부를 View라고 부른다. 실제로 큰 파일을 처리할 때는 파일의 일부만 뷰를 통해 접근한 뒤, 매핑을 해제하고 다시 다른 부분에 대한 뷰를 구성하여 매핑하는 과정을 반복해야 한다. 

MapViewOfFile를 호출할 땐 dwDesiredAccess 인자를 통해 데이터에 어떻게 접근할 것인지를 전달해야 한다. FILE_MAP_WRITE, FILE_MAP_READ, FILE_MAP_ALL_ACCESS, FILE_MAP_COPY, FILE_MAP_EXECUTE 중 하나를 지정한다. 나머지 세개의 매개변수는 주소 공간 상 영역을 예약하고 매핑하기 위한 정보들이다. 

단일 파일 매핑 오브젝트를 여러 개의 뷰를 이용해 매핑하는 경우 파일 내 데이터에 대한 일관성이 유지된다. 즉, 특정 뷰를 통해 내용을 변경했을 때 다른 뷰에도 그 변경 사항이 모두 반영되는 것이다. 실제로는 단일의 램 페이지들에만 데이터가 유지되고 있기 때문이다. 

이를 바꾸어 말하자면 각 프로세스들의 독립 주소 공간에 동일한 램 페이지들을 매핑할 수 있다. 이미 다른 프로세스에서 매핑되고 있는 파일이라도 읽기 쓰기 작업을 진행할 수 있으며 이는 위험한 상황으로 이어질 수 있다. 따라서 읽기 전용이 아닌 상황에서 매핑을 위해 CreateFile을 쓴다면 dwShareMode를 0으로 지정하기를 권장한다. 

## **4) 메모리 맵 파일 시작 주소 지정**

MapViewOfFileEx를 사용하면 매핑할 시작 주소를 지정할 수 있는데, 마지막 매개변수 pvBaseAddress로 매핑하고자 하는 메모리의 시작 주소를 전달하면 된다. 이 값에 NULL을 입력하면 MapViewOfFile과 동일하게 동작한다. 만약 이 값을 할당 단위 배수로 전달하지 않았거나, 지정한 주소에 매핑할 수 없는 경우엔 NULL을 반환한다.

링크드 리스트 같이 자료구조가 포인터를 갖고 있고, 이를 프로세스끼리 공유하는 경우에 유용하게 사용된다. 한 프로세스가 링크드 리스트를 맵 파일에 구성하고 이를 다른 프로세스가 공유할 때, 해당 맵 파일을 다른 주소에 매핑하면서 유효하지 않은 주소를 가리키게 될 수 있기 때문이다. MapViewOfFileEx으로 매핑 위치를 지정하면 이러한 상황을 피할 수 있다. 

MapViewOfFileEx으로 매핑 위치를 지정한 뒤 프로세스 간 통신으로 이 주소를 전달할 수도 있고, 노드를 삽입할 때 노드 주소를 시작 주소로부터의 오프셋으로 지정할 수도 있다. 후자의 방법은 노드에 접근할 때마다 오프셋 값을 더하는 연산이 추가되기 때문에 성능 저하를 일으킬 가능성이 커서 되도록 전자를 권장한다.

## **5). 메모리 맵을 통한 데이터 공유**

윈도우에서는 RPC, COM, DDE, 윈도우 메시지, 클립보드, 메일슬롯, 파이프, 소켓 등의 메커니즘을 이용해 애플리케이션 간 데이터를 빠르게 공유할 수 있다. 이때 단일 머신 내 데이터를 공유하는 가장 저수준, 저비용의 메커니즘은 메모리 맵 파일이다. 앞서 말한 방법들 역시 단일 머신에서 수행하는 경우 결국 메모리 맵 파일을 이용해 작업을 수행하게 된다. 

동일한 파일 매핑 오브젝트에 대해 프로세스 별로 뷰를 매핑하면 결국 그 프로세스들은 물리적 저장소를 공유하게 되고, 한 프로세스에서  데이터를 변경할 경우 다른 프로세스도 뷰를 통해 변경사항을 즉각 반영할 수 있다. 이때 여러 프로세스가 핸들 상속, 명명, 핸들 복사와 같은 방법을 이용해 단일 파일 매핑 오브젝트를 공유할 수 있으며, 이때 동일한 매핑 오브젝트 이름을 사용해야 한다.

## **6) 메모리 맵 파일 저장하기**

데이터를 쓸 때 지체 없이 변경 작업을 저장하고 싶다면 FlushViewOfFile과 같은 함수를 명시적으로 호출해주어야 한다. 속도 측면에서 보면 시스템은 파일 데이터의 페이지를 버퍼링하기 때문에 뷰 내용을 변경한다고 해서 파일로 즉각 반영되지 않기 때문이다.

이때 메모리 맵 파일이 네트워크로 연결된 리모트 서버에 있는 저장소일 경우, 서버가 파일의 데이터들을 캐싱할 수 있기 때문에 서버로 변경사항이 전달되는 것까지는 보장할 수 있지만 디스크 드라이브에 저장되는 것은 보장할 수 없다. 디스크 드라이브에 완전히 저장된 이후 FlushViewOfFile가 반환되도록 하고 싶다면 CreateFile에 FILE_FLAG_WRITE_THROUGH를 전달하면 된다.

## **7) 메모리 맵 파일 삭제하기**

다 쓴 이후에는 UnmapViewOfFile로 매핑 해제를 한 후, 각각 오브젝트에 대한 CloseHandle 작업을 해주어야 한다. 이때 UnmapViewOfFile를 호출하지 않으면 예약된 공간이 프로세스를 종료할 때까지 해제되지 않으며, MapViewOfFile은 호출될 때마다 앞서 예약되었던 영역을 그대로 둔 채 새로운 영역을 확보한다. 삭제 예제는 아래와 같다. 

```c++
HANDLE hFile = CreateFile(...);
HANDLE hFileMapping = CreateFileMapping(hFile, ...);
CloseHandle(hFile);

PVOID pvFile = MapViewOfFile(hFileMapping, ...);
CloseHandle(hFileMapping);

// ...

UnmapViewOfFile(pvFile);
```

주의해야 할 것은 만일 뷰가 FILE_MAP_COPY 플래그로 매핑된 경우 파일의 내용을 변경하면 시스템의 페이징 파일이 그 내용에 복사되고 복사된 데이터가 변경된다. 이 상황에서 UnmapViewOfFile를 호출하면 매핑된 파일에는 갱신 내용이 없기 때문에 페이징 파일에 할당한 메모리를 해제하는 작업만 수행되며, 앞서 변경한 내용은 소실된다. 

이러한 경우에 파일 변경 내용을 유지하고 싶다면 동일 파일에 대해 FILE_MAP_WRITE 플래그를 이용해 추가적인 매핑 오브젝트를 생성하고, 이후 FILE_MAP_COPY로 생성했던 이전 뷰의 페이지들을 검색해서 특성이 PAGE_READWRITE로 변경된 페이지를 찾는다. 여기에서 해당 페이지 내용이 변경되었는지 검토하고 그 내용을 MoveMemory를 이용해 추가적으로 생성한 뷰에 복사하면 된다.  

<br/>

# **4. 스파스 메모리 맵 파일**

## **1) 메모리 맵과 VirtualAlloc**

만약 파일 매핑 오브젝트로 표를 공유한다면, 실제로 쓰이는 것은 일부분의 셀이기 때문에 표 전체만큼 메모리를 할당하는 것은 낭비가 될 수 있다. 따라서 SEC_RESERVE, SEC_COMMIT 플래그로 예약과 커밋을 분리하는 것이 좋다. 이때 예약, 공유한 영역에 커밋을 시도할 때도 VirtualAlloc을 사용한다. 이때 SEC_RESERVE 플래그를 이용한 영역은 VirtualAlloc을 했더라도 VirtualFree로 디커밋할 수 없다.

## **2) 페이징 파일 메모리 맵**

만약 수행 중 생성한 데이터를 공유하고 싶다면, 디스크에 번거롭게 저장하지 않고도 페이징 파일을 이용해 메모리 맵을 생성할 수 있다. CreateFileMapping에 핸들 대신 INVALID_HANDLE_VALUE를 전달하면 페이징 파일을 물리적 저장소로 사용한다는 뜻이 된다. 이때 이 값이 CreateFile 실패 반환값과 같다 보니 의도하지 않게 이런 동작을 하게 될 수도 있으므로, CreateFile 이후엔 반환 값을 반드시 확인해야 한다. 

다른 프로세스와 데이터를 공유할 때는 CreateFileMapping의 pszName 매개변수로 이름을 지정하여, 타 프로세스에서 그 이름을 이용해 커널 오브젝트를 열어주면 된다. 다 사용한 뒤엔 CloseHandle를 반드시 해주어야 하며 모든 핸들이 닫히면 페이징 파일 내 커밋된 저장소가 해제 된다. 

## **3) 스파스 파일**

NT 파일 시스템은 스파스 파일을 제공하는데, 이를 이용하면 페이징 파일이 아니라 디스크 상 존재하는 파일을 이용해서도 스파스 메모리 맵 파일을 쉽게 생성할 수 있다. 또, 이런 기능을 이용하면 크기가 증가하는 메모리 맵 파일을 구현할 수 있기 때문에 저장하게 될 데이터가 어느 정도 크기인지 알 수 없는 상황에서 유용하게 사용될 수 있다. 

우선 최초의 메모리 맵 파일은 어떤 저장소도 사용하지 않는 상태로 초기화한다. 그 후 처음으로 값을 쓸 때 1KB 단위로 저장소를 커밋하고, 그 저장소를 초과할 때 다시 1KB를 더 커밋하기를 반복한다. 만약 파일을 닫을 때 논리적인 크기를 알고 싶다면 스파스 파일을 0으로 채운 후 디스크 공간에 영향을 주지 않는 끝부분을 제거함으로써 크기를 얻을 수 있다. 이때 SetFilePointer, SetEndOfFile 함수를 사용해 파일 끝을 설정한다.