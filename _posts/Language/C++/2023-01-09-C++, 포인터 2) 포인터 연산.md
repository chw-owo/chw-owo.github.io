---
title: C++, 포인터 2) 포인터 연산
categories: C++
tags: 
toc: true
toc_sticky: true
---

## **1. 주소 연산자 (&)**

```c++
int* ptr = &number;
```

변수 앞에 붙어서 해당 변수의 주소를 알려주는 역할을 한다. 

<br/>

## **2. 산술 연산자 (+, -)**

```c++
ptr = ptr + 1;
ptr += 1;
ptr++;
```
일반적인 변수에서 사용했던 산술 연산자(+, -)를 포인터에서도 사용할 수 있다. 그러나 일반적인 변수에서의 산술 연산자와 살짝 다른 의미를 가진다. 

위의 방법 중 하나를 사용하여 ptr에 1을 더한뒤 메모리를 확인해보면 ptr의 값이 1이 아니라 4만큼 증가한 것을 확인할 수 있다. 이는 ptr를 대상으로 한 (+, -)연산의 경우, 정말 산술적인 연산을 의미하는 것이 아니라 한번에 그 TYPE의 크기만큼 이동하라는 의미이기 때문이다. 현재는 int가 4byte 자료형이라 4만큼 증가했지만 8byte 자료형일 경우 8만큼 증가하게 된다. 

어셈블리어를 확인해보면 아래와 같이 작동한다. 
```
mov     eax, dword ptr [ptr]
add     eax, 4
mov     dword ptr [ptr], eax
```
단순하게 4를 더하는 것을 확인할 수 있다. 

<br/>

## **3. 간접 연산자 (*)**

```c++
*pointer = 3;
```

위의 코드는 해당 주소의 값에 가서 값을 3으로 바꿔라 라는 의미가 된다. 이처럼 포인터에 들어있는 주소의 값에 접근할 때 사용하는 *을 간접 연산자라고 한다.

<br/>

## **4. 간접 멤버 연산자 (->)**

struct로 만든 자료형도 포인터를 사용할 수 있다. 

```c++
struct Player
{
    int hp;
    int mp;
}

int main()
{
    Player chw;
    chw.hp = 100;
    chw.mp = 120;

    Player* chwPtr = &ptr;
    (*chwPtr).hp = 200;
    (*chwPtr).mp = 220;

    return 0;
}
```
이 중에서 포인터를 사용하는 부분만 어셈블리어로 보자면 다음과 같다. 

**c++**

```c++
Player* chwPtr = &ptr;
(*chwPtr).hp = 200;
(*chwPtr).mp = 200;
```

**Assembly**

```
lea     eax, [chw]
mov     dword ptr [chwPtr], eax

mov     eax dword ptr [chwPtr]
mov     dword ptr [eax], 0C8h

mov     eax dword ptr [chwPtr]
mov     dword ptr [eax + 4], 0C8h
```

이처럼 구조체 포인터를 이용할 경우 Player 구조체에서 hp는 +0 위치에, mp는 +4 위치에 자리하는 것을 이용하여 값에 접근하게 된다. 

```c++
chwPtr -> hp = 200;
chwPtr -> mp = 200;
```

이것을 간단하게 표시하면 위와 같이 간접 멤버 연산자로 표시할 수 있다. 간접 멤버 연산자는 구조체의 특정 멤버를 다룰 때 사용하며, 의미와 작동 방식은 위에서 쓴 것과 동일하다. 

<br/>


## **출처**

[C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈] Part1: C++ 프로그래밍 입문, Rookiss