---
title: 어셈블리어 기초 문법
categories: OS
tags: 
toc: true
toc_sticky: true
---

## **1. 레지스터**

**1) 레지스터 구조**

자세한 건 [레지스터 구조](https://chw-owo.github.io/os/%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0/) 포스트 참조

![image](https://user-images.githubusercontent.com/96677719/210197187-a07880a9-7b0e-46a8-9230-7edf097e2791.png)

우리가 연산을 할 때 직접 사용할 수 있는 대표적인 범용 레지스터로는 AX, BX, CX, DX가 있다. AX, BX, CX, DX는 총 16bit 크기의 레지스터로 원래는 16bit를 사용하던 시절에 기본 단위로 정해졌다. 이 중 앞의 8bit를 High라는 접미사를 붙여서 AH, 뒤의 8bit를 Low라는 접미사를 붙여서 AL이라 칭한다. 그러나 운영체제가 32bit, 64bit로 발전함에 따라 최근에는 32bit의 EAX, EBX, ECX, EDX, 64bit의 RAX, RBX, RDX, RDX가 이의 기본 단위로 변경되었다. 이 글은 64bit 운영체제를 사용한다고 가정하여 R_X를 기본 단위로 사용하려고 한다. 

따라서 

**R_X**는 해당 레지스터의 전체 64bit, 즉 0-63에 해당하는 영역을 가리킨다.  

**E_X**는 해당 R_X의 하위 32bit, 즉 0-31에 해당하는 영역을 가리킨다.

**AX**는 해당 R_X의 하위 16bit를, 즉 0-15에 해당하는 영역을 가리킨다.

**AH**는 해당 R_X의 8-15에 해당하는 영역을, **AL**는 0-7에 해당하는 영역을 가리킨다. 

어셈블리어를 사용할 때는 이러한 레지스터 이름에 직접 접근하므로, 각 이름이 어떤 위치를 가리키는지 간단하게 알고 있어야 한다. 실제로 AX, BX, CX, DX는 쓰이는 용도가 조금씩 다르지만 기초 문법을 설명함에 있어서는 다 동일한 저장공간이라 가정하고 진행하려 한다. 

<br/>

**2) mov, 레지스터에 값 쓰기**
```
mov [register 이름 1], [값]  
```
register 1에 값을 넣는다
```
mov [register 이름 1], [register 이름 2]
```
register 1에 register 2의 값을 복사하여 넣는다

<br/>

실제 레지스터 이름으로 예시를 들어보면 다음과 같다
```
mov rax, 0x12345678
```
이렇게 넣을 경우 어셈블러를 통해 레지스터에 들어간 값을 직접 확인해보면 rax에 0x12345678이 올바르게 들어가 있는 것을 확인할 수 있다. 

<br/>



```
mov eax, 0x12345678
```
그러나 위와 같이 적을 경우 에러가 나며 실행이 되지 않는데, 이는 0x12345678이 eax의 크기인 32bit를 초과하기 때문이다. 
```
mov eax, 0x1234
```
따라서 위와 같이 각 레지스터 이름의 크기에 맞게끔 값을 넣어주어야 한다.

<br/>

그럼 아래처럼 코드를 작성하고 실행하면 어떻게 될까?

```
mov rax, 0x12345678
mov eax, 0x1234
```
처음에는 rax에 0x12345678이 들어갈 것이다. 그러나 그 이후 eax, 즉 rax의 하위 32비트에 0x1234가 들어가면서 rax에 있는 값이 0x12341234로 바뀔 것이다. 

<br/>

**3) 레지스터와 변수**

메모리에 데이터를 올리고 싶다면 section.data과 section.bss를 사용하면 된다. data, bss가 무엇인지에 대해서는 [메모리 구조](https://chw-owo.github.io/os/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0/) 포스트 참조 

초기화된 데이터의 경우 section.data에 다음과 같이 변수를 선언한다. 

```
section.data
    [변수 이름] [변수 크기] [초기값]
```
이때 변수 크기는 

db = 1 byte

dw = 1 word = 2 byte 

dd = 1 double word = 2 word = 4 byte

dq = 1 quad word = 4 word = 8 byte

로 나타낸다. 예를 들면 다음과 같다.

```
section.data
    a dw 0x1234
```

<br/>

초기화되지 않은 데이터의 경우 section.bss 아래에 다음과 같이 변수를 선언한다.
```
section.bss
    [변수 이름] [변수 크기] [개수]
```
이때 변수 크기는 

resb = 1 byte

resw = 1 word = 2 byte 

resd = 1 double word = 2 word = 4 byte

resq = 1 quad word = 4 word = 8 byte

로 나타낸다. 예를 들면 다음과 같다.

```
section.bss
    b resw 10
```
이 경우 2byte 크기를 가진 b 라는 이름의 변수 10개를 생성한 것이다. 

어셈블러에서 메모리 창을 켜서 확인해보면 어쩌구

## 2. 문자
## 3. 엔디안
## 4. 사칙 연산
## 5. 시프트 연산
## 6. 논리 연산
## 7. 분기문과 반복문
## 8. 배열
## 9. 함수



