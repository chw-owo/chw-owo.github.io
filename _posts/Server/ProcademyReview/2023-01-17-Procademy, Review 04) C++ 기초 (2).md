---
title: Procademy, Review 04) C++ 기초 (2)
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---
## **1. 연산자와 수식**

**1) 자료형 변환**

```c++
int main()
{
	int x = 394028;
	char a = x;
}
```
이렇게 초과하는 값을 넣을 경우 x의 하위 1byte(char의 size)만 char에 들어가게 된다. 

 ```c++
char a = x;
```

즉, 이러한 대입은 x의 첫 메모리 주소에 가서 값을 복사해넣으라는 의미인 것을 알 수 있다. 우리가 사용하는 컴퓨터가 리틀 엔디안을 사용하기 때문에 1byte만 들어가는 것이다. 만약 빅 엔디안을 사용하는 컴퓨터라면, 상위 값이 00이니까 a에 00이 들어가게 된다. 리틀 엔디안, 빅 엔디안의 개념은 [리틀 엔디안, 빅 엔디안에 관한 포스트][1] 참조. 

프로그래머로서 빅 엔디안으로 이루어진 컴퓨터를 사용할 일은 웬만해서는 없다. 하지만 네트워크 장비의 경우 빅 엔디안을 사용한다. 따라서 네트워크 프로그래밍을 할 때, 네트워크 장치가 사용할 데이터에 한해서 빅 엔디안으로 변환해주어야 한다. 클라이언트와 주고 받는 데이터 (ex 포지션, 레벨 등)은 어차피 패킹되어서 전달되기 때문에 변환할 필요 없지만, 주소와 관련된 값은 빅엔디안으로 변환하여 주고 받고, 사용할 때 다시 리틀 엔디안으로 변환해야 한다. 

```c++
int* p  = (int*)  x;
```

이러한 상황에서도 x의 포인터 값이 아니라 x의 값이 p에 그대로 들어가게 된다. 실수와 정수 간의 변환을 제외하면 C언어에서의 캐스팅은 실제로 데이터를 바꿔주는 것이 아니다. 실제로 어셈블리에서도 캐스팅이라는 개념은 없다. 실수가 아니라 의도한 변환이니 이대로 진행하라고 명령하는 것뿐이다. 


<br/>

**2) sizeof()**

```c++
int a = sizeof(int);
```
sizeof는 사실 함수가 아니라 연산자다. 따라서 일반적인 경우 컴파일 시에 값이 정해진다.어셈블리어를 열어보면 그냥 값으로 치환해서 꽂아주는 것을 볼 수 있다. 함수를 call 하는 게 아니기 때문에 성능을 저하시키지 않으니 편하게 사용해도 괜찮다. 

```c++
int s0 = sizeof(char);
int s1 = sizeof(char);
int s2 = sizeof(char);
```
```c++
int s0 = sizeof(char);
int s1 = s;
int s2 = s;
```
sizeof는 어차피 컴파일 시 상수로 치환되기 때문에 위, 아래에 성능 상 차이가 없다. 그러므로 위와 같이 동일한 sizeof를 여러번 써야 한다면 차라리 sizeof라고 명시해주는 것이 가독성 측면에서 낫다.

<br/>

**3) 연산자 우선 순위**

<br/>

## **2. 조건문**

**1) if**

<br/>

**2) switch-case**

<br/>

## **3. 반복문**

**1) while vs for**

<br/>

**2) do while**

<br/>

**3) goto**

<br/>

## **4. 그 외**

**1) rand**

<br/>

## **출처**

[1](https://chw-owo.github.io/os/Byte-Order,-%EB%B0%94%EC%9D%B4%ED%8A%B8-%EC%98%A4%EB%8D%94/)