---
title: Procademy, Q1, 29 - 2) Window API -  Object Handle
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. Object Handle**

윈도우는 모든 리소스를 오브젝트라는 이름으로, 핸들을 통해 관리한다. 오브젝트는 유저 오브젝트와 커널 오브젝트로 나뉘며 핸들값은 32bit에서는 32bit, 64bit에서는 64bit의 크기를 갖는다. 유저 오브젝트는 유저가 사용하는 메모리에 있어서 유저 모드에서도 우리가 손쉽게 접근할 수 있는 오브젝트, 커널 오브젝트는 커널에 있어서 여러 프로세스끼리 공유가 가능하지만 커널 모드로 전환해야만 접근 가능한 오브젝트를 의미한다. 

커널 모드 전환은 인터럽트를 일으키고 가상 메모리 테이블을 전환하는 등 프로세스 간 컨텍스트 스위칭에 준하는 오버헤드가 생긴다. 또, 인터럽트를 하면 미리 해둔 분기 예측도 다 날라가게 된다. 물론 커널 모드 전환을 아예 안할 수는 없으며 커널 오브젝트를 안써도 전환이 일어날 수 지만, 그래도 커널 오브젝트 사용을 최소화하는 것이 성능에 좋다. 동기화에는 유저모드 객체를, 서버 간 통신에는 네트워크를, 분산에는 스레드를 사용하는 등의 방식으로 줄일 수 있다. 

SECURITY_ATTRIBUTES는 프로세스 간 접근 관련 보안 속성을 지정하는 것으로, 오브젝트를 만들 때 이를 인자로 받는다면 모두 커널 오브젝트이다. 물론 저게 없다고 모두 유저 오브젝트인 것은 아니다. 특히 Heap, IOCP, Socket 등은 전부 커널 오브젝트지만 다소 독특한 성격을 띄는데 Heap, IOCP는 프로세스 간 공유가 불가능하며, Heap은 호출할 때마다 커널 모드 전환이 일어나는 것도 아니다. 따라서 헷갈리는 오브젝트는 MS에서 공식 표를 참조하는 것이 좋다.

<br/>

# **2. HeapCreate**

프로세스는 생성과 동시에 기본 Heap을 하나 세팅하고 그 핸들을 기억하기 때문에, 동적할당을 하면 자동으로 기본 Heap을 사용하게 된다. 이때 HeapCreate를 통해 동적 힙을 추가로 할당해서 사용할 수 있다. 이 경우 단편화 감소, 캐시 미스 감소 등의 효과를 얻을 순 있으나 이걸로 큰 성능 향상을 기대할 순 없다. 

그나마 현실적인 이점이라면, 멀티스레드에서 힙을 쓰면 매번 lock을 거는 동기화 작업이 들어가는데 스레드 별로 힙을 만들고 동기화를 끄면 성능상 이점을 얻을 수 있다. 하지만 이렇게 되면 해당 스레드에서 힙 삭제까지 해야되는데, 실제로 스레드 안에서 외부와의 상호작용 없이 할당하고 삭제까지 할 수 있는 상황은 흔하지 않다.

일반적인 사용은 아니지만 로그를 남길 때는 유용하게 쓸 수 있다. Release 빌드를 하면 디폴트 힙이 깨진 이후 Alloc을 하게 될 때 크래쉬가 난다. 그러면 CreateFile에서 크래쉬가 나면서 덤프도 남기지 못하게 되는데, 최악을 대비해 사용하는 힙은 디폴트 힙과 별도로 마련해두는 것이 좋다. 
