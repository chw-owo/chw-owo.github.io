---
title: 데이터 복사와 이동의 최적화
categories: Algorithm
tags: 
toc: true
toc_sticky: true
---

연결 리스트 대신 배열을 사용할 경우 배열 크기를 증가시켜야 할 때마다 데이터를 복사하여 이동시켜야 한다. 이를 짧은 시간 안에 효율적으로 하기 위한 여러 방법들이 있다. 

### 📌 메모리 블록을 0으로 설정하기

![슬라이드1](https://user-images.githubusercontent.com/96677719/152711614-c7eef32b-a8c1-4e39-af72-769021cf1d31.JPG)

잘 작동하지만 효율적이지 않은 알고리즘. 각 상자에 똑같은 시간이 걸린다고 가정하면 메모리 위치를 0으로 설정하는데 걸리는 시간보다 인덱스를 유지하고 길이를 갱신하기 위한 시간이 더 걸린다. 

### 📌 loop unrolling, 루프 언롤링

![슬라이드2](https://user-images.githubusercontent.com/96677719/152711616-a8598bd3-2639-428b-9774-b78f02d20c43.JPG)

메모리 블록을 0으로 설정할 때 이런 기법을 쓸 경우 코드를 더 효율적으로 만들 수 있다. 인덱스를 유지하고 길이를 갱신하기 위해 시간을 쓰는 대신 메모리를 0으로 만드는 것에 더 많은 시간을 쓸 수 있기 때문이다. 

### 📌 Duff's Device, 더프의 장치

![슬라이드3](https://user-images.githubusercontent.com/96677719/152711611-a49bcbb8-e6c2-4eae-a1af-92836e919449.JPG)

length가 0 이상일 때 제대로 작동하는 구현 방식. 루프를 여덟번 펼치고 남은 바이트 수에 따라 펼친 루프의 단계를 시작한다. 조건 분기를 여럿 써서 구현할 필요 없이 메모리 주소를 조작하는 방식으로 구현하기 때문에, 쓸 경우 메모리를 0으로 설정하는 시간과 다른 요소를 관리하는데 걸리는 시간이 비율이 더 계산 된다. 

단계 별로 설명해보자면

1) 마스크를 사용해 length의 하위 3비트만 남겨서 0x7과 AND 한다.

2) 8에서 1)의 결과를 뺀다.

3) 1) 을 반복한다.

4) 0으로 설정하는 명령어(current가 가리키는 메모리 <- 0>) 사이에 1)을 곱한다.

5) 0으로 설정하는 명령어 중 맨 앞 명령어의 주소를 4)에 더한다.

6) 5)에서 얻은 주소로 점프한다.

### 📌 일부 바이트를 0으로 설정하기

64비트 기계라면 한꺼번에 8바이트를 0으로 설정할 수 있다는 사실을 활용할 수도 있다. 이를 위해서는 블록 맨 앞 뒤에 메모리 경계에서 벗어난 남는 바이트들을 처리하기 위한 코드를 추가해야 한다. 위의 그림에서 eight에 대한 루프만 제거한 코드를 앞 뒤에 추가하는 것이다. 이런 방법을 통해 중간 부분에서 최대한 많은 8바이트 덩어리를 0으로 설정해야 한다.

### 📌 벡터를 사용한 I/O

벡터를 이용하여 I/O를 처리하는 것은 복사를 피할 수 있는 방법 중 하나이다. 

예를 들어 mp3 파일을 오디오 장치에 보낸다고 할 때, 다른 파일 형식과 마찬가리도 mp3 파일은 여러개 프레임으로 구성되며 각 프레임은 헤더와 데이터로 구성된다. 

이럴 때 데이터를 복사해서 전달하는 대신 시스템에게 프레임의 각 부분을 가리키는 포인터의 집합을 전달하고, 시스템이 오디오 장치에 데이터를 쓸 때 각 부분을 하나로 합쳐주는 방식으로 데이터를 이동시킬 수 있다. 데이터의 크기와 데이터에 대한 포인터 벡터를 만들어서 운영체제에 넘기면, 운영체제는 이 벡터에 저장된 데이터를 사용해 순서대로 프레임을 조합한다. 이때 벡터는 같은 데이터가 연속적으로 모여있는 고정된 크기의 데이터 구조를 의미한다. 이처럼 벡터를 활용해 데이터를 쓰는 행위는 수집, 읽는 행위는 분산이라고 부른다. 

### 출처
한 권으로 읽는 컴퓨터 구조와 프로그래밍, 조너선 스타인하트 지음, 오현석 옮김, 책만, 2021
