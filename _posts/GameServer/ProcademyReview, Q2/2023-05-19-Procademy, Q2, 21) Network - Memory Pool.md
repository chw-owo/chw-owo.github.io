---
title: Procademy, Q2, 21) Network - Memory Pool
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. Memory Pool과 FreeList**

Memory Pool과 FreeList 모두 메모리를 사용한 이후 바로 반환하는 대신 재사용할 수 있도록 따로 저장해서 성능을 높이는 것이다. 할당 예정인 메모리를 미리 확보해 두는 것을 Memory Pool, 런타임에서 필요할 때 할당 받는 것은 FreeList라고 한다. 사용할 리소스 총량이 예상 가능하다면 Memory Pool로 일괄 확보하는 것이 조금 더 효율적이다. 그러나 몬스터 수 같은 건 콘텐츠가 바뀔 때마다 변하므로 예상하기 어려우며, Pool 대신 FreeList를 쓴다고 해도 초기 할당 과정을 제외하면 그렇게까지 성능 차이가 크진 않다. 따라서 상황에 맞게 FreeList를 사용하는 것도 괜찮고, 절충하여 일부는 확보해놓고 이후에 추가할 수 있도록 하는 것도 좋다.

<br/>

# **2. Memory Pool과 Object Pool**

Memory Pool을 만드는 것에는 큰 메모리 덩어리를 한번에 할당 받아서 크기별로 나누어주는 방법과, template으로 type을 받는 type 별 Object Pool을 두는 방법이 있다. 객체 단위로 데이터를 할당 받아서 사용하는 프로그램이라면 굳이 메모리 덩어리로 할당 받을 필요가 없다. 이 경우 크기를 계산하고 버킷을 확인할 필요 없이 규격화된 하나의 크기로 풀을 만들다보니 해제 - 재할당 과정이 간단하다. 또, 메모리 누수가 생겨도 어떤 Object에서 문제가 생겼는지 타입 별로 모니터링 하기가 용이하다. 

반면 객체 타입 별로 Pool을 할당해야 하는 것이 다소 번잡스러우며, 타입에 종속적인 구조가 되기 때문에 할당 받은 메모리가 남아 돌고 있어도 다른 타입은 사용할 수 없게 된다. 또, 크기 별로 할당받을 경우 상황에 따라 Birtual Lock을 걸 수도 있다. 게다가 Object 타입 추적은 new delete 오버로딩으로도 해결할 수 있으며, 다른 라이브러리를 사용할 경우 잘못된 사용으로 작성하지 않은 지점에서 누수가 일어난다면 Obejct Pool로 추적할 수 없다. 따라서 메모리 단위의 Memory Pool을 선호하는 경우도 있다. 

<br/>

# **3. 크기 별 Memory Pool**

64KB 이상의 메모리를 Virtual Alloc으로 잡은 후, 포인터 계산으로 잘라서 쓰도록 구현한다. 이때 최초 할당과 해제는 쉽지만 재할당이 다소 복잡해진다. 따라서 일반적으로는 힙이 버킷을 관리하듯이 크기 범위 별로 메모리를 관리하며 재할당 한다. Pool 안에 또 규격 단위의 Pool이 존재하여 그 안에서 할당해서 주는 방식을 사용한다. 이때, 반환 된 값을 적절한 버킷에 넣어주기 위해 노드 앞 혹은 뒤에 몇 Byte 풀에 속하는지에 대한 정보를 포함한다.

Memory Pool로 사용할 때는 Pool 삭제 시 할당 받았던 메모리를 일괄 삭제 하는 게 가능하지만 FreeList로 사용한다면 최초에 할당 받은 메모리와 이후 낱개로 만든 메모리를 이중으로 관리해야 돼서 다소 복잡해진다. 또 Page Lock을 걸 수 있는 게 장점이지만 Page out 될만큼 사용하지 않는 메모리는 굳이 Lock을 걸지 않아도 성능에 큰 문제를 주지 않는다. 