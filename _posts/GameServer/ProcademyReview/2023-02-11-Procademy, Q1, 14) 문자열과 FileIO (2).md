---
title: Procademy, Q1, 14) 문자열과 FileIO
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 문자열**

## **1) 문자열 처리 함수**

strlen: 문자열 길이 계산

strcpy: 문자열 복사

strcmp: 문자열 비교

strchr: 특정 문자 검색 후 포인터 리턴

strstr: 특정 문자열 검색 후 포인터 리턴

strlwr: 문자열을 소문자로 변환


## **2) _s 문자열 처리 함수**

_s 버전은 버퍼 초과하는 것을 막기 위한 안전장치가 있는 문자열 처리 함수를 의미한다. 따라서 쓰기와 같이 버퍼가 들어가는 경우에 존재한다. 

```c++
char string[8];
strcpy(string, "Hello wolrd");
```
위와 같은 상황에서 원래대로면 메모리를 침범해버린다. 

```c++
char string[8];
strcpy_s(string, "Hello wolrd");
```
반면 위 상황에서는 예외를 던져서 아예 프로세스를 죽여버린다. 따라서 로그를 통해 문제가 났음을 확인할 수 있다. 

하지만 로그 안에서 예외가 터지는 경우 이 조차도 확인할 수 없게 된다는 한계가 있다. 

```c++
char string[80];
strcpy(string, "Hello wolrd");
```
```c++
char string[80];
strcpy_s(string, "Hello wolrd");
```
또, 위 상황처럼 버퍼가 남는 경우에는 별도의 처리를 하지 않으며 이 외에도 가변인자를 사용할 경우 _s를 사용해도 여전히 위험성이 남는다. 

## **2) strsafe 함수**

StringCchCat, StringCchCopy 등과 같이 윈도우에서 안전한 문자열 처리를 위해 제공하는 strsafe 종류를 사용하면 위와 같은 상황을 피할 수 있다. 이 함수들은 공간이 잘리거나 남으면 예외가 발생하는데, 그 예외를 코드 안에서 보여주기 때문에 확실하게 어떤 예외인지 확인할 수 있다. 로그를 남기는 코드와 같이 예외를 반드시 확인해야 하는 경우에 유용하다. 이때, 살펴보면 StringCb~ 와 StringCch~ 가 있는데 Cb의 경우 버퍼 바이트를 Cch는 char(캐릭터)의 개수를 넣게 된다. Cch는 유니코드 전용으로 나온 것이라고 생각하면 된다. 

# **2. File IO**

## **1) fopen mode**

fopen을 할 때 r/w을 통해 read/write 모드를 지정할 수 있고 b를 통해 text mode와 binary mode를 결정할 수 있다. 반면 윈도우에서 제공하는 CreateFile 같은 함수를 보면 text mode/binary mode가 없는 걸 알 수 있다. 즉, 이건 운영체제가 아니라 C 언어 차원에서 사용의 편의성을 위해 제공하는 기능인 것이다. 

윈도우와 linux는 줄바꿈하는 기호가 조금 다르다. (Windows: 0d0a / Linux: 0a) 그래서 옛날 윈도우에서는 줄바꿈 대신 음표가 들어가는 것을 왕왕 볼 수 있다. 하지만 C 언어 입장에서는 여전히 linux, unix 양식(0a)을 따르고 있다. 만약 텍스트 모드를 사용할 경우 이를 알아서 변환해주겠다는 의미가 된다. 그래서 텍스트 모드를 쓰면 읽고 쓸 때 용량에 약간의 변화가 생기게 된다. 단, 텍스트 모드일 때는 1a를 파일의 끝으로 처리하기 때문에 이미지 파일이 깨지거나 텍스트가 중간에 잘릴 수 있으므로 이를 주의해야 한다. 일반적으로 텍스트를 처리할 때는 text 모드를, 그 외 파일을 쓸 때는 binary 모드를 쓰는 것을 권장한다.

## **2) File IO와 성능**

속도를 높이려면 입출력 횟수를 줄이고, 데이터 가공을 메모리에서 처리해야 한다. 파일을 직접 건드리는 건 좋지 않다. 읽을 땐 read로 다 읽고, 메모리에서 내용을 수정한 뒤 쓸 땐 write로 한번에 다 쓰는 것이 상대적으로 성능이 좋다. 따라서 w+, a+ 등은 잘 사용되지 않는다. 또, fscanf(), fgetc() 등은 파일 format 양식에 영향을 많이 받기 때문에 잘 사용하지 않는다. 반면 fprintf, fread, fwrite는 많이 사용하게 된다. 

fwrite, fread에서 size, count를 어떤 크기로 지정하는지는 속도에 영향을 주지 않는다. 어차피 읽는 길이는 동일하기 때문이다. 반환값이 바뀌긴 하지만 실제로 반환값을 잘 활용하지는 않는다.

## **3) fflush**

fflush는 버퍼를 지운다는 의미가 아니라 버퍼를 밀어준다는 것을 의미한다. 즉, 저장할 게 있으면 지금 저장하고 버퍼는 빈 상태로 만들라는 뜻이다. 

만약 파일을 읽어오게 되면 일종의 버퍼링처럼 실제로 1글자 짜리를 읽더라도 4KB malloc을 요청해서 한번에 4KB를 읽어들인다. 그리고 이후에는 해당 malloc된 메모리에서 읽는다. 이 이후로는 파일이 아니라 메모리에서 값을 읽어오게 된다. 쓰는 것 역시 메모리에 있는 값을 수정하다가 fclose가 될 때, 페이지가 넘어갈 때, 그리고 flush가 일어날 때 실제 파일에 값을 쓰게 된다. 따라서 로그를 만들 때도 쓸 때마다 open -write - close 를 반복하거나 flush를 매번 해야한다. 그래야만 파일에 저장되었음을 보장할 수 있다. 그러나 버퍼는 두단계 있다. 하나는 언어 차원, 하나는 OS 차원. 언어 차원에서 fflush를 했어도 만약 OS 차원의 버퍼에 저장해두고 아직 쓰기 전이라면 이런 과정을 거쳐도 파일에 저장되지 않았을 수 있음에 유의해야 한다. 

fflush의 뜻을 오해하여 잘못 사용되는 대표적인 예시가 fflush(stdin)이다. stdin, stdout은 pfile가 아니지만 C언어 차원에서 랩핑해서 그렇게 처리해주고 있기 때문에 생긴 일이다. ms에서는 키보드 버퍼를 지우고 싶다면 rewind()를 사용하기를 권장하고 있다.
