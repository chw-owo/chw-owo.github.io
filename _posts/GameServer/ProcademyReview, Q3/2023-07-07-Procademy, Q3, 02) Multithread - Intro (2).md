---
title: Procademy, Q3, 02) Multithread - 개요 (2)
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 커널 스레드와 유저 스레드**

선점형 스케줄링에서 '선점'은 OS 입장의 선점, 즉 OS 마음대로 하겠다는 것을 의미한다. 간혹 유저 스레드와 커널 스레드가 언급되는데, 우리가 c++에서 스레드라고 인지하는 것은 모두 커널 스레드이다. 이는 OS 커널에 생성되어서 커널이 알아서 관리하는 스레드로, OS가 선점형으로 관리한다. 비선점형 스케줄링은 OS가 관여하지 않겠다는 것이므로 OS 입장에서 비선점형 스케줄링은 있을 수가 없다. 

유저 스레드는 유저가 생성, 관리하는 실행 단위로 유니티의 코루틴이 한 예시이다. 병렬 처리 느낌을 주기 위한 실행 단위로, 코루틴 A, B, C가 있을 때 개념적으로 두개가 도는 것처럼 보인다. 당연히 실제 병렬은 아니지만 함수와 다르게 호출 경로와 콜 스택을 기억하기에 중간에 나오고 돌아갈 수 있다. 이때 코드 수행 위치가 변경되면서 레지스터 셋도 변경되므로 컨텍스트 스위칭과 같은 부하가 걸린다. 

유저 단계에서 커널 스레드를 흉내냈지만 OS에서는 이를 알 수 없다. 따라서 코어가 여러개여도 코루틴은 단일 코어에서 실행된다. 즉, (OS 기준) 비선점형 스케줄링이 되기 때문에 유저가 yield를 통해 직접 호출해야 한다. 유니티는 싱글 스레드 엔진이기 때문에 이런 방식으로 병렬 처리를 할 수 밖에 없다. 작업 시점을 개발자가 제어할 수 있도록 하기 위해 이런 구조를 사용한 것으로 보인다.

윈도우의 유저 스레드로는 fiber가 있으며, 모던 c++20부터 경량 스레드라는 이름의 유저 스레드가 제공된다. 경량 스레드는 코루틴처럼 yield로 개발자가 직접 제어해야 된다. 실제로는 선점형 스케줄링 안에서 돌지만 유저에게 보이지 않으니 비선점형 스케줄링이라 부를 수 있다. 더 적은 오버헤드로 코드 관리를 쉽게 할 수 있지만 당연히 멀티 코어를 활용할 수는 없다.

동시성은 동시에 도는 것처럼 보이는 것, 병렬성은 실제로 병렬로 도는 것으로 병렬성 안에 동시성이 포함된다. 즉, 유저 스레드는 동시성, 커널 스레드는 동시성과 병렬성의 영역이다. 성능이 낮아져도 구조를 더 간결하게 하기 위해 혹은 1차원적 응답성을 높이기 위해 동시성을 활용할 수 있다. 메시지 peek을 스레드로 분리하거나 주기적인 시간 체크 코드를 분리하는 것 등이 포함된다. 

예외 핸들링으로 싱글 스레드라면 프로세스가 죽을 예외에 대해 그 스레드만 죽이고 다시 스레드를 생성해서 없던 일처럼 진행할 수도 있다. 그러나 이런 처리는 나중에 더 큰 문제가 생길 수 있다. 대규모 DB 혹은 금융권에서는 Active 서버 (Master) - Stand By 서버 (Slave)를 두고 Active 서버에 문제가 생기면 Stand By 서버로 연결하여 고가용률을 보장하기도 한다. 그러나 이는 하드웨어 고장을 대비한 것이지 소프트웨어 버그를 대비할 수 있는 방법은 아니므로 게임에 활용하기는 어렵다. 

<br/>

# **2. 윈도우의 멀티 스레드**

윈도우는 스레드 스케줄링. 프로세스는 스레드를 모은 껍데기일 뿐, 스레드 단위로 작동하며 프로세스는 작동된다는 개념이 아니다. 과거  리눅스는 프로세스 단위로 돌았기에 프로세스 스케줄링을 했으며, 이때 자식 프로세스를 생성해서 멀티태스크를 처리했다. 윈도우 OS는 스레드 단위로 돌리기 때문에 프로세스를 구분하지 않으며 프로세스 A가 1개의 스레드를, 프로세스 B가 2개의 스레드를 가지고 있고 순서대로 돌아 간다면 프로세스 B가 두번 돌아갈 것이다. vs의 콜스택은 스택 메모리를 역추적 해서 띄운 것으로, 콜 스택이 따로 있다기보단 스레드마다 콜할 수 있는 스택이 만들어진다고 받아 들이면 된다. 

프로그램 수행 시간은 IO 바운드와 CPU 바운드로 나뉘는데, IO 바운드는 IO를 기다리느라 Block된 시간을, CPU는 CPU를 쓰면서 걸린 시간을 의미한다. IO 바운드는 최대한 없애고, CPU 바운드도 로직 개선 및 병렬 처리로 최소화 해야된다. 4GHz clock CPU의 사용률이 50%라는 건 1초가 측정주기라면 그 중 0.5초는 썼고 0.5초는 안썼다는 것을 의미한다. CPU는 일부만 쓸 순 없고 쓴다와 안쓴다만 있으며, 안 쓴 시간은 IO 바운드 혹은 Sleep에 쓰인 시간이 된다. 실제로 스레드가 돌지 않을 땐 커널에 있는 IDLE 스레드가 돌기 때문에 스레드가 돌지 않는 시간은 없지만, 유저가 요청한 스레드가 돌지 않았으므로 저렇게 표시한다. 

스레드는 CPU 시간을 할당 받는 수행의 단위로, 할당 받은 CPU 시간은 퀀텀 혹은 타임 슬라이스라 한다. OS는 선점형 스케줄링 우선순위 기반의 라운드 로빈 형태로 스레드들을 스케줄링 한다. c 연산자로만 이루어진 코드를 뺑뺑이 돌리지 않는 이상 주어진 퀀텀을 다 쓰기는 어렵다. printf, select, sleep 등의 IO 작업이 걸리면 스레드가 자진해서 사용권을 놓기 때문이다. 따라서 멀티 스레드에서 할 일이 없다면 sleep이든 signal이든 스레드를 블락 걸고 다른 스레드에게 양보하는 것이 좋다. OS 입장에서 CPU는 스레드를 돌릴 수 있는 단위, 즉 논리 프로세서를 말하는 거지 물리적 코어 개수를 말하는 것이 아니다. 쿼드코어라도 하이퍼 스레딩 기능이 있다면 8개의 CPU 창이 뜬다. 

스레드 생성 가능 개수는 정해져있지 않으며 메모리 한계치까지 가능할 것으로 추측된다. 스레드는 러닝, 레디, 블락의 상태를 가지며 생성 시엔 non-signal이다가 종료되면 signal이 된다. 동기화 함수(WaitFor-Object)를 사용하면 특정 객체가 signal 될 때까지 스레드를 block 할 수 있다. MS는 먼저 기다린 스레드가 먼저 깨어날 것임을 보장하지 않는다. 2023 기준 현재까지는 보장 되는 것으로 보이나 커널 업데이트 되면 바뀔 수 있으니 의존하지 않는 게 좋다. 정지된 스레드는 단순한 큐, 리스트 등의 형태로 저장될 것으로 추측되며, 스레드 10000개가 블락 되어있어도 블락된 상태라면 전혀 CPU에 부하를 주지 않는다.

돌던 스레드가 퀀텀을 다 쓰거나 사용권을 내놓으면 레디 큐에 있던 스레드를 넣는다. 이때 레디 큐의 스레드를 돌리는 것만 CPU의 역할이며 스레드의 소속 프로세스는 확인하지 않는다. 컨텍스트 스위칭이 되면 작동되던 상태를 스냅샷 찍듯이 찍어서 PCB(Process Context Block)에 저장하고 이걸 CPU가 그대로 불러와서 사용한다. CPU가 CR3에 있는 Page directory의 물리 주소만 보기 때문에 가상 메모리 테이블 역시 테이블 채로 교체하는 대신 CR3 레지스터만 교체하면 된다. 프로세스가 동일하면 메모리에 대한 시야가 같으니 교체가 안되어도 되는데, 이에 대한 세부 사항은 OS 마다 다르며 공개되어 있지 않다. 

이렇게 교체가 되면 TLB를 비롯한 Cache Memory에서 다 miss가 난다. 커널 TLB를 비우지 않는다고 명시되어 있으며, 유저 TLB는 비우는 걸로 추측된다. Cache까지 flush를 하는지 아닌지는 공개되지 않았는데 비워도 안비워도 miss 나는 건 동일하기에 안할 거라고 추측된다. 문맥 교환 자체는 CPU의 상태를 교체하는 것이기 때문에 그렇게 오래 걸리지 않을 걸로 추측 되며, 가상 메모리 시야가 바뀌는 부분에서 오버헤드가 크게 걸린다고 보는 게 합리적이다. 

<br/>

# **3. 인터럽트**

mov, cmp 등을 최소 단위 오퍼레이션이라 부르는데, 이는 수행이 보장되는 최소 단위를 의미한다. 인터럽트는 늘 최소 단위 오퍼레이션 사이에서 발생하며, mov 하는 도중에는 인터럽트가 일어나지는 않는다. 참고로 rep 와 같은 반복자는 최소 단위 오퍼레이션이 아니다. 간혹, 최소 단위 오퍼레이션이어도 데이터가 캐시 라인 중간에 걸리면 메모리에 두번 접근해야 한다. 예를 들어 mov [a] eax 인데 [a]가 걸쳐져 있다면 두번 가져오는 것이다. 그럼에도 mov는 최소 단위 오퍼레이션이기 때문에 중간에 인터럽트가 일어나지는 않는다. 물론 다른 코어가 그 타이밍에 저 값을 가져오면 다른 값이 들어올 순 있으나 OS가 패딩을 하기 때문에 의도적으로 경계에 세우지 않는 한 그럴 일은 없다. 

인터럽트는 소프트웨어가 돌아가는 상태에서 이더넷, 마우스 신호 등 외부 하드웨어 반응을 처리하기 위해 나온 개념이다. CPU는 인터럽트 번호 당 수행되어야 하는 핸들러 코드의 테이블, 인터럽트 서비스 루틴을 커널 코드에 지니고 있다. 인터럽트가 발생하면 CPU는 그 테이블을 참고 하여 최소 단위 오퍼레이션이 끝나는 즉시 해당 핸들러 코드를 실행하고 이것이 끝나면 다시 돌아온다. 이때 프로그래밍 가능한 인터럽트 컨트롤러를 PIC라고 한다. 여기서 0번이 타임 인터럽트에 해당하며, 기본적으로 하드웨어 인터럽트가 소프트웨어보다 높은 우선순위를 가진다. 인터럽트 처리 중에 더 높은 우선 순위의 인터럽트가 발생하면 이것도 최소 단위 오퍼레이션이 끝나는 즉시 해당 핸들러 코드로 튄다. 

인터럽트 우선 순위 가장 아래에는 APC와 DPC, 디스패쳐, 스레드가 위치한다. MS는 하드웨어 인터럽트 발생 시 할 일을 다 하는 대신 최소한만 처리한 뒤 DPC에 넘김으로써 하드웨어 인터럽트 우선 전부 처리하고 이후에 DPC 인터럽트로 지연 처리 하기를 권장한다. 디스패쳐는 별도 하드웨어가 아닌, 커널이 메모리 할당을 해서 들고 있는 것으로 컨텍스트 스위칭을 담당한다. 일단 발생된 인터럽트를 모두 처리한 후에 진행하기 위해 아래쪽에 위치한다. 디스패쳐는 서비스 루틴(핸들러 코드) 안에서 컨텍스트 스위칭이 발생한다. 디스패쳐 핸들러 함수 안에서 현 스레드 정보를 TCB로 빼고 레디큐 정보를 CPU에 넣는데, 그 그 순간 스레드가 바뀌는 거니까 그 안에서 스레드가 바뀌는 셈이다.

대부분 인터럽트는 특정 코어 하나가 받아서 처리해야 하는데, 이때 부하 분산을 APIC (Advanced PIC)가 담당한다. 대부분의 인터럽트는 CPU 선호도가 있으며 이것이 제일 우선시 되지만 간혹 APIC에 의해 선호도와 다르게 분배될 수도 있다. 그러나 성실히 분산하지는 않기에 CPU 100이 아닌 이상 거의 선호도 대로 된다. Blocked 스레드는 큐에 들어가기 전에 어느 코어의 레디큐에 들어갈지 판단하는데 이는 디스패쳐가 처리한다. 윈도우 8까지는 인터럽트의 CPU 선호도를 임의로 수정할 수 있었는데 윈도우 10부터는 잘 되지 않는다.

0번 인터럽트가 발생할 때마다 모든 코어가 각자의 스케줄러를 돌린다. 과거에는 0번 인터럽트가 외부에 있었는데 지금은 CPU 내부에 있다. 엄밀히 따지면 자기가 자기의 인터럽트를 발생 시키고 그걸 바탕으로 자기 스케줄러를 돌리는 것으로, 타이머 하드웨어에 의해 작동된다는 말은 여전히 맞지만 그 하드웨어가 내부에 들어온 셈이다. 

인터럽트 처리 시에도 커널 스택이 사용된다. 스레드는 기본 4K, 최대 16K의 작은 커널 스택을 하나씩 갖는다. 인터럽트 발생 등의 이유로 스레드가 커널 모드로 전환 되면 스택도 함께 커널 스택으로 전환 되고, 이때 저장해야 될 데이터가 있다면 모두 커널 스택에 저장된다. 서비스 루틴을 실행하기 전, eip, rip는 하드웨어적으로 백업이 되고 나머지 레지스터 정보는 커널 스택에 저장된다.

<br/>

# **4. 스레드 스케줄링**

컨텍스트 스위칭을 하면 TCB에 데이터를 그대로 백업하고, 레디큐에 있는 스레드의 TCB를 그대로 씌운다. 따라서 다른 기기(CPU)가 CPU를 컨텍스트 스위칭 시킨다는 건 불가능하며 컨텍스트 스위칭 시점은 유저, 커널에 상관 없이 자기 자신만이 결정할 수 있다. 자신의 레지스터와 스택 데이터를 직접 저장해야 되기 때문이다. 코어마다 우선순위별로 여러개의 레디큐들이 있으며, 각 큐에 Ready 상태의 스레드들이 들어간다. 이때 현재 돌아가는 스레드보다 높은 우선순위의 레디큐에 스레드가 들어오면 퀀텀에 상관 없이 컨텍스트 스위칭을 시킨다. 디스패쳐가 TCB를 빼고, 어디에 넣을지 판단하고, 넣기로 결정한 코어의 디스패쳐를 작동시킨다.

스케줄러는 0번 인터럽트 간격으로 현 스레드 퀀텀을 확인해서 지났으면 디스패쳐를 작동시키며, 실질적인 컨텍스트 스위칭은 소프트웨어 인터럽트인 디스패쳐 인터럽트를 통해 디스패쳐가 수행한다. 디스패쳐가 CPU에 러닝 중인 스레드를 TCB로 빼고 이를 어느 레디큐에 넣을 지 결정한다. 이때 우선 선호도를, 두번째로 되도록 직전에 돌았던 프로세서를 고려한다. 같은 프로세서에서 돌아가면 사실 그걸 컨텍스트 스위칭으로 보지 않는다. 레디큐, TCB 등은 다 Nonpaged-pool에 존재하며, 레디큐에 스레드를 넣는 것은 다른 코어의 디스패쳐가 내 레디큐에 진행하므로 내부적으로 동기화가 진행된다.

밸런스 셋 매니저는 커널에 있는 스레드로, 이 스레드가 1초 주기마다 레디큐를 스캔하면서 4초 이상 돌지 못한 스레드를 발견하면 우선순위를 높여준다. 이를 우선순위 부스팅이라 하며 이런 작업으로 기아 현상을 방지한다. IO에 대한 결과를 받을 때도 우선순위 부스팅이 일어나는데 이건 추후에 다시 다룬다. 참고로 레디큐에 한번 배정이 되면 다른 CPU가 비어있어도 갈 수 없다. 이를 더 효율적으로 바꾸기 위해 MS에서 레디큐 그룹화를 할 예정이라고 한다. 요즘 나온 CPU는 저전력 코어 혹은 고성능 코어에 배정하는 기능이 있다는데 아직 MS에서 그걸 컨트롤 할 수 있는 API를 제공하지는 않는다.

<br/>

# **5. 동기화**

커널 단위의 동기화는 동기화 객체를 통해 이루어지며, 동기화를 걸고 해제 하는 시점을 사용자가 결정한다. 크리티컬 섹션으로 예를 들면, enter 시 들어가고 leave 시 나오는데 이때 enter, leave를 선언하지 않고 해당 데이터에 접근한다면 당연히 동기화가 되지 않는다. 또, 한 스레드는 Enter Player-Enter Item-Leave Item-Leave Player, 다른 스레드는 Enter Item-Enter Player- Leave Player-Leave Item 순서로 실행할 경우 데드락이 발생한다. 따라서 동기화 사이에 연관 관계가 있는 경우 교차로 동기화되지 않도록 순서를 일치시켜야 한다.

최근 vs 디버깅은 스레드 목록과 어떤 스레드에서 락이 걸렸는지 보여주기에 비교적 데드락을 쉽게 찾을 수 있다. .Leave 이전에 실수로 return 해서 걸린 경우 크리티컬 섹션 멤버의 Enter 했던 스레드 ID를 참고하면 된다. 이를 막기 위해 클래스를 만들어서 생성자에 Enter, 소멸자에 Leave 할 수도 있으며 이는 현업에서도 많이 사용되는 방법이다. 그렇게 할 경우 객체를 지역 변수로 선언하기만 하면 return 시에 자동으로 Leave 된다. 요즘은 생성자 소멸자도 inline이 되기에 괜찮은 방법이다.

<br/>

# **6. 링버퍼와 멀티스레드**

```
스레드 1 -> RingBuffer -> 스레드 2
```

스레드 1은 Enqueue만 하고 스레드 2는 Dequeue만 한다. 이때도 동기화가 필요할까?

링버퍼는 Front, Rear가 단방향으로만 움직이기 때문에 데이터가 있는데 없다고 보는 상황은 생길 수 있지만, 데이터가 오염되는 상황은 생기지 않을 것이다. 여러 스레드가 동시에 접근할 때 문제가 되는 것은 데이터가 망가지거나, 유실되거나, 쓰레기 값이 생기는 상황이다. 따라서 하나의 공유 자원에 대해 양쪽이 동시에 쓰기를 할 때 동기화가 필요한 것이지, 위처럼 읽기만 하거나 읽고 쓰는 경우는 상관이 없다. 

참고로 EnterCriticalSection을 먼저 호출했다고 소유권을 먼저 획득하는 것은 아니다. 그 안에서도 소유권 획득 단계로 가기까지 많은 과정이 있다. 따라서 멀티스레드 환경에서는 함수나 EnterCriticalSection의 호출 순서에 따라 실행 순서를 보장 받을 수 없으며, 그 실행 순서에 의존하는 코드는 애초에 만들어서는 안된다.

만약 동시에 쓰기를 한다면 동기화가 필요한데, 이때 함수 별 공유 자원을 명확히 파악하고 이를 바탕으로 동기화를 해야 한다. Enqueue는 Rear 변수와 Rear~Front에 해당하는 메모리 영역을 건드리고, Dequeue는 Front 변수만 사용한다. 그러므로 링버퍼 전체에 lock을 거는 것보다는 Enqueue는 Enqueue끼리, Dequeue는 Dequeue끼리 동기화 객체를 만들어서 잠그는 게 더 효율적일 것이다. 

또 다른 방법은 하나의 Queue에서 Enqueue와 Dequeue가 완전히 분리된 객체를 만드는 것이다. Enqueue만을 위한 버퍼와 Dequeue만을 위한 버퍼를 만들어서, Dequeue가 끝나고 버퍼가 비는 순간 포인터만 바꾸어서 flip 하면 더블 버퍼링과 동일한 효과를 볼 수 있다. rear, front가 양방향으로 움직이는 버퍼라면 이런 구조가 매번 Lock을 거는 것보다 효율적일 것이다. 

