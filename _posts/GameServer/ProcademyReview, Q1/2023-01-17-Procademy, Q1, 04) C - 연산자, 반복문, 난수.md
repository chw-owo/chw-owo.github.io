---
title: Procademy, Q1, 04) C - 연산자, 반복문, 난수
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 연산자와 수식**

## **1) 자료형 변환**

```c++
int main()
{
	int x = 394028;
	char a = x;
}
```
이렇게 초과하는 값을 넣을 경우 x의 하위 1byte(char의 size)만 char에 들어가게 된다. 

 ```c++
char a = x;
```

즉, 이러한 대입은 x의 첫 메모리 주소에 가서 값을 복사해넣으라는 의미인 것을 알 수 있다. 우리가 사용하는 컴퓨터가 리틀 엔디안을 사용하기 때문에 1byte만 들어가는 것이다. 만약 빅 엔디안을 사용하는 컴퓨터라면, 상위 값이 00이니까 a에 00이 들어가게 된다. 리틀 엔디안, 빅 엔디안의 개념은 [리틀 엔디안, 빅 엔디안에 관한 포스트][1] 참조. 

프로그래머로서 빅 엔디안으로 이루어진 컴퓨터를 사용할 일은 웬만해서는 없다. 하지만 네트워크 장비의 경우 빅 엔디안을 사용한다. 따라서 네트워크 프로그래밍을 할 때, 네트워크 장치가 사용할 데이터에 한해서 빅 엔디안으로 변환해주어야 한다. 클라이언트와 주고 받는 데이터 (ex 포지션, 레벨 등)은 어차피 패킹되어서 전달되기 때문에 변환할 필요 없지만, 주소와 관련된 값은 빅엔디안으로 변환하여 주고 받고, 사용할 때 다시 리틀 엔디안으로 변환해야 한다. 

```c++
int* p  = (int*)  x;
```

이러한 상황에서도 x의 포인터 값이 아니라 x의 값이 p에 그대로 들어가게 된다. 실수와 정수 간의 변환을 제외하면 C언어에서의 캐스팅은 실제로 데이터를 바꿔주는 것이 아니다. 실제로 어셈블리에서도 캐스팅이라는 개념은 없다. 실수가 아니라 의도한 변환이니 이대로 진행하라고 명령하는 것뿐이다. 

## **2) sizeof()**

```c++
int a = sizeof(int);
```
sizeof는 사실 함수가 아니라 연산자다. 따라서 일반적인 경우 컴파일 시에 값이 정해진다.어셈블리어를 열어보면 그냥 값으로 치환해서 꽂아주는 것을 볼 수 있다. 함수를 call 하는 게 아니기 때문에 성능을 저하시키지 않으니 편하게 사용해도 괜찮다. 

```c++
int s0 = sizeof(char);
int s1 = sizeof(char);
int s2 = sizeof(char);
```
```c++
int s0 = sizeof(char);
int s1 = s;
int s2 = s;
```
sizeof는 어차피 컴파일 시 상수로 치환되기 때문에 위, 아래에 성능 상 차이가 없다. 그러므로 위와 같이 동일한 sizeof를 여러번 써야 한다면 차라리 sizeof라고 명시해주는 것이 가독성 측면에서 낫다.

## **3) 연산자 우선 순위**

![image](https://user-images.githubusercontent.com/96677719/212912030-6d1d42a6-e544-4996-85e5-0921bfe12241.png)

혼동되기 쉬운 것만 다시 짚고 넘어가자. 

|연산자|의미|
|------|----|
|+, -|덧셈 뺄셈 연산|
|shift|쉬프트 연산|
|==, != |비교 연산|
|&, ^|비트 and or 연산|

위에서부터 순서대로 우선순위가 높다. 즉, 덧셈 뺄셈이 Shift 연산보다 앞서고, == != 와 같은 비교 연산자가 bit and or 연산보다 앞선다. 

<br/>

# **2. 조건문**

## **1) if**

조건이 여러개 중첩된 상황을 가정해보자. 

```c++
int a = 10;
int b = 10;
int c = 10;

if(a == 10 && b == 20 && c == 31)
{
	…
}
```
이럴 때, 조건문 속 비교 연산도 다 연산이기 때문에 최대한 효율적으로 배치하는 것이 좋다. 예를 들어 and 연산의 경우 거짓일 가능성이 높은 것을 앞쪽에 배치하는 것이 성능상 유리하고, or 연산의 경우 참을 가능성이 높은 것을 앞쪽에 배치하는 것이 성능상 유리하다.

## **2) switch-case**

네트워크 통신을 하기 시작하면 컨텐츠 메시지 하나하나에 번호를 매기게 된다. 그런데 MMORPG 게임이라면 시간이 지났을 때 메시지의 종류가 몇백개를 훌쩍 넘어가기도 한다. 그런 상황이 되면 거대한 switch문이 많이 쓰인다. (회사에 따라 key-value 형태의 자료구조로 만들거나 배열로 저장하는 경우도 있다.) 만약 아래 같은 상황이 있다고 가정해보자. 

```c++
void Test()
{
    int msg = 10;
    int x = 0xffffffff;

    switch (msg)
    {
    case 30:
        x = 1;
        break;

    case 150:
        x = 1;
        break;

    case 10:
        x = 1;
        break;

    case 720:
        x = 1;
        break;

    case 80:
        x = 1;
        break;
    	…
    //대충 이렇게 case가 300개.
    }
}

```

이 코드의 어셈블리를 열어보면 cmp je cmp je cmp je cmp je cmp je cmp je cmp je cmp je cmp je… 이런 식으로 이루어져있다. if 문 300개와 동일하게 동작하는 것이다. 만약 어셈블리어가 이렇게 되어 있다면 이 switch 코드는 지나치게 비효율적인 코드이므로 사용을 지양해야한다. 그런데 만약 아래와 같이 switch문이 정돈 되어 있다면 경우가 달라진다.  

```c++
void Test()
{
    int msg = 10;
    int x = 0xffffffff;
    switch (msg)
    {
    case 10:
        x = 1;
        break;

    case 11:
        x = 1;
        break;

    case 12:
        x = 1;
        break;

    case 14:
        x = 1;
        break;
    	…
    case 16:
        x = 1;
        break;
    }
}
```

이 경우 놀랍게도 cmp을 한번만 하는 것을 확인할 수 있다. 어셈블리어를 보면 아래와 같은 구조로 되어있다. 

```
mov ecx, dword ptr [ebp-8]
sub ecx, 0Ah 
```
우선 해당 switch문이 10부터 시작하기 때문에 10을 빼서 시작값을 0으로 만들어준다 .

```
cmp dword ptr [ebp-8], 6
```
마지막이 16이기 때문에, 만약 input 값이 이를 초과한다면 switch문 밖으로 나가라는 명령이다.

그 이후를 보면 
```
jmp dword ptr [edx*4+0C21090h]
```
그 후 이와 같이 알 수 없는 주소로 점프하는 것을 볼 수 있다. 하나하나 비교하는 대신 case에 대한 테이블을 만들어서 그곳으로 던지는 것이다. edx*4+0C21090h 이 주소로 들어가서 설정을 4byte (32bit 기준. 64bit라면 8byte)로 바꾸면, 케이스 하나하나에 해당하는 메모리 위치가 테이블에 들어가 있는 것을 확인할 수 있다. 컴파일러가 자동으로 case 10 11 12 13… 였던 것을 0 1 2 3 …으로 바꾸고, 해당 0 1 2 3… 을 index 삼아서 각각의 경우가 가리키는 테이블을 만든 것이다. 이렇게 되면 switch case문이 몇백개가 되어도 어차피 index를 통해 jmp하기 때문에, 성능상 문제가 생기지 않는다. 일종의 Hash 탐색으로 이해하면 된다. case 뒤에 반드시 상수만 와야 하고 변수가 올 수 없는 이유도 case문이 테이블 형식으로 동작하는 것을 지향하기 때문인 것으로 추측된다. 

case가 반드시 연속된 숫자가 아니어도 괜찮다. 숫자의 순서가 뒤섞이거나, 약간의 간격이 있는 것은 컴파일러가 알아서 해결해준다. 간격이 멀 경우 점프 테이블을 자체적으로 여러개 만든다. 간격이 가까울 경우 비어있는 값도 포함하는 테이블을 만든 뒤, 해당 값으로 가면 switch문을 빠져나오도록 명령하는 방법을 주로 사용한다. 실제로 연속되지 않은 case를 가질 때 테이블이 어떻게 구성되는지 확인해보면 아래와 같다. 

![image](https://user-images.githubusercontent.com/96677719/212916043-3be9de75-e988-4c17-9902-0d8ab06784fc.png)

(사진 출처: https://crmerry.tistory.com/26)

만약 위처럼 값 몇개가 연속되지 않고 빠진다고 가정해보자. 이 상황에서 점프 테이블을 보면 비어있는 값의 index도 존재하며, 그 위치로 가면 0a 채워져있는 것을 볼 수 있다. 이때 0a이 있는 위치로 가게 되면 바깥으로 jmp시켜준다. 연속된 배열을 만들기 위해 이가 빠진 부분도 채워서 테이블로 만들어는 것이다. 실제로 메모리에서 주소를 타고 들어가보면 연속된 값을 모두 채워준 변환용 테이블과 실제로 존재하는 값들만 가리키고 있는 작은 테이블, 2개의 테이블이 존재하는 것을 확인할 수 있다. 

그러나 컴파일러가 어느정도 불규칙성까지 해석해주는 지는 보장할 수 없다. 따라서 switch case문을 수정하고 나면 이러한 점프 테이블이 여전히 존재하는지 확인해야 한다. 만약 점프 테이블이 깨졌다면 테이블을 유지할 수 있도록 case 값을 수정하는 것이 좋다. 그럼에도 테이블이 생기지 않는다면 적합한 자료구조를 사용하는 것이 권장된다. 혹은 if로 큰 구역을 분기 탄 다음, 분기별로 case문을 따로 만들면 테이블이 형성될 가능성이 더 높아진다. 

<br/>

# **3. 반복문**

## **1) while vs for**

```c++
while(1) 
{ 
    .. 
}

```
```c++
for(;;)
{ 
    .. 
}
```
이 둘은 무한 반복이라는 동일한 기능을 수행하지만, 성능에 있어서는 while(1)이 조금 더 불리하다. 1인지 체크하는 과정이 (어셈블리어로) 한 줄 포함되기 때문이다. 참고로 최적화 컴파일을 하면 이 부분을 알아서 생략해주기 때문에 성능이 동일해진다. 하지만 무한 루프 도는 코드는 보통 1초에 많아봤자 100-120번 도는 경우가 많기 때문에 이것이 큰 영향을 주지는 않는다. 그래서 while(1)이 더 안좋은 걸 알면서도 가독성을 위해 while(1)을 쓰기도 한다고 한다.

## **2) do while**

do while은 잘 쓰이진 않는 문법인데, #define으로 매크로 함수를 만들 때 관습적으로 사용한다. 

```c++
#define AAAA(x)
{
	cout << x << endl;
}

int main()
{
    AAAA(10);
}
```
매크로함수는 실제로 호출하는 함수는 아니지만, 함수처럼 사용하고 함수처럼 작동이 된다. 그래서 매크로 함수를 쓸 때는 do-while을 사용해서, 함수와 동등한 문법으로 만들어주게 된다. 위와 같이 그냥 사용할 때는 do-while이 없어도 괜찮지만 아래와 같은 상황에서는 문제가 생기기 때문이다.

```c++
if(x == 0)
	AAAA(10);
else
	AAAA(20);
```
이 코드는 에러가 난다. 매크로함수는 inline처럼 치환하는 것이기 때문에 사실 세미콜론을 붙이지 않아도 된다. 그냥 함수처럼 보이기 위해 쓰는 것 뿐이다. 여기서 세미콜론은 AAAA(x)를 끝낸다는 의미로 쓰이는 게 아니기 때문에 내부적으로 아래와 같이 동작하게 된다

```c++
if(x == 0)
{
	AAAA(10)
};
else
	AAAA(20);
```

if문이 끝난 것처럼 인식되기 때문에 else에서 에러가 나는 것이다. 이때 do-while을 써주면 문제를 해결할 수 있다. 

```c++
#define AAAA(x)
do {

	//

} while(0)
```

중요한 것은 while(0) 뒤에 세미콜론을 붙이지 않는 것이다.

```c++
if(x == 0)
	AAAA(10);
else
	AAAA(20);
```
그러면 위 상황에서 세미콜론이 while(0);을 종료한다는 의미가 되기 때문에 위 식이 의도대로 동작한다. 즉, 반복을 위해서가 아니라 함수처럼 사용하기 위해서 do-while을 사용하는 것이다. 

## **3) goto**

되도록 지양하자는 얘기가 많지만 필요하면 써도 괜찮다. 성능상 크게 문제가 되지는 않는다. 

<br/>

# **4. rand, 난수 생성**

## **1) rand 사용법**

기존 C언어의 rand는 메모리를 거의 쓰지 않고 매우 빠르다. 하지만 좋은 난수 생성기라고 보기는 어렵다. seed만 알면 값을 알아낼 수 있는데다가 분포도 역시 최근 새로 나온 random 함수들에 비해 많이 낮다. 또, rand 값의 범위는 signed short의 범위와 같아서 넓다고 보기 어렵다. 실제로 공식 사이트를 가보면 rand는 암호화적으로 안전하지 않으므로 rand_s를 사용하기를 권장한다. 하지만 고차원적인 rand가 될 수록 메모리와 속도를 많이 차지하는 것에 비해, 기존의 rand는 가볍고 빠르다는 명확한 장점을 가지므로 사용법에 대해 알고 있는 것이 좋다. 

```c++
int main()
{
    int r;
    r = rand();
}
```
위와 같이 rand()를 사용하면 seed값이 기본값으로 설정되기 때문에 아무리 여러번 실행해도 매번 같은 값이 나온다. 따라서 보편적으로 srand에 time값을 seed로 넣어서 사용하게 된다. 참고로 이때 time은 unix timestamp로, 1970년도 1월 1일부터 경과된 초를 의미한다. 이는 언어에 상관 없이 범용적으로 표준처럼 사용하는 시간 값이며, 언어별로 변환하는 함수가 마련되어 있어서 유용하게 사용된다. 

```c++
int main()
{
    int r;
    srand(time(NULL));
    r = rand();
    r = rand();
    r = rand();
}
```
간혹 헷갈리는 경우가 있는데, srand는 한번만 호출해도 된다. 그 이후에는 rand만 계속 하는 것이다. 

최근에는 난수가 필요할 때 서버가 일방적으로 클라에 값을 전달하는 게 일반적이지만, 간혹 서버와 클라가 동일한 난수를 공유하는 게 필요할 때가 있다. 이럴 경우 난수를 직접 구현해야 할 것이다. 그러므로 C언어의 rand가 어떻게 구현되어있는지 어셈블리어를 분석해보자. 

## **2) rand의 원리**

```c++
int main()
{
    int r;
    srand(10);
    r = rand();
}
```
위의 코드에서 srand(10) 부분을 먼저 분석해보자. 

```
push 10
```
우선 srand에 인자를 넣어준다. 
```
call __acrt_getptd
```
스레드를 공부하고 나면 이게 무엇인지 정확하게 알게 되지만, 지금은 런타임 라이브러리가 필요로 하는 정보들을 보관한 공간 정도로 이해해도 된다. 

간단하게 설명하자면, 대부분의 런타임 라이브러리는 함수 호출을 하면 그 일만 하고 끝난다. 그러나 간혹 이전의 호출 데이터를 기억했다가 이를 기억해서 동작시키는 함수들이 있는데, 대표적인 예시가 strtok이다. strtok(ptr, token)는 token을 찾아서 그 주소를 return하는 함수이다. 그런데 처음 한번 실행할 때만 인자값을 넣어주면 이후에는 strtok(nullptr, token)으로 호출해도 잘 작동한다. 이전의 주소값을 기억하기 때문에 이를 이용해서 작동하는 것이다. 하지만 구조상 호출 데이터를 하나밖에 저장할 수 없는데 이는 멀티스레드 환경에서는 큰 결함이 된다. 따라서 멀티스레드 환경에서도 값을 잘 저장해두기 위해 저 ptd라는 구조체를 이용한다. ptd 구조체는 스레드마다 새로 만들어져서 해당하는 데이터를 따로따로 저장한다.

다시 srand(10)의 어셈블리어로 넘어와서, 

```
mov ecx, dword ptr [ebp+8]
```
어셈블리어에서 함수 파라미터 전달은 보통 stack에 push를 하고, 이후 ebp 기준으로 + 위치에 접근하는 방식으로 이루어진다. +8인 걸 보면 현재 base pointer 아래에 있는 값임을 알 수 있고, 방금 내가 넣은 인자 10이 ecx에 담기는 것으로 추론할 수 있다. 실제로 메모리에서 해당 주소를 확인해보면 10이 담겨있다.
```
mov dword ptr [eax+18h], ecx
```

함수는 eax에 값을 넣어서 return 하게 되어있다. 즉, return 값은 무조건 eax를 통해서 전달된다. 함수 호출이 있었고, eax를 사용하지 않았는데 eax를 활용하는 코드가 나온다면 그건 높은 확률로 return 값을 활용하는 것이다. 그리고 eax + 24, 와 같이 +하여 접근하는 것은 보통 구조체 (혹은 클래스) 멤버 메모리에 접근하는 것이라고 해석할 수 있다. 즉, 이전에 return 받은 구조체의 24번째 멤버 위치에 내가 push 했던 seed 값 10을 넣은 것이다. 실제로 eax + 24를 확인해보면 seed 값의 저장 위치임을 알 수 있다. 이렇게 저장만 하고 srand는 끝이 난다. seed값을 넣는 것만 srand의 역할인 것이다. 

이번에는 r = rand()의 어셈블리 부분을 보자 

```
call __acrt_getptd
```
우선 위에서도 사용했던 call __acrt_getptd를 통해 저장했던 값을 불러온다. 
```
imul ecx, dword ptr [eax+18h], 343FDh
add ecx, 269EC3h
mov dword ptr [eax+18h], ecx
shr ecx, 10h
and ecx, 7FFFh
mov eax, ecx
```

기존 seed 값에 엄청 큰 수를 곱하고 더한 다음에 이를 seed에 넣는다. 그리고 10h만큼 right shift를 시킨 0x7FFFh로 마스킹(and)한다. 마지막으로 return을 위해 eax에 계산한 값을 담는다. 

이 과정을 보면 seed값이 기존 seed와 달라졌을 것이라는 사실, 그리고 바뀐 seed값과 출력되는 값이 서로 다르다는 사실을 알 수 있다. 이는 seed 값을 ptd에 저장하여 다음번에 rand()를 호출할 때 그대로 사용하기 때문이다. 그래서 rand()를 여러번 사용할 경우, 여러번 재실행 해도 비슷한 값들이 계속 나온다. 이처럼 내부 연산을 계속 재사용하기 때문에 안전성에도 문제가 있다. 

rand_s 같은 경우에는 window api의 하드웨어 정보를 잡아내서 그걸로 계산을 하게 되어서 보다 안전한 대신, 느리고 메모리 사용량이 많다. 만약 rand()를 사용하되 분포도와 안전성을 더 확보하고 싶다면, 난수 기반의 table을 만들어서 한번 더 돌리거나 재가공 하는 방식을 사용할 수도 있다. 만약 난수를 직접 구현해야 한다면 rand()와 같은 함수들에서 사용하는 방식을 참고하여 구현해도 좋다.

ptd 구조체는 스레드 별로 생성되므로 멀티 스레드에서는 스레드마다 srand()를 해주어야 한다. srand를 하지 않으면 default 값을 seed로 사용하기 때문에 main에서 한번만 한다면 다른 스레드들에서는 다 동일한 값이 나오는 문제가 생길 수 있다. 

[1]:https://chw-owo.github.io/os/Byte-Order,-%EB%B0%94%EC%9D%B4%ED%8A%B8-%EC%98%A4%EB%8D%94/