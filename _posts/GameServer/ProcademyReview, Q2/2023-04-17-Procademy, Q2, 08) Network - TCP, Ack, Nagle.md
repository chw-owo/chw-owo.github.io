---
title: Procademy, Q2, 08) Network - Ack, Nagle
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. Ack**

![image](https://user-images.githubusercontent.com/96677719/232992365-b757fece-d8cd-47d6-83d4-7284bd4112e5.png)

TCP에서는 패킷 도착 여부를 확인하기 위해 ack를 사용한다. 패킷 캡쳐 프로그램에서는 사용자 편의를 고려하여 첫 시퀀스 번호, seq를 0으로 보여주는데 실제로는 0이 아니며 랜덤한 값으로 정해진다. seq는 양측 모두 갖고 있는 자신의 번호, ack는 상대에게 어디까지 수신했는지 알려주기 위한 상대의 번호이다. 예를 들어 seq 1000, len 10 의 패킷을 보냈다면, 수신측은 ack로 1010을 보낼 것이다. 이때 ack는 seq에 메시지 개수가 아닌 페이로드의 바이트, 즉 len을 더한다.

seq 1000, len 10 패킷을 보낸 이후엔 ack 수신 여부에 상관 없이 seq 1010 패킷을 보낸다. 만약 1000, 10/1010, 30/1040, 100를 연달아 보냈고 모두 잘 수신되었다면 수신 측은 ack 1140를 보낸다. 그러나 1010, 30이 누락되어서 1000, 10 다음에 1040, 100이 왔다면, 수신 측은 유실이 있었다고 판단하여 이를 받지 않고 1000, 10에 대한 회신으로 ack 1010를 보낼 것이다. 그럼 송신 측은 1010, 30 / 1040, 100을 재전송한다. 이때 송신측은 재전송을 대비하여 ack가 오기 전까지는 데이터를 보관한다.

TCP는 이와 같은 방식으로 재전송을 보장한다. 수신측은 받은 패킷에 대해 모두 ack를 보내는데 모든 메세지에 매번 바로 응답하는 대신 일정 시간 간격으로 전송한다. 송신측은 일정 시간 동안 ack가 오지 않으면 패킷을 재전송한다. TCP는 직접 조각을 내므로 이런 로직이 포함되며 컨트롤 비트에서 ack를 끌 수도 있지만 보통 켜둔다. 반면 UDP는 조각을 내지 않으므로 MSS에 맞춰 조각내는 로직과 이러한 순서 보장 로직을 L7 계층에서 마련해주어야 한다. 이를 구현한 것을 Reliable UDP라고 한다. 

<br/>

# **2. 3-Way Handshake Ack**

3-Way Handshake 과정의 패킷을 보면 seq 0, len 0 / seq 0, ack 1, len 0 / seq 1, ack 1, len 0임을 확인할 수 있다.  원래대로면 0이 되어야 하는데 1씩 더해지는 것을 볼 수 있다. 여기서 len 0은 데이터 없이 헤더만 보내고 있음을 의미한다. SYN, KEEP ALIVE, FIN처럼 len이 0이되 ACK(응답)를 필요로 하는 경우 ACK의 구분을 위해 위와 같이 1을 더한다. 반면 ZERO WINDOW와 같이 len이 0이지만 ACK가 필요하지 않은 경우에는 ACK 값이 유지된다. 

<br/>

# **3. Nagle**

패킷이 뭉치는 것을 두고 Nagle이라고 부른다. NO DELAY 옵션이 꺼진 경우 기본 설정으로 TCP의 Nagle 알고리즘이 활성화되어 패킷이 MSS 크기로 뭉쳐진다. 옵션이 켜져 있어도 상대의 윈도우 사이즈가 다 차서 보내지지 않은 채로 버퍼에 쌓이는 경우 최대  MSS 크기까지 뭉쳐지다가 한번에 보내진다. 또, 뭉쳐져서 오지 않더라도 receive를 즉각 해주지 않으면 L7에서는 수신 버퍼에 쌓인 패킷들을 뭉쳐진 채로 수신하게 된다. 

뭉친 패킷을 보내는 타이밍은 상대방으로부터 ACK가 왔을 때와 MSS가 가득 찼을 때로 시간은 고려되지 않는다. 이때 ACK는 SYN에 대한 ACK도 포함하므로 첫 패킷은 네이글 없이 그대로 보내게 된다. TCP는 헤더가 크기 때문에 이 과정으로 트래픽 낭비를 줄일 수 있지만, 대신 응답성이 떨어지므로 장르에 맞게 적절히 선택해야 한다. 이때 뭉쳐진 메시지는 L7에서 판단하여 분리하고 이어 붙여야 한다.  

<br/>

# **4. RST**

프로세스를 종료할 경우 모든 연결에 대해 RST를 전송하여 연결이 해제되었음을 통지하고, 통지를 받은 측에서도 연결을 해제한다. RST는 재전송 보장이 되지 않기 때문에 유실되면 송신측은 종료되었음을 알 수 없다. 따라서 RST가 없어도 일정 주기동안 통신 되지 않는다면 자체적으로 연결을 해제한다. 응답이 없으면 일정 횟수 만큼 재전송한 뒤 RST를 보내는데, 트래픽 방지를 위해 계속 응답 속도를 측정하여 그에 맞춰 점점 천천히 보낸다. 재전송 횟수는 레지스트리 키에서 수정할 수 있다. 

<br/>

# **5. TCP segment offload**

대용량을 한번에 보낼 경우 환경에 따라 len 14600, TCP segment offload를 확인할 수도 있다. 이는 L2가 기존의 TCP가 했던 일, 즉 패킷을 조각내고 헤더 붙이는 것을 대신 하고 있음을 의미한다. 이 경우 TCP는 그냥 큰 단위로 패킷을 보내며, 커널이 하던 일을 L2 하드웨어가 처리함으로써 속도가 빨라진다. 이때 수신은 여전히 1460 단위이므로 ack 역시 1460 단위로 돌아온다. 특이한 상황처럼 보이지만 문제가 있는 것은 아니며 재전송 로직 역시 문제 없이 동작한다.