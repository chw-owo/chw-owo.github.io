---
title: 메모리 관리와 IO 5) 메모리 관리
categories: WindowsSystem
tags: 
toc: true
toc_sticky: true
---

이 포스트는 윤성우님의 <뇌를 자극하는 윈도우즈 시스템 프로그래밍 (한빛미디어)> 내용을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 가상 메모리 컨트롤**

## **1) Reserve, Commit, Free**

페이지의 총 개수 = 가상 메모리의 크기 / 페이지 하나당 크기

위와 같은 공식에 따르면, 페이지 개수는 가상 메모리 크기에 비례하며, 이때 모든 페이지는 Reserved, Commit, Free 중 한가지 상태를 지닌다. 이들은 Windows 시스템에서 부여할 수 있는 페이지의 상태이며, Windows에서는 이와 관련하여 가상메모리를 컨트롤 할 수 있는 기능들을 제공하는데 이는 메모리의 효율적인 사용에 도움이 된다. Commit, Free에 대해 그림으로 쉽게 설명하자면 아래와 같다. 

![image](https://user-images.githubusercontent.com/96677719/214892098-c1cfd6a5-3163-482d-ae67-a329951762b4.png)

즉, Commit은 물리메모리에 할당이 이루어진 상태를 의미한다. 이때 물리메모리는 RAM과 하드디스크를 모두 포함한다. 반면 할당이 이루어지지 않은 영역은 FREE 상태에 해당한다. 그러나 간혹 당장 사용할 것은 아니지만 순차적으로 연결된 메모리의 사용량이 점진적으로 늘어날 것으로 예상되는 경우도 있다. 이 경우 Reserve 상태로 만들면 해당 페이지가 물리 메모리에 할당되지는 않는 동시에, 다른 메모리 할당 함수에 의해 해당 페이지가 할당되지 않도록 막을 수 있다. 때문에 reserver 상태에서는 물리 메모리의 소비가 발생하지 않는다.

## **2) 메모리 할당의 시작점과 단위**

페이지 단위로 메모리를 할당하기 위해서는 메모리 할당의 시작 주소와 할당할 메모리의 크기에 대해 고려해야 한다. 가상 메모리 시스템은 페이지 단위로 관리되기 때문에 페이지의 중간 위치에서부터 할당을 시작할 수 없으며 페이지 크기의 배수 단위로 할당을 해야 한다. 만약 페이지 크기가 4KB라면 4KB 배수값 할당 시작 주소가 될 수 있다. 그러나 Windows 시스템에서는 메모리가 지나치게 조각나는 것을 막기 위해 조금 더 넓은 범위를 할당의 경계로 정한다. 이렇게 메모리 할당의 시작 주소가 될 수 있는 기본 단위를 가리켜 Allocation Granularity Boundary이라고 한다. 이는 GetSystemInfo 함수를 통해 얻을 수 있다. 예제는 다음과 같다. 

```c++
GetSystemInfo(&si);
DWORD pageSize = si.dwPageSize;
DWROD allocGranularity = si.dwAllocationGranularity;
```

## **3) VirtualAlloc & VirtualFree**

VirtualAlloc은 페이지를 Reserve, Commit 상태로 만드는 역할을, VirtualFree는 Free 상태로 만드는 역할을 한다. 함수에 대한 설명은 다음과 같다. 

```c++
LPVOID VirtualAlloc (
    LPVOID  lpAddress,
    SIZE_T  dwSize,
    DWORD   flAllocationType,
    DWORD   flProtect
)
```
```c++
LPVOID VirtualFree (
    LPVOID  lpAddress,
    SIZE_T  dwSize,
    DWORD   dwFreeType
)
```
**LPVOID, lpAddress**

상태를 변경하고자 하는 메모리의 시작 주소를 지정한다. NULL을 전달하면 할당하려는 크기에 맞춰 메모리 위치를 임의로 결정한다. 그러나 reserver 상태를 commit 상태로 변경할 때는 주소를 정확히 지정해주어야 한다. 예약을 할때는 Allocation Granularity Boundary를 기준으로 값이 조절되고, 할당할 때는 페이지 크기 단위로 값이 조절된다. 

**SIZE_T, dwSize**

할당/해제하고자 하는 메모리의 크기를 바이트 단위로 지정한다. 실제 메모리의 할당/해제는 지정한 바이트 단위를 포괄하는 최소 페이지 크기 단위로 결정된다. 

**DWORD, flAllocationType**

메모리 할당의 타입을 지정한다. MEM_RESERVE, MEM_COMMIT 등으로 설정할 수 있다. 

**DWORD, dwFreeType**

MEM_DECOMMIT, MEM_RELEASE 중 하나를 지정할 수 있다. MEM_RELEASE를 지정할 경우 해당 페이지가 Free 상태가 되며 물리 메모리가 할당되어 있었다면 반환되게 된다. 이떄, 두번째 전달인자 dwSize는 반드시 0이어야 하고 lpAddress의 값은 예약되었던 메모리의 시작 번지여야 한다. MEM_DECOMMIT의 경우 commit 상태를 reserve 상태로 바꾼다.

**DWORD, flProtect**

페이지별 접근방식에 제한을 두는 용도로 사용한다. 기본적으로 Reserver 상태일 땐 접근을 막는 PAGE_NOACCESS를, commit 상태일 땐 읽기 쓰기를 허용하는 PAGE_READWRITE를 인자로 전달한다. 메모리 보호와 관련된 내용도 존재하니 MSDN을 참조하면 된다. 

함수 호출이 성공하면 할당이 이루어진 메모리의 시작 번지를 반환한다. 

## **4) Dynamic Array Design**

Dynamic Array는 일반적으로 한순간에 배열 크기만큼 물리 메모리가 할당되지 않고 사용량의 증가에 따라 물리 메모리에 할당되는, 즉 배열의 크기가 점진적으로 증가하는 배열을 의미한다. 이러한 배열을 구현한다고 하면 1) Allocation Granularity Boundary 값을 얻어와야 할 것이고 2) 필요하다고 예상되는 최대 크기로 메모리를 예약해야 한다. 3) 그 후 필요한 만큼 메모리를 물리 메모리에 할당하고 4) 다 사용한 뒤에는 할당한 메모리를 반환해야 한다. 이러한 시나리오를 충족할 수 있는 Dynamic Array를 SEH로 구현한 예제는 다음과 같다. 

```c++
#include <stdio.h>
#include <tchar.h>
#include <windows.h>

#define MAX_PAGE 5

int* nextPageAddr;
DWORD pageCnt = 0;
DWORD pageSize;
int PageFaultExceptionFilter(DWORD);

int _tmain(int argc, TCHAR* argv[])
{
	LPVOID baseAddr;
	int* lpPtr;
	SYSTEM_INFO sSysInfo;

	GetSystemInfo(&sSysInfo);
	pageSize = sSysInfo.dwPageSize;

	baseAddr = VirtualAlloc(
		NULL, MAX_PAGE * pageSize, MEM_RESERVE, PAGE_NOACCESS);

	if (baseAddr == NULL)
		_tprintf(_T("VirtualAlloc reserve fail!\n"));

	lpPtr = (int*)baseAddr;
	nextPageAddr = (int*)baseAddr;

	for(int i = 0; i < ((MAX_PAGE * pageSize) / sizeof(int)); i++)
	{ 
		__try
		{
			lpPtr[i] = i;
		}
		__except (PageFaultExceptionFilter(GetExceptionCode()))
		{
			ExitProcess(GetLastError());
		}
	}

	for (int i = 0; i < (MAX_PAGE * pageSize) / sizeof(int); i++)
		_tprintf(_T("%d "), lpPtr[i]);


	BOOL isSuccess = VirtualFree( baseAddr, 0, MEM_RELEASE );
	if(isSuccess)
		_tprintf(_T("Release Success!\n"));
	else
		_tprintf(_T("Release fail!\n"));
}

int PageFaultExceptionFilter(DWORD exptCode)
{
	if (exptCode != EXCEPTION_ACCESS_VIOLATION)
	{
		_tprintf(_T("Exception code = %d\n"), exptCode);
		return EXCEPTION_EXECUTE_HANDLER;
	}
	_tprintf(_T("Exception is a page fault\n"));

	if(pageCnt >= MAX_PAGE)
	{
		_tprintf(_T("Exception: out of pages\n"));
		return EXCEPTION_EXECUTE_HANDLER;
	}

	LPVOID lpvResult = VirtualAlloc(
		(LPVOID) nextPageAddr, pageSize, MEM_COMMIT, PAGE_READWRITE);

	if (lpvResult == NULL)
	{
		_tprintf(_T("VirtualAlloc fail!\n"));
		return EXCEPTION_EXECUTE_HANDLER;
	}
	else
		_tprintf(_T("Allocating another page.\n"));

	pageCnt++;
	nextPageAddr += pageSize / sizeof(int);

	return EXCEPTION_CONTINUE_EXECUTION;
}
```

<br/>

# **2. 힙 컨트롤**

## **1) 디폴트 힙과 Windows System의 힙**

## **2) 디폴트 힙 컨트롤**

## **3) 힙의 이점**

## **4) 힙의 생성, 소멸, 할당**

## **5) 힙과 링크드리스트**

<br/>

# **3. MMF**

## **1) MMF의 이해**

## **2) MMF의 구현 과정**

## **3) MMF의 구현 함수**

## **4) MMF의 구성 예제**

## **5) 읽고 쓰기 위한 MMF**

## **6) Copy-On-Write**

<br/>

# **출처**

뇌를 자극하는 윈도우즈 시스템 프로그래밍, 윤성우, 한빛미디어
