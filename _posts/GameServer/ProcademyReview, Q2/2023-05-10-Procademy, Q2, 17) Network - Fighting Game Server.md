---
title: Procademy, Q2, 17) Network - Fighting Game Server
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---

이 포스트는 프로카데미 (게임 서버 아카데미) 수업을 바탕으로 공부한 내용을 정리한 것입니다. 

# **1. 개요**

select 모델을 사용하여 8방향의 이동과 3종류의 공격을 처리할 수 있는 Fighting Game 서버를 만든다. 클라는 제공되는 것을 사용하며 서버에서 충돌 처리, 사망 처리를 한 후 그 결과를 서버에서 클라들에게 전송한다. 

<br/>

# **2. 이동과 공격**

이동의 경우 매 프레임 좌표를 보내는 것은 비효율적이므로 보통 일정 간격의 이동 경로를 바탕으로 데드렉 커닝을 한다. 이 예제의 경우 간단하게 하기 위해 이동 시작과 결과만 통보한다. 클라는 클라대로, 서버는 서버대로 이동 경로를 계산한 후 최종 결과만 비교하여 오차 범위 내일 경우 클라에서 통보한 이동 결과를 반영한다. 이로 인해 생기는 약간의 좌표 차이는 무시하며, 오차 범위 밖일 경우 연결을 끊는다. 실제 게임에서는 목적지 메시지만 클라에서 보내고 좌표는 서버가 결정해서 뿌려주는 방식으로 구현하는 경우가 더 많다.

이동, 공격은 키가 눌렸을 때 동작을 취함과 동시에 패킷을 보내고, 충돌 처리 및 데미지 정보는 서버에서 처리하고 바로 통보한다. 그 후 서버로부터 정보가 도착하면 이펙트 및 hp 감소를 보여준다. 이때, 이펙트는 보통 공격 동작의 끝에 터지지만 hp 감소는 서버로부터 메시지가 오자마자 반영하기 때문에 자세히 보면 hp가 먼저 줄어들고 이펙트가 터진다. 이 예제는 충돌 처리 메시지가 오면 공격의 특정 프레임에서 터지도록 그때까지 기다리기 때문에 충돌 이펙트가 너무 늦게 올 경우 무시되거나 다음 공격에서 두번 발생할 수 있다. 

공격은 과거에 보낸 데이터를 바탕으로 충돌 처리를 하기에 약간의 좌표 차이가 날 수 있다. 공격이 대상에게 닿기 이전에 충돌 처리 메시지가 도착해야 되기 때문에 이러한 차이는 어쩔 수 없다. 그걸 고려해서 서버에서 대상에 닿는 시점의 위치를 바탕으로 충돌 처리 한다면 클라에서는 해당 결과를 너무 늦게 받게 된다. 모 게임에서는 이를 부드럽게 처리하기 위해 공격 애니메이션 초입부까지 클라에서 보여준 뒤 최종 공격 이펙트는 메시지를 받은 다음 처리하기도 한다. 

<br/>

# **3. 프로토콜**

프로토콜의 경우, 패킷 코드 0x89가 아니면 무시하고 로그 남긴다. 우선 패딩 없앤 구조체로 구현하되, 이후에 직렬화 버퍼를 만들어서 교체할 예정이다. 메시지 이름의 경우 SC-CS 혹은 Req-Res로 방향성을 표시한다. CS_MOVE 는 한 방향으로 쭉 이동하는 것으로, 이동 중에는 패킷을 보내지 않으며 방향이 변경될 때와 이동이 끝났을 때만 보낸다.  SC_MOVE의 경우 당사자에겐 가지 않고 그 외 다른 유저에게만 전송한다. 소켓 단위로 세션이 관리되기 때문에 일부 MOVE, ATTACK 패킷에서는 ID를 굳이 넣지 않는다.

이 예제에서는 콘텐츠 용도별로 메시지 번호에 간격을 두고 있지만, 실제로는 그럴 필요 없다. 어차피 유지 보수를 위해 새로운 메시지는 콘텐츠 용도와 상관 없이 주석을 달아서 맨 뒤에 넣게 된다. 물론 사용 장소가 명확히 나눠진다면 구역을 나눠 분기 처리 해도 좋다. 이때, 스위치 테이블이 사라질 것을 대비해 함수 외형들을 똑같이 맞추는 것이 좋다. 그러면 테이블이 사라져도 해시 테이블에 함수 포인터를 등록하거나 함수 포인터 배열을 쓰는 등 다른 방식으로 쉽게 바꿀 수 있다.

또, 메시지 당 생성 함수를 하나씩 만들어서 메시지는 다 함수 내부에서 만들도록 하고, 메시지 생성 함수들을 한 파일에 몰아넣는 것이 좋다. 이렇게 해야 메시지가 3-500개 이상으로 늘어나도 관리가 가능하다. 이때 생성 함수 인자를 플레이어 포인터로 넘기면 플레이어 헤더가 수정될 때마다 컴파일을 다시 해야 되므로 인자가 많지 않다면 요소 하나씩 전달하는 것이 낫다. 물론 인자가 2-30개까지 늘어나면 그땐 플레이어 포인터를 보낼 것이다. 

<br/>

# **4. 프레임**

서버에서 프레임이 떨어지면 좌표 틀어짐으로 인한 버벅임이 생긴다. 이에 대한 보정 코드를 넣으면 중간 없이 한번에 이동할텐데 어느쪽을 택할 지는 선택 사항이다. 클라와 달리 서버에서는 생략해도 되는 영역이 없기 때문에 프레임의 최대치만 정하게 된다. 이때 프레임 단위로 가면 0~20ms의 sleep 때문에 당장 recv, send를 할 수 있음에도 불구하고 기다리게 되는데, 이를 방지하고 싶다면 Login Update 안에서 sleep(0~20ms)를 하면 된다. 이 문제는 멀티스레드로 가서 네트워크와 로직의 스레드가 분리되면 자연스럽게 해결된다. 

또, 싱글 스레드 환경에서는 프레임을 50으로 맞췄다면 1초에 50명밖에 accept 못한다. 물론 멀티스레드가 되면 accept 하는 스레드를 따로 두기 때문에 문제가 되지 않는다. 꼭 싱글 스레드로 개발을 해야 된다면 accept가 끝날 때까지 loop를 돌거나, listen_sock 의 FD_READ를 한 프레임 안에서 여러번 확인하는 등의 방법으로 처리해야 한다. 이때 select는 느린 작업이므로 가능한 호출 횟수를 최소화 하는 게 좋다. 

<br/>

# **5. 초기화**

초기화 할 때 데이터를 다 불러온다. 클라이언트에서 사용하는 그래픽적 리소스는 필요 없겠지만 컨텐츠와 관련된 모든 데이터는 거의 동일하게 사용한다. 추가적으로, 서버 연산에 필요한 일부 데이터는 클라이언트에 없고 서버에만 있기도 하다. 따라서 서버에서 로딩해야 할 데이터가 대체로 더 많다. 클라이언트의 파일을 서버 실행파일 옆에 두고 공유하기도 하고, 서버 데이터와 클라 데이터를 DB에 올리는 과정을 추가하여 모든 걸 DB에 두기도 한다. 
