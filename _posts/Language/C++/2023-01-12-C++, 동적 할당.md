---
title: C++, 동적 할당
categories: cpp
tags: 
toc: true
toc_sticky: true
---

이 포스트는 Rookiss님의 \<C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈 Part1: C++ 프로그래밍 입문> 수업을 바탕으로 공부한 내용을 정리한 것입니다. 
## **1. 동적 할당이란?**

플레이어 및 플레이어 수에 비례하여 만들어지는 몬스터, 아이템 등 규모가 가변적인 변수를 선언할 때, 정적 영역에 최대값으로 선언하면 메모리를 불필요하게 많이 사용하게 될 수 있다. 따라서 이처럼 변동 가능성이 높은 것은 동적으로 할당하는 것이 더 효율적인 경우가 많다. 따라서 우리가 생성, 소멸 시점을 관리할 수 있는 동적 할당 기능이 필요하다. 

기본적으로는 C++에서 기본으로 제공하는 CRT(C RunTime Library)의 힙 관리자를 통해 힙 영역을 사용하지만, MMORPG 서버 메모리 풀링 등과 같은 고급 기법에서는 직접 API를 통해 힙을 생성하고 관리하기도 한다. 

<br/>

## **2. 동적 할당 문법**

**1) malloc**

동적으로 메모리를 할당할 때 사용된다.

```c++
void* ptr = malloc(1000);
```

위와 같이 사용할 경우 1000byte만큼 할당하여 그 할당 받은 메모리 영역의 시작 주소를 ptr라는 pointer 변수에 넣어주는 것을 의미한다. 메모리 부족으로 요청 받은 크기의 메모리를 할당해줄 수 없으면 NULL을 반환한다. 

이때 void 형의 포인터는 해당 주소에 무엇이 있는지 아직 알 수 없으니 (혹은 정해지지 않았으니) 변환해서 사용하라는 의미로 사용된다.

```c++
void* ptr = malloc(1000);

Monster* m1 = (Monster*)ptr;
m1->hp = 100;
m1->attack = 10;
```
위 코드처럼 형변환을 거쳐 원하는 자료형의 변수로 사용할 수 있다. 

```c++
void* ptr = malloc(sizeof(Monster));

Monster* m1 = (Monster*)ptr;
m1->hp = 100;
m1->attack = 10;
```
만약 Monster의 크기만큼만 할당받고 싶다면 위와 같이 적으면 된다. 

유효한 힙 범위를 초과하여 사용할 경우 Heap Overflow가 발생할 수 있다. 

<br/>

**2) free**

malloc으로 할당한 영역을 해제할 때 사용한다. 

```c++
free(ptr);
```
위처럼 간단하게 해제할 수 있다. 디버그 모드에서 메모리를 켜두고 이걸 실행해보면, malloc으로 할당되어있던 메모리 영역이 비활성화 되는 것을 확인할 수 있다. 몇 byte를 해제하는지 따로 기입하지 않아도 된다. malloc이 일어날 때 할당된 메모리의 header 영역에 몇 byte를 할당했는지에 관한 정보가 적혀있기 때문이다.

free와 관련된 실수는 치명적인 문제를 낳을 수 있다. 

이미 free한 메모리를 다시 free 할 경우 (Double free) 바로 크래쉬가 난다. 이 경우에는 바로 문제를 파악할 수 있어서 그나마 괜찮다. 

만약 할당을 한 뒤 free를 하지 않는 실수가 생기면, 당장 프로그램 실행에는 문제가 없지만 메모리 누수가 계속 발생하여 후에 큰 문제가 생길 수 있다. 

Use-After-Free의 경우에도 큰 문제가 생길 수 있다. free가 일어나면 더 이상 현재 프로그램에 메모리가 할당되어 있지는 않지만, 여전히 ptr은 해당 주소값을 갖고 있다. 이때, free 한 걸 잊고 이 주소로 접근하게 되면 엉뚱한 값, 때로는 위험한 값을 건드리게 될 수도 있다. 

<br/>

**3) new / delete**

```c++
Monster* m = new Monster;
...
delete m;
```

메모리를 동적으로 할당한다는 점에서 malloc과 동일하지만, 이 경우에는 할당 받을 크기를 입력하지 않아도 자료형의 크기에 맞게 알아서 메모리를 할당해준다. malloc / free에서와 마찬가지로 할당을 받으면 해제를 해주어야 하며, 해제를 잘못했을 때의 문제 사항 역시 동일하게 나타난다. 

```c++
Monster* m0 = new Monster[5];
...
delete[] m;
```

new / delete의 경우 배열의 형식으로 할당 받고 해제할 수 있다. 이 역시 자동으로 배열의 크기에 맞게 메모리를 할당해준다. 

```c++
Monster* m0 = new Monster[5];
Monster* m1 = (m0 + 1);
Monster* m2 = (m0 + 2);
...
delete[] m;
```

동적 할당도 포인터로 주소를 전달 받기 때문에 포인터에서의 연산이 동일하게 적용된다.

## **3. malloc/free vs new/delete**

기본적으로는 특정 타입의 데이터만 할당받는다고 하면 사용 편의성을 고려했을 때 malloc/free보다 new/delete가 편리하다. 그러나 타입에 상관없이 특정 크기의 메모리 할당이 필요하다면 malloc/free가 필요할 것이다.

그러나 이 둘의 근본적인 차이는 malloc/free는 함수인 반면 new/delete는 연산자라는 것, 그리고 **new/delete의 경우 생성 타입이 클래스라면 생성자/소멸자를 호출해준다는 것**에 있다. malloc/free는 c에서부터 사용되던 방법인 반면 new/delete는 c++에서 도입된 문법이기에 이런 차이를 보인다. 

<br/>

## **출처**

[C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈] Part1: C++ 프로그래밍 입문, Rookiss
