---
title: C++, 객체지향 1) 객체지향 기초
categories: C++
tags: 
toc: true
toc_sticky: true
---
## **1. 객체지향이란?**

**1) 절차 지향 프로그래밍**
 
함수를 주로 이용하여 절차적으로 프로그램을 제어하는 것을 지향하는 프로그래밍 방법론

**2) 객체 지향 프로그래밍**

프로그램에서 사용되는 데이터들을 객체로 만든 뒤, 객체들끼리의 상호작용을 주로 이용하여 프로그램을 제어하는 것을 지향하는 프로그래밍 방법론. 

c++은 c에서 발전했기 때문에 처음부터 객체지향적으로 설계된 프로그램이라기보단 절차지향적 언어에 객체지향적인 특징이 보완된 언어라고 볼 수 있다. 따라서 Java와 같은 타 객체지향 언어에 비해 덜 객체지향적인 부분이 있으나 객체지향 언어의 특징은 대부분 충족하고 있기에 객체지향 언어라고 할 수 있다. 

<br/>

## **2. Class 기본 문법**

c언어에서의 struct와 c++에서의 class에는 큰 차이가 있지만, c++에서는 struct안에도 함수를 만들 수 있게 되며 struct와 class 사이에 큰 차이가 없어졌다. 단, 은닉성의 측면에 있어서는 차이를 갖는데 이는 은닉성 파트에서 다시 설명하고자 한다. struct에서와 마찬가지로 class는 설계도일 뿐, class로 만든 변수는 크기를 갖지만 class를 선언하는 자체는 메모리에서 데이터로서 크기를 차지하지 않는다. 

```c++
class Knight
{

public:
    void Move(int y, int x);
    void Attack();
    void Die();

public:
    int hp;
    int attck:
    int posX;
    int posY;
}
```
이때, class 안에 속해 있는 함수를 해당 class의 멤버 함수, 변수를 멤버 변수라고 부른다.  

```c++
class Knight
{

public:
    void Move(int y, int x);
    void Attack();
    void Die()
    {
        ...
    }


public:
    int hp;
    int attck:
    int posX;
    int posY;
}

void Knight::Move(int y, int x)
{
    ...
}

void Knight::Attack()
{
    ...
}
```
함수 정의는 위처럼 class 내부에서 해도 되고 class 외부에서 해도 무관하다. class의 멤버 함수의 경우 자신의 멤버 변수에 직접 접근할 수 있다. 즉, 함수를 통해 값을 바꿀 수 있다.

<br/>

```c++
class Knight
{

public:
    void Move(int y, int x);
    void Attack();
    void Die();

public:
    int hp;
    int attck:
    int posX;
    int posY;
}

void Knight::Move(int y, int x)
...

int main()
{
    Knight k1;
    k1.hp = 100;
    k1.attack = 10;
    k1.posY = 0;
    k1.posX = 0;

    Knight k2;
    k2.hp = 80;
    k2.attack = 5;
    k2.posY = 1;
    k2.posX = 1;

}
```

struct에서와 마찬가지로 위처럼 class를 이용해 변수를 만들어주게 되면 메모리에 멤버 변수의 총합 크기만큼 데이터가 올라가게 된다. 멤버 함수는 데이터로서 공간을 차지하지 않는다. 이때 k1, k2는 독립된 객체로 동작하며, 메모리에도 따로 올라간다. 

```c++
int main()
{
    Knight k1;
    k1.hp = 100;
    k1.attack = 10;
    k1.posY = 0;
    k1.posX = 0;

    k1.Move(2,2);
    k1.Attack();
    k1.Die();
}
```
위와 같이 멤버 함수 역시 사용할 수 있다. 

아래에, class의 멤버 함수를 사용할 때와 일반적인 함수에 참조 값 내지는 포인트 값을 넘겨서 사용하는 것 두개는 어떤 차이가 있는지 어셈블리어를 확인해보았다. 

**일반적인 함수**
```
lea     eax, [k1]
push    eax
call    Move
```

**멤버 함수**
```
lea     ecx, [k1]
call    Knight::Move
```
stack에 push해서 넘겨주느냐, 레지스터에 담은 상태에서 넘겨주느냐의 미묘한 차이를 제외하면 동작하는 방식은 동일했다. 

Knight::Move 내부에서 어떻게 동작하는지 자세히 확인해보았다.

```
mov     dword ptr [this], ecx

mov     eax, dword ptr [this]
mov     ecx, dword ptr [y]
mov     dword ptr [eax+8], ecx
```
ecx를 통해 넘겨주었던 k1의 데이터를 this에 넣고, 매개변수 y로 받은 데이터를 this + 8의 주소 공간에 넣는 것을 확인할 수 있다. 그동안 pointer를 매개변수로 넘겨서 사용했던 문법과 크게 다르지 않게 동작하는 것을 볼 수 있다. 

<br/>

## **출처**

[C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈] Part1: C++ 프로그래밍 입문, Rookiss
