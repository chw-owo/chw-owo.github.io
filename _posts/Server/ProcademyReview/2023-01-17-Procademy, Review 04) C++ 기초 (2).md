---
title: Procademy, Review 04) C++ 기초 (2)
categories: ProcademyReview
tags: 
toc: true
toc_sticky: true
---
## **1. 연산자와 수식**

**1) 자료형 변환**

```c++
int main()
{
	int x = 394028;
	char a = x;
}
```
이렇게 초과하는 값을 넣을 경우 x의 하위 1byte(char의 size)만 char에 들어가게 된다. 

 ```c++
char a = x;
```

즉, 이러한 대입은 x의 첫 메모리 주소에 가서 값을 복사해넣으라는 의미인 것을 알 수 있다. 우리가 사용하는 컴퓨터가 리틀 엔디안을 사용하기 때문에 1byte만 들어가는 것이다. 만약 빅 엔디안을 사용하는 컴퓨터라면, 상위 값이 00이니까 a에 00이 들어가게 된다. 리틀 엔디안, 빅 엔디안의 개념은 [리틀 엔디안, 빅 엔디안에 관한 포스트][1] 참조. 

프로그래머로서 빅 엔디안으로 이루어진 컴퓨터를 사용할 일은 웬만해서는 없다. 하지만 네트워크 장비의 경우 빅 엔디안을 사용한다. 따라서 네트워크 프로그래밍을 할 때, 네트워크 장치가 사용할 데이터에 한해서 빅 엔디안으로 변환해주어야 한다. 클라이언트와 주고 받는 데이터 (ex 포지션, 레벨 등)은 어차피 패킹되어서 전달되기 때문에 변환할 필요 없지만, 주소와 관련된 값은 빅엔디안으로 변환하여 주고 받고, 사용할 때 다시 리틀 엔디안으로 변환해야 한다. 

```c++
int* p  = (int*)  x;
```

이러한 상황에서도 x의 포인터 값이 아니라 x의 값이 p에 그대로 들어가게 된다. 실수와 정수 간의 변환을 제외하면 C언어에서의 캐스팅은 실제로 데이터를 바꿔주는 것이 아니다. 실제로 어셈블리에서도 캐스팅이라는 개념은 없다. 실수가 아니라 의도한 변환이니 이대로 진행하라고 명령하는 것뿐이다. 


<br/>

**2) sizeof()**

<br/>

**3) 연산자 우선 순위**

<br/>

## **2. 조건문**

**1) if**

<br/>

**2) switch-case**

<br/>

## **3. 반복문**

**1) while vs for**

<br/>

**2) do while**

<br/>

**3) goto**

<br/>

## **4. 그 외**

**1) rand**

<br/>

## **출처**

[1](https://chw-owo.github.io/os/Byte-Order,-%EB%B0%94%EC%9D%B4%ED%8A%B8-%EC%98%A4%EB%8D%94/)